<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[iOS面试题3--C语言]]></title>
    <url>%2F2018%2F09%2F12%2FiOS%E9%9D%A2%E8%AF%95%E9%A2%983-C%E8%AF%AD%E8%A8%80%2F</url>
    <content type="text"><![CDATA[C语言，开发的基础功底，iOS很多高级应用都要和C语言打交道，所以，C语言在iOS开发中的重要性，你懂的。里面的一些问题可能并不是C语言问题，但是属于计算机的一些原理性的知识点，所以我就不再另外写一篇文章了，直接写在这里。 当你写下面的代码时会发生什么事？ least = MIN(*p++, b); 结果是：((p++) &lt;= (b) ? (p++) : (*p++)) 这个表达式会产生副作用，指针p会作三次++自增操作。 用预处理指令#define声明一个常数，用以表明1年中有多少秒（忽略闰年问题）#define SECONDS_PER_YEAR (60 * 60 * 24 * 365)UL(UL无符号长整形) 写一个”标准”宏MIN ，这个宏输入两个参数并返回较小的一个。#define MIN(A,B) （（A） &lt;= (B) ? (A) : (B)) 写一个标准宏Max，并给出以下代码的输出int array[5] = {1, 2, 3, 4, 5}; int *p = &amp;array[0]; int max = Max(*p++, 1); printf("%d %d", max, *p); 参考答案： 1，2 #define Max(X, Y) ((X) > (Y) ? (X) : (Y)) 当看到宏时，就会想到宏定义所带来的副作用。对于++、–，在宏当中使用是最容易产生副作用的，因此要慎用。 分析： p指针指向了数组array的首地址，也就是第一个元素对应的地址，其值为1. 宏定义时一定要注意每个地方要加上圆括号 *p++相当于*p, p++,所以Max(*p++, 1)相当于： (*p++) > (1) ? (*p++) : (1) => (1) > (1) ? (*p++) : (1) => 第一个*p++的结果是，p所指向的值变成了2，但是1 > 1为値，所以最终max的值就是1。而后面的(*p++)也就不会执行，因此p所指向的地址对应的值就是2，而不是3. 扩展：如果上面的*p++改成*(++p)如何？ (*++p) > (1) ? (*++p) : (1) => (2) > (1) ? (*++p) : (1) => max = *++p; => *p = 3，max = 3; define定义的宏和const定义的常量有什么区别？λ #define定义宏的指令，程序在预处理阶段将用#define所定义的内容只是进行了替换。因此程序运行时，常量表中并没有用#define所定义的宏，系统并不为它分配内存，而且在编译时不会检查数据类型，出错的概率要大一些。 λ const定义的常量，在程序运行时是存放在常量表中，系统会为它分配内存，而且在编译时会进行类型检查。 #define定义表达式时要注意“边缘效应”，例如如下定义： #define N 2 + 3 // 我们预想的N值是5，我们这样使用N int a = N / 2; // 我们预想的a的值是2.5，可实际上a的值是3.5 关键字volatile有什么含意?并给出三个不同的例子 优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。下面是volatile变量的几个例子： 并行设备的硬件寄存器（如：状态寄存器） 一个中断服务子程序中会访问到的非自动变量(Non-automatic variables) 多线程应用中被几个任务共享的变量 完成字符串拷贝可以使用sprintf、strcpy、以及memcpy函数，请问这些函数有什么区别?你喜欢哪一个？为什么？这些函数的区别在于实现功能以及操作对象不同。 strcpy：函数操作的对象是字符串，完成从源字符串到目的字符串的拷贝功能。 sprintf：这个函数主要用来实现（字符串或基本数据类型）向字符串的转换功能。如果源对象是字符串，并且指定%s格式符，也可实现字符串拷贝功能。 memcpy：函数顾名思义就是内存拷贝，实现将一个内存块的内容复制到另一个内存块这一功能。内存块由其首地址以及长度确定。因此，memcpy 的操作对象适用于任意数据类型，只要能给出对象的起始地址和内存长度信息、并且对象具有可操作性即可。鉴于memcpy函数等长拷贝的特点以及数据类型代表的物理意义，memcpy函数通常限于同种类型数据或对象之间的拷贝，其中当然也包括字符串拷贝以及基本数据类型的拷贝。 对于字符串拷贝来说，用上述三个函数都可以实现，但是其实现的效率和使用的方便程度不同： strcpy 无疑是最合适的选择：效率高且调用方便。 snprintf 要额外指定格式符并且进行格式转化，麻烦且效率不高。 memcpy 虽然高效，但是需要额外提供拷贝的内存长度这一参数，易错且使用不便；并且如果长度指定过大的话（最优长度是源字符串长度 + 1），还会带来性能的下降。其实 strcpy 函数一般是在内部调用 memcpy函数或者用汇编直接实现的，以达到高效的目的。因此，使用 memcpy 和 strcpy 拷贝字符串在性能上应该没有什么大的差别。 对于非字符串类型的数据的复制来说，strcpy和snprintf一般就无能为力了，可是对memcpy却没有什么影响。但是，对于基本数据类型来说，尽管可以用 memcpy 进行拷贝，由于有赋值运算符可以方便且高效地进行同种或兼容类型的数据之间的拷贝，所以这种情况下memcpy几乎不被使用。memcpy的长处是用来实现（通常是内部实现居多）对结构或者数组的拷贝，其目的是或者高效，或者使用方便，甚或两者兼有。 sprintf,strcpy,memcpy使用上有什么要注意的地方 strcpy是一个字符串拷贝的函数，它的函数原型为strcpy(char dst, const char src); 将src开始的一段字符串拷贝到dst开始的内存中去，结束的标志符号为 ‘\0’，由于拷贝的长度不是由我们自己控制的，所以这个字符串拷贝很容易出错。 具备字符串拷贝功能的函数有memcpy，这是一个内存拷贝函数，它的函数原型为memcpy(char dst, const char src, unsigned int len);将长度为len的一段内存，从src拷贝到dst中去，这个函数的长度可控。但是会有内存读写错误。(比如len的长度大于要拷贝的空间或目的空间) sprintf是格式化函数。将一段数据通过特定的格式，格式化到一个字符串缓冲区中去。sprintf格式化的函数的长度不可控，有可能格式化后的字符串会超出缓冲区的大小，造成溢出。 static关键字的作用 隐藏。编译多个文件时，所有未加static前缀的全局变量和函数都全局可见。 保持变量内容的持久。全局变量和static变量都存储在静态存储区，程序开始运行就初始化，只初始化一次。static控制了变量的作用范围。 默认初始化为0.在静态数据区，内存中的所有字节都是0x00，全局变量和static变量都是默认初始化为0. static关键字区别： static全局变量与普通的全局变量有什么区别：static全局变量只初使化一次，防止在其他文件单元中被引用; static局部变量和普通局部变量有什么区别：static局部变量只被初始化一次，下一次依据上一次结果值； static函数与普通函数有什么区别：static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝 关键字const const int a;int const a; 作用是一样：a 是一个常整型数 const int a;int const a; a 是一个指向常整型数的指针(整型数是不可修改的，但指针可以) int * const a;a 是一个指向整型数的常指针(指针指向的整型数是可以修改的，但指针是不可修改的) int const * const a;a 是一个指向常整型数的常指针(指针指向的整型数是不可修改的，同时指针也是不可修改的) 堆栈 管理方式：对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生内存泄露 (memory leak)。 申请大小： 栈：在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在Windows下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示 overflow。因此，能从栈获得的空间较小。 堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。 碎片问题： 对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个 问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出 分配方式： 堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由 alloc函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。 分配效率： 栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的 效率比较高。堆则是C/C++函数库提供的，它的机制是很复杂的 数组和指针的区别 数组可以申请在栈区和数据区；指针可以指向任意类型的内存块 sizeof作用于数组时，得到的是数组所占的内存大小；作用于指针时，得到的都是4个字节的大小 数组名表示数组首地址，是常量指针，不可修改指向。比如不可以将＋＋作用于数组名上；普通指针的值可以改变，比如可将＋＋作用于指针上 用字符串初始化字符数组是将字符串的内容拷贝到字符数组中；用字符串初始化字符指针是将字符串的首地址赋给指针，也就是指针指向了该字符串 引用和指针的区别 指针指向一块内存，内容存储所指内存的地址。 引用是某块内存的别名。 引用使用时不需要解引用（*）而指针需要 引用只在定义时被初始化，之后不可变，指针可变。 引用没有const 引用不能为空 sizeof引用得到的是所指向变量（对象）的大小，sizeof指针是指针本身的大小。 指针和引用的自增(++)运算意义不一样：引用++为引用对象自己++，指针++是指向对象后面的内存 程序需要为指针分配内存区域，引用不需要。 用变量a给出下面的定义 一个整型数（An integer） 一个指向整型数的指针（ A pointer to an integer） 一个指向指针的的指针，它指向的指针是指向一个整型数（ A pointer to a pointer to an intege）r 一个有10个整型数的数组（ An array of 10 integers） 一个有10个指针的数组，该指针是指向一个整型数的。（An array of 10 pointers to integers） 一个指向有10个整型数数组的指针（ A pointer to an array of 10 integers） 一个指向函数的指针，该函数有一个整型参数并返回一个整型数（A pointer to a function that takes an integer as an argument and returns an integer） 一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数（ An array of ten pointers to functions t hat take an integer argument and return an integer ） 答案是： int a; // An integer int *a; // A pointer to an integer int **a; // A pointer to a pointer to an integer int a[10]; // An array of 10 integers int *a[10]; // An array of 10 pointers to integers int (*a)[10]; // A pointer to an array of 10 integers int (*a)(int); // A pointer to a function a that takes an integer argument and returns an integer int (*a[10])(int); // An array of 10 pointers to functions that take an integer argument and return an integer 请写出以下代码输出int a[5] = {1, 2, 3, 4, 5}; int *ptr = (int *)(&amp;a + 1); printf("%d, %d", *(a + 1), *(ptr + 1)); 参考答案： 2, 随机值 这种类型题好像挺常见的。考的就是C语言上的指针的理解和数组的理解。 分析： a代表有5个元素的数组的首地址，a[5]的元素分别是1，2，3，4，5。接下来，a + 1表示数据首地址加1，那么就是a[1]，也就是对应于值为2.但是，这里是&amp;a + 1，因为a代表的是整个数组，它的空间大小为5 * sizeof(int)，因此&amp;a + 1就是a+5。a是个常量指针，指向当前数组的首地址，指针+1就是移动sizeof(int)个字节。 因此，ptr是指向int *类型的指针，而ptr指向的就是a + 5，那么ptr + 1也相当于a + 6，所以最后的*(ptr + 1)就是一个随机值了。而*(ptr – 1)就相当于a + 4，对应的值就是5。 简述内存分区情况 代码区：存放函数二进制代码 数据区：系统运行时申请内存并初始化，系统退出时由系统释放，存放全局变量、静态变量、常量 堆区：通过malloc等函数或new等操作符动态申请得到，需程序员手动申请和释放 栈区：函数模块内申请，函数结束时由系统自动释放，存放局部变量、函数参数 用NSLog函数输出一个浮点类型，结果四舍五入，并保留一位小数float money = 1.011; NSLog(@"%.1f", money);]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS面试题2--UNIX常用命令]]></title>
    <url>%2F2018%2F09%2F12%2FiOS%E9%9D%A2%E8%AF%95%E9%A2%982-UNIX%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[做开发说用不到命令行，那肯定是不可能的。所以记住几个常用的命令还是很有用。 cd 改变工作目录 pwd 输出当前工作目录的绝对路径 在UNIX中要执行什么命令，一定要知道自己当前所在的工作目录 ls 查看文件 $ ls 显示文件 $ ls -a 显示所有文件 $ ls -l 列表显示文件 $ ls -la 列表显示所有文件 touch 用于更改文件访问和修改时间的标准UNIX程序，也被用于创建新文件 $ touch test.txt 注意：touch不修改test.txt内容，只更改它的访问、修改时间，如果test.txt不存在，它会被创建 cat 连续查看文件内容 more 分页查看文件内容 提示： 1&gt; 命令和参数之间需要添加空格 2&gt; 如果要使用当前目录中的文件名，输入到一半时，按TAB键能够补全]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS面试题1--版本控制]]></title>
    <url>%2F2018%2F09%2F12%2FiOS%E9%9D%A2%E8%AF%95%E9%A2%981-%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[面试过程中，可能会问及一些关于版本控制的问题，理解下SVN和Git的原理，记住常用命令即可。 SVN SVN 是集中式源代码管理工具 概念： 1&gt; Repository 代码仓库，保存代码的仓库 2&gt; Server 服务器，保存所有版本的代码仓库 3&gt; Client 客户端，只保存当前用户的代码仓库 4&gt; 用户名&amp;密码 访问代码仓库需要使用自己的&quot;用户名和密码&quot;，从而可以区分出不同的人对代码做的修改 操作： 1&gt; checkout 将服务器上最新的代码仓库下载到本地，&quot;只需要做一次&quot; 2&gt; update 从服务器上将其他人所做的修改下载到本地，&quot;每天上班必须要做的事情&quot; 3&gt; commit 将工作提交到服务器，&quot;每天下班之前至少做一次&quot; SVN服务器安装(略) SVN常用命令 切换工作目录 $ cd 工作目录 checkout服务器上的代码仓库 $ svn co http://xxx/svn/xxxx --username=manager --password=manager 提示：checkout(co)之后，命令行会记录用户名和密码，后续操作不用再另行指定 查看本地代码库状态 $ svn st 错误提示：&quot;is not a working copy&quot;，必须在svn的工作目录下才能正确使用svn的命令 查看svn日志 $ svn log 查看某一个文件的日志 $ svn log filename 查看某一个文件某个版本的日志 $ svn log filename@1 创建文件 $ touch main.c 打开并编写文件内容 $ open main.c 查看工作目录状态 $ svn st 将文件添加到本地版本库中 $ svn add main.c/main.* 将文件提交到服务器的版本库中 $ svn ci -m &quot;备注信息&quot; 注意：一定要养成写注释的良好习惯 删除文件 $ svn rm Person.h 提交删除 $ svn ci -m &quot;删除了文件&quot; 注意：不要使用文件管理器直接删除文件 撤销修改 $ svn revert Person.m 恢复到之前的某个版本 $ svn update -r 5 冲突解决 (p) postpone 对比 (mc) mine-conflict 使用我的 (tc) theirs-conflict 使用对方的 svn st 显示的文件状态 &#39; &#39; 没有修改 &#39;A&#39; 被添加到本地代码仓库 &#39;C&#39; 冲突 &#39;D&#39; 被删除 &#39;I&#39; 被忽略 &#39;M&#39; 被修改 &#39;R&#39; 被替换 &#39;X&#39; 外部定义创建的版本目录 &#39;?&#39; 文件没有被添加到本地版本库内 &#39;!&#39; 文件丢失或者不完整（不是通过svn命令删除的文件） &#39;~&#39; 受控文件被其他文件阻隔 Git git是一款开源的分布式版本控制工具 $ git help 查看git所有命令的帮助 $ git help 子命令 要退出帮助信息，按&quot;q&quot; 翻看下页，按&quot;空格&quot; 翻看上页，按&quot;CTRL+B&quot; 要搜索相关文字，按&quot;/&quot;然后输入&quot;相关文字&quot; 创建代码仓库 $ git init 配置用户名和邮箱 $ git config user.name manager $ git config user.email manager@gmail.com 以上两个命令会将用户信息保存在当前代码仓库中 如果要一次性配置完成可以使用一下命令 $ git config --global user.name manager $ git config --global user.email manager@gmail.com 以上两个命令会将用户信息保存在用户目录下的 .gitconfig 文件中 查看当前所有配置 $ git config -l 创建代码，开始开发 $ touch main.c $ open main.c 将代码添加到代码库 查看当前代码库状态 $ git status 将文件添加到代码库 $ git add main.c 将修改提交到代码库 $ git commit -m &quot;添加了main.c&quot; 在此一定要使用 -m 参数指定修改的备注信息 否则会进入 vim 编辑器，如果对vim不熟悉，会是很糟糕的事情 将当前文件夹下的所有新建或修改的文件一次性添加到代码库 $ git add . 添加多个文件 $ touch Person.h Person.m $ git add . $ git commit -m &quot;添加了Person类&quot; $ open Person.h $ git add . $ git commit -m &quot;增加Person类属性&quot; 注意 使用git时，每一次修改都需要添加再提交，这一点是与svn不一样的 查看所有版本库日志 $ git log 查看指定文件的版本库日志 $ git log 文件名 回到当前版本，放弃所有没有提交的修改 $ git reset --hard HEAD 回到上一个版本 $ git reset --hard HEAD^ 回到之前第3个修订版本 $ git reset --hard HEAD~3 回到指定版本号的版本 $ git reset --hard e695b67 查看分支引用记录 $ git reflog 为什么要用源代码管理工具 能追踪一个项目从诞生一直到定案的过程 记录一个项目的所有内容变化 方便地查阅特定版本的修订情况 最常用的版本控制工具是什么，能大概讲讲原理么？参考答案： 最常用的版本控制工具有SourceTree（GIT）和CornerStone（SVN）； 原理提到svn是集中式代码管理，解释下具体意思，git也这样回答就行了。 集中式代码管理（SVN）的核心是服务器，所有开发者在开始新一天的工作之前必须从服务器获取代码，然后开发，最后解决冲突，提交。所有的版本信息都放在服务器上。如果脱离了服务器，开发者基本上可以说是无法工作的。 分布式的版本控制系统，在Git中并不存在主库这样的概念，每一份出的库都可以独立使用，任何两个库之间的不一致之处都可以进行合并。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS体系结构图]]></title>
    <url>%2F2018%2F09%2F12%2FiOS%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[这张图是github上一位大牛所制作。建议找工作的同学，把这张图打印出来，自己对着看，有哪些知识点遗忘的，赶紧去复习，每天过一遍，保证你面试的时候胸有成竹。 在这里，我将总结这段时间收集的和面试记录下来的各类问题，助各位同学面试一臂之力。文章如有问题，请留言，我将及时更正。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[速学block在ARC和MRC中的使用]]></title>
    <url>%2F2018%2F09%2F04%2F%E9%80%9F%E5%AD%A6block%E5%9C%A8ARC%E5%92%8CMRC%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1.ARC转MRC MRC转ARC首先, 先要了解下ARC转MRC和MRC转ARC.ARC项目转MRC创建项目, 打开Xcode, 点击项目, 找到Build Phases中的Compile Sources, 将需要转为MRC的 .m文件加入编译标记 -fno-objc-arc MRC项目转ARC给MRC项目中.m文件添加ARC标记 -fobjc-arc 2.示例演示Example A void exampleA() { char a = 'A'; ^{ printf("%c\n", a); }(); } 1.ARC和MRC都有效 ?2.只有ARC 有效?3.MRC有效 ?4.都没有效? Example B void exampleB_addBlockToArray(NSMutableArray *array) { char b = 'B'; [array addObject:^{ printf("%c\n", b); }]; } void exampleB() { NSMutableArray *array = [NSMutableArray array]; exampleB_addBlockToArray(array); void (^block)(void) = [array objectAtIndex:0]; block(); //MRC 断点查看下 __NSStackBlock__ NSLog(@"%@", [block class]);// ARC __NSMallocBlock__ } 1.ARC和MRC都有效 ?2.只有ARC 有效?3.MRC有效 ?4.都没有效? Example C void exampleC_addBlockToArray(NSMutableArray *array) { [array addObject:^{ printf("C\n"); }]; } void exampleC() { NSMutableArray *array = [NSMutableArray array]; exampleC_addBlockToArray(array); void (^block)(void) = [array objectAtIndex:0]; block(); NSLog(@"%@", [block class]); // __NSGlobalBlock__ } 1.ARC和MRC都有效 ?2.只有ARC 有效?3.MRC有效 ?4.都没有效? Example D typedef void (^dBlock)(void); dBlock exampleD_getBlock() { char d = 'D'; return ^{ printf("%c\n", d); } ; } void exampleD() { exampleD_getBlock()(); } 1.ARC和MRC都有效 ?2.只有ARC 有效?3.MRC有效 ?4.都没有效? Example E typedef void (^eBlock)(void); eBlock exampleE_getBlock() { char e = 'E'; void (^block)(void) = ^{ printf("%c\n", e); }; return block; } void exampleE() { eBlock block = exampleE_getBlock(); block(); //MRC 断点查看下 __NSStackBlock__ NSLog(@"%@", [block class]); // ARC __NSMallocBlock__ } 1.ARC和MRC都有效 ?2.只有ARC 有效?3.MRC有效 ?4.都没有效? 3.解析Example A: ARC和MRC都有效 不管在 ARC 还是 MRC 下，不论 block 存放在 stack 还是 heap 内存中，当example A 被调用时，block 仍然有效，都能正常执行. Example B: 只有ARC 有效 在 MRC 下，exampleB_addBlockToArray 中的 block 是 NSStackBlock 类型，存放在stack内存中。当执行 exampleB 时，stack 内存被释放，block 失效. 在 ARC 下，block 是 autoreleased NSMallocBlock 类型，存放在 heap 内存中，所以 Exmaple B 只有ARC 有效. Example C: ARC和MRC都有效 当 block 不需要从外部获取变量时，它不需要在 runtime 设置任何状态。此时，block 被编译成 NSGlobalBlock 类型，放在内存 data 段，就像 C 函数一样，属于代码的一部分，所以 ARC和MRC都有效. Example D: 只有ARC 有效 这题有点类似于 Example B. 在 MRC 下，exampleD_getBlock 中的block 会被创建在 stack 内存中，当函数返回时，block马上失效。鉴于本题的错误实在太明显，编译器在编译时，就会抛出错误 error: returning block that lives on the local stack. 而在 ARC 下，block 会被编译成 autoreleased NSMallocBlock 类型，存放于 heap 内存中。所以 只有ARC 有效. Example E: 只有ARC 有效 本题类似于 Example D，区别在于本题代码不会出现编译错误，而是在运行时才会崩溃。更槽糕的是，如果你关闭了编译器优化选项，代码运行正常，而无法发现这个隐藏的bug。 而在 ARC 下，block 会被编译成 autoreleased NSMallocBlock 类型，存放于 heap 内存中。所以 只有ARC 有效. 4.总结总结1: MRC 中block 没有引用外部变量, block为 NSGlobalBlock 类型,存储在全局数据区.MRC 中block 引用外部变量,block为NSStackBlock 类型,存储在栈内存中.所以, 在block所属的栈作用域外使用block时, 需要将调用copy方法将该block存储在堆区. 总结2: ARC 中 没有引用外部变量, block为 NSGlobalBlock 类型,存储在全局数据区.ARC 中 引用外部变量, block为 autoreleased NSMallocBlock 类型,存储在堆内存中. 例外:匿名block 引用外部变量 在ARC下其实很少见到 NSStackBlock 类的Block，大多数情况编译器都保证了Block是在堆上创建的 int count = 11; NSLog(@"Stack Block:%@", [^{NSLog(@"Stack Block:%d",count);} class]); //打印：Stack Block:__NSStackBlock__ 5.以上这么多例子告诉我们什么？告诉我们要使用ARC！在ARC下，block总能正确运行。如果你不用ARC，最好能保证在 stack 内存中声明定义的block，能够拷贝到heap内存，保证block的正常运行。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>block</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown语法]]></title>
    <url>%2F2018%2F08%2F30%2Fmarkdown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[欢迎使用马克飞象@(示例笔记本)[马克飞象|帮助|Markdown] 马克飞象是一款专为印象笔记（Evernote）打造的Markdown编辑器，通过精心的设计与技术实现，配合印象笔记强大的存储和同步功能，带来前所未有的书写体验。特点概述： 功能丰富 ：支持高亮代码块、LaTeX 公式、流程图，本地图片以及附件上传，甚至截图粘贴，工作学习好帮手； 得心应手 ：简洁高效的编辑器，提供[桌面客户端][1]以及[离线Chrome App][2]，支持移动端 Web； 深度整合 ：支持选择笔记本和添加标签，支持从印象笔记跳转编辑，轻松管理。 [TOC] (不支持) Markdown简介(hexo引用不一样) Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。 —— 维基百科 正如您在阅读的这份文档，它使用简单的符号标识不同的标题，将某些文字标记为粗体或者斜体，创建一个链接或一个脚注[^demo]。下面列举了几个高级功能，更多语法请按Cmd + /查看帮助。 代码块@requires_authorization def somefunc(param1='', param2=0): '''A docstring''' if param1 > param2: # interesting print 'Greater' return (param2 - param1 + 1) or None class SomeClass: pass >>> message = '''interpreter ... prompt''' LaTeX 公式 (hexo不支持此写法)可以创建行内公式，例如 $\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N$。或者块级公式： $$ x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a} $$ 表格 (不一样) Item Value Qty Computer 1600 USD 5 Phone 12 USD 12 Pipe 1 USD 234 流程图 (hexo不支持此写法)st=>start: Start e=>end op=>operation: My Operation cond=>condition: Yes or No? st->op->cond cond(yes)->e cond(no)->op 以及时序图: Alice->Bob: Hello Bob, how are you? Note right of Bob: Bob thinks Bob-->Alice: I am good thanks! 提示：想了解更多，请查看流程图[语法][3]以及时序图[语法][4]。 复选框使用 - [ ] 和 - [x] 语法可以创建复选框，实现 todo-list 等功能。例如： 已完成事项 待办事项1 待办事项2 注意：目前支持尚不完全，在印象笔记中勾选复选框是无效、不能同步的，所以必须在马克飞象中修改 Markdown 原文才可生效。下个版本将会全面支持。 印象笔记相关笔记本和标签马克飞象增加了@(笔记本)[标签A|标签B]语法, 以选择笔记本和添加标签。 绑定账号后， 输入(自动会出现笔记本列表，请从中选择。 笔记标题马克飞象会自动使用文档内出现的第一个标题作为笔记标题。例如本文，就是第一行的 欢迎使用马克飞象。 快捷编辑保存在印象笔记中的笔记，右上角会有一个红色的编辑按钮，点击后会回到马克飞象中打开并编辑该笔记。 注意：目前用户在印象笔记中单方面做的任何修改，马克飞象是无法自动感知和更新的。所以请务必回到马克飞象编辑。 数据同步马克飞象通过将Markdown原文以隐藏内容保存在笔记中的精妙设计，实现了对Markdown的存储和再次编辑。既解决了其他产品只是单向导出HTML的单薄，又规避了服务端存储Markdown带来的隐私安全问题。这样，服务端仅作为对印象笔记 API调用和数据转换之用。 隐私声明：用户所有的笔记数据，均保存在印象笔记中。马克飞象不存储用户的任何笔记数据。 离线存储马克飞象使用浏览器离线存储将内容实时保存在本地，不必担心网络断掉或浏览器崩溃。为了节省空间和避免冲突，已同步至印象笔记并且不再修改的笔记将删除部分本地缓存，不过依然可以随时通过文档管理打开。 注意：虽然浏览器存储大部分时候都比较可靠，但印象笔记作为专业云存储，更值得信赖。以防万一，请务必经常及时同步到印象笔记。 编辑器相关设置右侧系统菜单（快捷键Cmd + M）的设置中，提供了界面字体、字号、自定义CSS、vim/emacs 键盘模式等高级选项。 快捷键帮助 Cmd + /同步文档 Cmd + S创建文档 Cmd + Opt + N最大化编辑器 Cmd + Enter预览文档 Cmd + Opt + Enter文档管理 Cmd + O系统菜单 Cmd + M 加粗 Cmd + B插入图片 Cmd + G插入链接 Cmd + L提升标题 Cmd + H 关于收费马克飞象为新用户提供 10 天的试用期，试用期过后需要续费才能继续使用。未购买或者未及时续费，将不能同步新的笔记。之前保存过的笔记依然可以编辑。 反馈与建议 微博：@马克飞象，@GGock 邮箱：&#x68;&#117;&#x73;&#x74;&#x67;&#x6f;&#99;&#x6b;&#64;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#x6d; 感谢阅读这份帮助文档。请点击右上角，绑定印象笔记账号，开启全新的记录与分享体验吧。 [^demo] (hexo不支持) [^demo]: 这是一个示例脚注。请查阅 MultiMarkdown 文档 关于脚注的说明。 限制： 印象笔记的笔记内容使用 [ENML][5] 格式，基于 HTML，但是不支持某些标签和属性，例如id，这就导致脚注和TOC无法正常点击。 (支持) [1]: http://maxiang.info/client_zh [2]: https://chrome.google.com/webstore/detail/kidnkfckhbdkfgbicccmdggmpgogehop [3]: http://adrai.github.io/flowchart.js/ [4]: http://bramp.github.io/js-sequence-diagrams/ [5]: https://dev.yinxiang.com/doc/articles/enml.php]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo语法体验]]></title>
    <url>%2F2018%2F08%2F30%2Fhexo%E8%AF%AD%E6%B3%95%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[标签插件（Tag Plugins）引用块在文章中插入引言，可包含作者、来源和标题。 别号： quotecontent [author[source]] [link] [source_link_title] 样例没有提供参数，则只输出普通的 blockquote Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem. 111111 222222 333 代码块在文章中插入代码。 别名： codecode snippet 样例普通的代码块alert(&#39;Hello World!&#39;); alert(‘Hello World!’); 指定语言[rectangle setX: 10 y: 10 width: 20 height: 20]; [rectangle setX: 10 y: 10 width: 20 height: 20]; [rectangle setX: 10 y: 10 width: 20 height: 20]; 附加说明array.map(callback[, thisArg]) Array.maparray.map(callback[, thisArg]) 附加说明和网址_.compact([0, 1, false, 2, &#39;&#39;, 3]); =&gt; [1, 2, 3] _.compactUnderscore.js_.compact([0, 1, false, 2, ‘’, 3]);=&gt; [1, 2, 3] 反引号代码块另一种形式的代码块，不同的是它使用三个反引号来包裹。 [title] [url] [link text] code snippet Image在文章中插入指定大小的图片。 Link在文章中插入链接，并自动给外部链接添加 target=”_blank” 属性。 text url [external] [title] Youtube在文章中插入 Youtube 视频。 Vimeo在文章中插入 Vimeo 视频。 引用文章引用其他文章的链接。 引用资源引用文章的资源。 window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdPic":"","bdStyle":"0","bdSize":"16"},"share":{},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["qzone","tsina","tqq","renren","weixin"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客开篇]]></title>
    <url>%2F2018%2F08%2F30%2F%E5%8D%9A%E5%AE%A2%E5%BC%80%E7%AF%87%2F</url>
    <content type="text"><![CDATA[终于下决心要开始写博客了，做程序员快四年了，四年的时间里，由一个嫩头青，成长为了一个能在公司项目里独立完成一些业务逻辑复杂的大模块的中坚程序员。首先我还是概括下这几年的成长历程吧。 由于本人的脸长得比较缓慢，刚出道时还是一张孩童脸，用时下流行的一个词来描述那就是“萌”。因为太萌，刚安排到客户现场做开发时，还被客户开玩笑说你们公司违法招收童工，我一怒之下蓄了几个月胡须，留了几个月飘逸的长发，想让自己在外表上看上去更老成。但不巧的是，此时的我又与那时刚出道的“犀利哥”风格极为类似，又被戏称为犀利程序哥，再怒之下，开始潜心工作，不再追求表面的浮夸，在工作中逐渐展露头角，完成了项目中几个重要需求的开发，在后来的普选中当选为公司年度优秀员工之一。最近1，2年波澜不惊，因为自学没有断过，技术也在逐步积累。 下面进入主题，关于我的博客，我用自问自答的方式来介绍： 1、我为什么要写博客？ 做程序员这几年，技术不断积累，思想不断在升华，有些思考和想法在与同事、朋友的交流中会迸发出来。在交流的过程中，我觉得很过瘾。有些模糊不清的事情，通过交流明确了，有些以为自己把握的很准的事情，通过交流颠覆了，而有些自己已经明白的事情，又开阔了新的思路。但交流只是瞬时的、已逝的，我们的讨论不是国家政要接见外国领导，没有人把我们的谈话记录下来。就像在内存里一样，断电后恢复不了，事后很难回忆起来那些曾经闪光的思想。所以我要把我在程序人生中得到的思想给持久化了，给固化下来。再一个就是，我的同事、朋友始终是我身边熟悉的人，我需要一个更大的世界，所以，我也想通过博客与大家交流！ 2、我的博客写些什么东西？ 这个问题我想了很久，以前想写些关于iOS的、关于前端博文。有时候在草稿中写好一段文字，最后一搜索，全世界拥有同样知识点的，同样解决方案的数不胜数，太多了。作为一个讨厌重复的人，我不能再罗列这些网上一抓一大把的普世技术知识点，更何况以我现在的积累，还不能做到非常好。当然我不是说罗列技术点没有技术含量，正是因为网上这些庞大的知识，我才能很快的找到我想要的，解决我的问题。综上，我不能做重复的事，也不要因为说的东西不扎实而误导别人。当然了，在某个技术领域达到一定境界了，我也会写研究技术细节的博文。 那我写什么？什么是不重复的？那必须斩钉截铁的说那就是我的思想，世上没有任何一个人和我的人生轨迹完全一样，在这个过程中，我会思考我会总结，我要把我的思想留存于世，即使有时候会有相同思想的东西同时存在，那也会因为是我个人的总结和反思而有所不同！ 3、写博客的计划？ 不追求一个月一定要写几篇几篇的，当我有深刻的感触，对事物有不同的理解，我就写一篇，记录下来，一步一个脚印，向卓越程序员迈进！ 夜空霓虹，都是我不要的繁荣，完。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[categories]]></title>
    <url>%2Fcategories%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[tags]]></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[timeline]]></title>
    <url>%2Ftimeline%2Findex.html</url>
    <content type="text"></content>
  </entry>
</search>
