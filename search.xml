<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[iOS面试题4--Objective-C]]></title>
    <url>%2F2018%2F09%2F12%2FiOS%E9%9D%A2%E8%AF%95%E9%A2%984-Objective-C%2F</url>
    <content type="text"><![CDATA[面试笔试都是必考语法知识的。请认真复习和深入研究OC。 Objective-C方法和选择器有何不同？(Difference between method and selector?) selector是一个方法的名字，method是一个组合体，包含了名字和实现. Core Foundation的内存管理 凡是带有Create、Copy、Retain等字眼的函数，创建出来的对象，都需要在最后做一次release 比如CFRunLoopObserverCreate release函数：CFRelease(对象); malloc和New的区别 new 是c++中的操作符，malloc是c 中的一个函数 new 不止是分配内存，而且会调用类的构造函数，同理delete会调用类的析构函数，而malloc则只分配内存，不会进行初始化类成员的工作，同样free也不会调用析构函数 内存泄漏对于malloc或者new都可以检查出来的，区别在于new可以指明是那个文件的那一行， 而malloc没有这些信息。 new 和 malloc效率比较 new可以认为是malloc加构造函数的执行。 new出来的指针是直接带类型信息的。 你是否接触过OC中的反射机制？简单聊一下概念和使用 class反射 通过类名的字符串形式实例化对象 Class class NSClassFromString@(@"student"); Student *stu = [[class alloc ]init]; 将类名变为字符串 Class class =[Student class]; NSString *className = NSStringFromClass(class); SEL的反射 通过方法的字符串形式实例化方法 SEL selector = NSSelectorFromClass(@"setName"); [stu performSelector:selector withObject:@"Mike"]; 将方法变成字符串 NSStringFomrSelector(@selector*(setName:)) 什么是SEL?如何声明一个SEL?通过那些方法能够,调用SEL包装起来的方法? SEL就是对方法的一种包装。包装的SEL类型数据它对应相应的方法地址，找到方法地址就可以调用方法。在内存中每个类的方法都存储在类对象中，每个方法都有一个与之对应的SEL类型的数据，根据一个SEL数据就可以找到对应的方法地址，进而调用方法。 SEL s1 = @selector(test1); // 将test1方法包装成SEL对象 SEL s2 = NSSelectorFromString(@"test1"); // 将一个字符串方法转换成为SEL对象 调用方法有两种方式： 1.直接通过方法名来调用 [person text] 2.间接的通过SEL数据来调用 SEL aaa = @selector(text); [person performSelector:aaa]; 协议中是什么意思?子类继承了父类,那么子类会遵守父类中遵守的协议吗?协议中能够定义成员变量?如何约束一个对象类型的变量要存储的地址是遵守一个协议对象? 遵守NSObject协议 会 能，但是只在头文件中声明，编译器是不会自动生成实例变量的。需要自己处理getter和setter方法 id NS/CF/CG/CA/UI这些前缀分别是什么含义 函数归属于属于cocoa Fundation框架 函数归属于属于core Fundation框架 函数归属于属于CoreGraphics.frameworks框架 函数归属于属于CoreAnimation.frameworks框架 函数归属于属于UIkit框架 面向对象都有哪些特征以及你对这些特征的理解。 继承：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。 继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段。 封装：封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。我们在类中编写的方法就是对实现细节的一种封装；我们编写一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口。 多态性 ：多态性是指允许不同子类型的对象对同一消息作出不同的响应。简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。多态性分为编译时的多态性和运行时的多态性。方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）。运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事： 方法重写（子类继承父类并重写父类中已有的或抽象的方法）； 对象造型（用父类型引用引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。 抽象：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。 我们说的Objective-C是动态运行时语言是什么意思? (When we call objective c is runtime language what does it mean?) 主要是将数据类型的确定由编译时,推迟到了运行时。这个问题其实浅涉及到两个概念,运行时和多态。 简单来说, 运行时机制使我们直到运行时才去决定一个对象的类别,以及调用该类别对象指定方法。 多态:不同对象以自己的方式响应相同的消息的能力叫做多态。 意思就是假设生物类(life)都拥有一个相同的方法-eat;那人类属于生物,猪也属于生物,都继承了life后,实现各自的eat,但是调用是我们只需调用各自的eat方法。也就是不同的对象以自己的方式响应了相同的消 息(响应了eat这个选择器)。因此也可以说,运行时机制是多态的基础. readwrite, readonly, assign, retain, copy, nonatomic属性的作用? readwrite 是可读可写特性;需要生成getter方法和setter方法; readonly 是只读特性 只会生成getter方法 不会生成setter方法 ,不希望属性在类外改变; assign 是赋值特性,setter方法将传入参数赋值给实例变量;仅设置变量时; assign用于简单数据类型,如NSInteger,double,bool; retain 表示持有特性,setter方法将传入参数先保留,再赋值,传入参数的引用计数retaincount会+1; copy 表示赋值特性,setter方法将传入对象复制一份;需要完全一份新的变量时; nonatomic 非原子操作,决定编译器生成的setter getter是否是原子操作; atomic 表示多线程安全,一般使用 nonatomic。 简述NotificationCenter、KVC、KVO、Delegate?并说明它们之间的区别?(重点) KVO（Key-Value- Observing）：一对多, 观察者模式,键值观察机制，它提供了观察某一属性变化的方法，极大简化了代码。 KVC (Key-Value-Coding)：是键值编码, 一个对象在调用setValue的时候， 检查是否存在相应key的set方法，存在就调用set方法。 set方法不存在，就查找_key的成员变量是否存在，存在就直接赋值。 如果_key没找到，就查找相同名称的key，存在就赋值。 如果没有就调用valueForUndefinedkey和setValue：forUndefinedKey。 Delegate: 通常发送者和接收者的关系是直接的一对一的关系。 代理的目的是改变或传递控制链。允许一个类在某些特定时刻通知到其他类，而不需要获取到那些类的指针。 可以减少框架复杂度。消息的发送者(sender)告知接收者(receiver)某个事件将要发生，delegate同意然然后发送者响应事件，delegate机制使得接收者可以改变发送者的行为。 Notification: 观察者模式, 通常发送者和接收者的关系是间接的多对多关系。 消息的发送者告知接收者事件已经发生或者将要发送，仅此而已，接收者并不能反过来影响发送者的行为。 区别 效率肯定是delegate比NSNotification高。 delegate方法比notification更加直接，需要关注返回值，所以delegate方法往往包含should这个很传神的词。相反的，notification最大的特色就是不关心结果。所以notification往往用did这个词汇。 两个模块之间联系不是很紧密，就用notification传值，例如多线程之间传值用notificaiton。 delegate只是一种较为简单的回调，且主要用在一个模块中，例如底层功能完成了，需要把一些值传到上层去，就事先把上层的函数通过delegate传到底层，然后在底层call这个delegate，它们都在一个模块中，完成一个功能，例如说 NavgationController 从 B 界面到A 点返回按钮 (调用popViewController方法) 可以用delegate比较好。 懒加载(What is lazy loading ?) 就是懒加载,只在用到的时候才去初始化。也可以理解成延时加载。我觉得最好也最简单的一个列子就是tableView中图片的加载显示了, 一个延时加载, 避免内存过高,一个异步加载,避免线程堵塞提高用户体验 OC有多继承吗?没有的话可以用什么方法替代? 多继承即一个子类可以有多个父类,它继承了多个父类的特性。 Object-c的类没有多继承,只支持单继承,如果要实现多继承的话,可以通过类别和协议的方式来实现。 protocol（协议）可以实现多个接口,通过实现多个接口可以完成多继承; Category（类别）一般使用分类,用Category去重写类的方法,仅对本Category有效,不会影响到其他类与原有类的关系。 分别描述类别(categories)和延展(extensions)是什么?以及两者的区别?继承和类别在实现中有何区别?为什么Category只能为对象添加方法,却不能添加成员变量? 类别: 在没有原类.m文件的基础上,给该类添加方法; 延展:一种特殊形式的类别,主要在一个类的.m文件里声明和实现延展的作用,就是给某类添加私有方法或是私有变量。 两个的区别: 延展可以添加属性并且它添加的方法是必须要实现的。延展可以认为是一个私有的类目。 类别可以在不知道,不改变原来代码的情况下往里面添加新的方法,只能添加,不能删除修改。 并且如果类别和原来类中的方法产生名称冲突,则类别将覆盖原来的方法,因为类别具有更高的优先级。 继承可以增加，修改删除方法，添加属性。 Category只能为对象添加方法,却不能添加成员变量的原因:如果可以添加成员变量,添加的成员变量没有办法初始化 Objective-C有私有方法么?私有变量呢?如多没有的话,有没有什么代替的方法? objective-c类里面的方法只有两种,静态方法和实例方法.但是可以通过把方法的声明和定义都放在.m文件中来实现一个表面上的私有方法。有私有变量,可以通过@private来修饰,或者把声明放到.m文件中。在Objective‐C中,所有实例变量默认都是私有的, 所有实例方法默认都是公有的 #include与#import的区别? #import与 @class的区别? #import指令是Object-C针对#include的改进版本，#import确保引用的文件只会被引用一次，这样你就不会陷入递归包含的问题中。 # impor与@class二者的区别在于： #import会链入该头文件的全部信息，包括实例变量和方法等；而@class只是告诉编译器，其后面声明的名称是类的名称，至于这些类是如何定义的，暂时不用考虑。 在头文件中一般使用@class来声明这个名称是类的名称,不需要知道其内部的实体变量和方法. 而在实现类里面，因为会用到这个引用类的内部的实体变量和方法，所以需要使用#import来包含这个被引用类的头文件。 在编译效率方面，如果你有100个头文件都#import了同一个头文件，或者这些文件是依次引用的，如A–&gt;B, B–&gt;C, C–&gt;D这样的引用关系。当最开始的那个头文件有变化的话，后面所有引用它的类都需要重新编译，如果你的类有很多的话，这将耗费大量的时间。而是用@class则不会。 如果有循环依赖关系，如:A–&gt;B, B–&gt;A这样的相互依赖关系，如果使用#import来相互包含，那么就会出现编译错误，如果使用@class在两个类的头文件中相互声明，则不会有编译错误出现。 浅复制(拷贝)和深复制的区别? (Difference between shallow copy and deep copy?) 浅复制(copy)：只复制指向对象的指针，而不复制引用对象本身。 深复制(mutableCopy)：复制引用对象本身。深复制就好理解了,内存中存在了两份独立对象本身, 当修改A时,A_copy不变。 类变量的@protected,@private,@public,@package声明各有什么含义?变量的作用域不同。 @protected 该类和子类中访问，是默认的; @private 只能在本类中访问; @public 任何地方都能访问; @package 本包内使用，跨包不可以 Objective-C与C、C+++之间的联系和区别？ Objective-C和C++都是C的面向对象的超集。 Object与C++的区别主要点：Objective-C是完全动态的，支持在运行时动态类型决议(dynamic typing)，动态绑定(dynamic binding)以及动态装载(dynamic loading)；而C++是部分动态的，编译时静态绑定，通过嵌入类(多重继承)和虚函数(虚表)来模拟实现。 Objective-C 在语言层次上支持动态消息转发，其消息发送语法为 [object function]； 而且C++ 为 object-&gt;function()。 两者的语义也不同，在 Objective-C 里是说发送消息到一个对象上，至于这个对象能不能响应消息以及是响应还是转发消息都不会 crash； 而在 C++ 里是说对象进行了某个操作，如果对象没有这个操作的话，要么编译会报错(静态绑定)，要么程序会 crash 掉的(动态绑定)。 目标-动作机制 目标是动作消息的接收者。一个控件，或者更为常见的是它的单元，以插座变量的形式保有其动作消息的目标。 动作是控件发送给目标的消息，或者从目标的角度看，它是目标为了响应动作而实现的方法. 程序需要某些机制来进行事件和指令的翻译。这个机制就是目标-动作机制。 Objective-C优点和缺点 优点:1.Cateogies 2.Posing 3.动态识别 4.指标计算 5.弹性讯息传递 6.不是一个过度复杂的C衍生语言 7.Objective-C与C++可混合编程 缺点:1.不支持命名空間 2.不支持运算符重载 3.不支持多重继承 4.使用动态运行时类型,所有的方法都是函数调用,所以很多编译时优化方法都用不到。(如内联函数等),性能低劣。 C语言的函数调用和oc的消息机制有什么区别? 对于C语言，函数的调用在编译的时候会决定调用哪个函数。编译完成之后直接顺序执行。 OC的函数调用成为消息发送。属于动态调用过程。在编译的时候并不能决定真正调用哪个函数（事实证明，在编译阶段，OC可以调用任何函数，即使这个函数并未实现，只要申明过就不会报错。而C语言在编译阶段就会报错）。只有在真正运行的时候才会根据函数的名称找到对应的函数来调用。 什么是谓词谓词就是通过NSPredicate给定的逻辑条件作为约束条件，完成对数据的筛选。 定义谓词对象，谓词对象中包含了过滤条件 NSPredicate *predicate = [NSPredicate predicateWithFormat:@"age40"]; array = [persons filteredArrayUsingPredicate:predicate]; 包含语句的使用 predicate = [NSPredicate predicateWithFormat:@"[self.name](https://link.jianshu.com?t=http://self.name) IN {'1','2','4'} || self.age IN{30,40}"]; 指定字符开头和指定字符结尾，是否包含指定字符 name以a开头的 predicate = [NSPredicate predicateWithFormat:@"name BEGINSWITH 'a'"]; name以ba结尾的 predicate = [NSPredicate predicateWithFormat:@"name ENDSWITH 'ba'"]; name中包含字符a的 predicate = [NSPredicate predicateWithFormat:@"name CONTAINS 'a'"]; like进行匹配多个字符 name中只要有s字符就满足条件 predicate = [NSPredicate predicateWithFormat:@"name like '*s*'"]; ?代表一个字符，下面的查询条件是：name中第二个字符是s的 predicate = [NSPredicate predicateWithFormat:@"name like '?s'"]; C与OC混用处理.m可以识别c和oc，.mm可以识别c c++ oc 但是cpp只能用c/c++ atomic和nonatomic的区别 atomic提供多线程安全，防止读写未完成的时候被另外一个线程读写，造成数据错误。 nonatomic在自己管理内存的环境中，解析的访问器保留并自动释放返回值，若指定了nonatomic，那么访问器只是简单的返回这个值。 常见的oc数据类型哪些，和c的基本类型有啥区别 常见的：NSInteger CGFloat NSString NSNumber NSArray NSDate NSInteger根据32或者64位系统决定本身是int还是long CGFloat根据32或者64位系统决定本身是float还是double NSString NSNumber NSArray NSDate都是指针类型的对象，在堆中分配内存，c语言中的char int 等都是在栈中分配空间 id和nil代表什么 id类型的指针可以指向任何OC对象 nil代表空值（空指针的值，0） nil和NULL的区别？ 从oc的官方语法上看，nil表示对象的指针 即对象的引用为空 null表示指向基础数据类型变量 即c语言变量的指针为空 在非arc中 两个空可以互换，但是在arc中 普通指针和对象引用被严格限制，不能互换 nil、Nil、NULL和NSNull区别 nil和C语言的NULL相同，在objc/objc.h中定义。nil表示Objective-C对象的值为空。在C语言中，指针的空值用NULL表示。在Objective-C中，nil对象调用任何方法表示什么也不执行，也不会崩溃。 Nil:那么对于我们Objective-C开发来说，Nil也就代表((void *)0)。但是它是用于代表空类的. 比如：Class myClass = Nil; NULL: 在C语言中，NULL是无类型的，只是一个宏，它代表空. 这就是在C/C++中的空指针。对于我们Objective-C开发来说，NULL就表示((void*)0). NSNull:NSNull是继承于NSObject的类型。它是很特殊的类，它表示是空，什么也不存储，但是它却是对象，只是一个占位对象。使用场景就不一样了，比如说服务端接口中让我们在值为空时，传空。NSDictionry *parameters = @{@”arg1” : @”value1”,@”arg2” : arg2.isEmpty ? [NSNull null] : arg2}; NULL、nil、Nil这三者对于Objective-C中值是一样的，都是(void *)0，那么为什么要区分呢？又与NSNull之间有什么区别： NULL是宏，是对于C语言指针而使用的，表示空指针 nil是宏，是对于Objective-C中的对象而使用的，表示对象为空 Nil是宏，是对于Objective-C中的类而使用的，表示类指向空 NSNull是类类型，是用于表示空的占位对象，与JS或者服务端的null类似的含意 向一个nil对象发送消息会发生什么？ 向nil发送消息是完全有效的——只是在运行时不会有任何作用。 如果一个方法返回值是一个对象，那么发送给nil的消息将返回0(nil) 如果方法返回值为指针类型，其指针大小为小于或者等于sizeof(void*)，float，double，long double 或者long long的整型标量，发送给nil的消息将返回0。 -如果方法返回值为结构体，正如在《Mac OS X ABI 函数调用指南》，发送给nil的消息将返回0。结构体中各个字段的值将都是0。其他的结构体数据类型将不是用0填充的。 如果方法的返回值不是上述提到的几种情况，那么发送给nil的消息的返回值将是未定义的。 self.和self-&gt;的区别 self.是调用get或者set方法 self是当前本身，是一个指向当前对象的指针 self-&gt;是直接访问成员变量 类方法和实例方法的本质区别和联系 类方法 实例方法 属于类对象 属于实例对象 只能类对象调用 实例对象调用 self是类对象 self是实例对象 类方法可以调用其他类方法 实例方法可以调用实例方法 类方法不能访问成员变量 实例方法可以访问成员变量 类方法不能直接调用对象方法 实例方法可以调用类方法 _block/weak修饰符区别 _block在arc和mrc环境下都能用，可以修饰对象，也能修饰基本数据类型 _weak只能在arc环境下使用，只能修饰对象(NSString)，不能修饰基本数据类型(int) _block对象可以在block中重新赋值，_weak不行。 写一个NSString类的实现NSString *str = [[NSString alloc] initWithCString: nullTerminatedCString encoding:encoding]; 为什么标准头文件都有类似以下的结构？# ifndef __INCvxWorksh # define __INCvxWorksh # ifdef __cplusplus extern "C" { # endif # ifdef __cplusplus } # endif # endif 显然，头文件中的编译宏 #ifndef __INCvxWorksh、#define __INCvxWorksh、#endif 的作用是防止该头文件被重复引用 init和initwithobject区别（语法）？ 后者给属性赋值 @property的本质是什么？ivar、getter、setter是如何生成并添加到这个类中的？@property的本质： @property = ivar（实例变量） + getter（取方法） + setter（存方法） “属性” (property)有两大概念：ivar（实例变量）、存取方法（access method ＝ getter + setter） ivar、getter、setter如何生成并添加到类中： 这是编译器自动合成的，通过@synthesize关键字指定，若不指定，默认为@synthesize propertyName = _propertyName;若手动实现了getter/setter方法，则不会自动合成。 现在编译器已经默认为我们添加@synthesize propertyName = _propertyName;因此不再需要手动添加了，除非你真的要改成员变量名。 生成getter方法时，会判断当前属性名是否有_，比如声明属性为@property (nonatomic, copy) NSString *_name;那么所生成的成员变量名就会变成__name，如果我们要手动生成getter方法，就要判断是否以_开头了。 不过，命名都要有规范，是不允许声明属性是使用_开头的，不规范的命名，在使用runtime时，会带来很多的不方便的。 这个写法会出什么问题：@property (copy) NSMutableArray *array; 没有指明为nonatomic，因此就是atomic原子操作，会影响性能。该属性使用了同步锁，会在创建时生成一些额外的代码用于帮助编写多线程程序，这会带来性能问题，通过声明nonatomic可以节省这些虽然很小但是不必要额外开销。在我们的应用程序中，几乎都是使用nonatomic来声明的，因为使用atomic并不能保证绝对的线程安全，对于要绝对保证线程安全的操作，还需要使用更高级的方式来处理，比如NSSpinLock、@syncronized等 因为使用的是copy，所得到的实际是NSArray类型，它是不可变的，若在使用中使用了增、删、改操作，则会crash @protocol和category中如何使用 @property• 在protocol中使用@property只会生成setter和getter方法声明，我们使用属性的目的是希望遵守我协议的对象能实现该属性• category使用@property也是只会生成setter和getter方法的声明，如果我们真的需要给category增加属性的实现，需要借助于运行时的两个函数：• objc_setAssociatedObject• objc_getAssociatedObject @property中有哪些属性关键字？1.原子性 （atomic，nonatomic）2.读写（readwrite, readonly）3.内存管理（assign, strong, weak, unsafe_unretained,copy）4.getter、setter isa指针问题 isa：是一个Class 类型的指针. 每个实例对象有个isa的指针,他指向对象的类，而Class里也有个isa的指针, 指向meteClass(元类)。元类保存了类方法的列表。当类方法被调用时，先会从本身查找类方法的实现，如果没有，元类会向他父类查找该方法。同时注意的是：元类（meteClass）也是类，它也是对象。元类也有isa指针,它的isa指针最终指向的是一个根元类(root meteClass).根元类的isa指针指向本身，这样形成了一个封闭的内循环。 如何访问并修改一个类的私有属性？ 一种是通过KVC获取 通过runtime访问并修改私有属性 如何为 Class 定义一个对外只读对内可读写的属性?在头文件中将属性定义为readonly,在.m文件中将属性重新定义为readwrite Objective-C 中，meta-class 指的是什么？meta-class 是 Class 对象的类,为这个Class类存储类方法,当一个类发送消息时,就去这个类对应的meta-class中查找那个消息,每个Class都有不同的meta-class,所有的meta-class都使用基类的meta-class(假如类继承NSObject,那么他所对应的meta-class也是NSObject)作为他们的类 Objective-C 的class是如何实现的？Selector是如何被转化为 C 语言的函数调用的？ 当一个类被正确的编译过后，在这个编译成功的类里面，存在一个变量用于保存这个类的信息。我们可以通过[NSClassFromString]或[obj class]。这样的机制允许我们在程序执行的过程当中，可以Class来得到对象的类，也可以在程序执行的阶段动态的生成一个在编译阶段无法确定的一个对象。 （isa指针） @selector()基本可以等同C语言的中函数指针,只不过C语言中，可以把函数名直接赋给一个函数指针，而Object-C的类不能直接应用函数指针，这样只能做一个@selector语法来取. @interface foo -(int)add:int val; @end SEL class_func ; //定义一个类方法指针 class_func = @selector(add:int); @selector是查找当前类的方法，而[object @selector(方法名:方法参数..) ] ;是取object对应类的相应方法. 查找类方法时，除了方法名,方法参数也查询条件之一. 可以用字符串来找方法 SEL 变量名 = NSSelectorFromString(方法名字的字符串); 可以运行中用SEL变量反向查出方法名字字符串。NSString *变量名 = NSStringFromSelector(SEL参数); 取到selector的值以后，执行seletor。 SEL变量的执行.用performSelecor方法来执行. [对象 performSelector:SEL变量 withObject:参数1 withObject:参数2]; 对于语句NSString *obj = [[NSData alloc] init]; ，编译时和运行时obj分别是什么类型？ 编译时是NSString类型 ，运行时是NSData类型. @synthesize和@dynamic分别有什么作用？答: @property有两个对应的词，一个是 @synthesize，一个是 @dynamic。如果 @synthesize和 @dynamic都没写，那么默认的就是@syntheszie var = _var; @synthesize 的语义是如果你没有手动实现 setter 方法和 getter 方法，那么编译器会自动为你加上这两个方法。 @dynamic 告诉编译器：属性的 setter 与 getter 方法由用户自己实现，不自动生成。（当然对于 readonly 的属性只需提供 getter 即可）。假如一个属性被声明为 @dynamic var，然后你没有提供 @setter方法和 @getter 方法，编译的时候没问题，但是当程序运行到 instance.var = someVar，由于缺 setter 方法会导致程序崩溃；或者当运行到 someVar = var 时，由于缺 getter 方法同样会导致崩溃。编译时没问题，运行时才执行相应的方法，这就是所谓的动态绑定。 NSString 的时候用copy和strong的区别？OC中NSString为不可变字符串的时候，用copy和strong都是只分配一次内存，但是如果用copy的时候，需要先判断字符串是否是不可变字符串，如果是不可变字符串，就不再分配空间，如果是可变字符串才分配空间。如果程序中用到NSString的地方特别多，每一次都要先进行判断就会耗费性能，影响用户体验，用strong就不会再进行判断，所以，不可变字符串可以直接用strong。 NSArray、NSSet、NSDictionary与NSMutableArray、NSMutableSet、NSMutableDictionary的特性和作用（遇到copy修饰产生的变化） 特性： NSArray表示不可变数组，是有序元素集，只能存储对象类型，可通过索引直接访问元素，而且元素类型可以不一样，但是不能进行增、删、改操作；NSMutableArray是可变数组，能进行增、删、改操作。通过索引查询值很快，但是插入、删除等效率很低。 NSSet表示不可变集合，具有确定性、互异性、无序性的特点，只能访问而不能修改集合；NSMutableSet表示可变集合，可以对集合进行增、删、改操作。集合通过值查询很快，插入、删除操作极快。 NSDictionary表示不可变字典，具有无序性的特点，每个key对应的值是唯一的，可通过key直接获取值；NSMutableDictionary表示可变字典，能对字典进行增、删、改操作。通过key查询值、插入、删除值都很快。 作用： 数组用于处理一组有序的数据集，比如常用的列表的dataSource要求有序，可通过索引直接访问，效率高。 集合要求具有确定性、互异性、无序性，在iOS开发中是比较少使用到的，笔者也不清楚如何说明其作用 字典是键值对数据集，操作字典效率极高，时间复杂度为常量，但是值是无序的。在ios中，常见的JSON转字典，字典转模型就是其中一种应用。 请把字符串2015-04-10格式化日期转为NSDate类型NSString *timeStr = @"2015-04-10"; NSDateFormatter *formatter = [[NSDateFormatter alloc] init]; formatter.dateFormat = @"yyyy-MM-dd"; formatter.timeZone = [NSTimeZone defaultTimeZone]; NSDate *date = [formatter dateFromString:timeStr]; // 2015-04-09 16:00:00 +0000 NSLog(@"%@", date); 在一个对象的方法里：[self.name=@object] 和name=@object有什么不同 这是老生常谈的话题了，实质上就是问setter方法赋值与成员变量赋值有什么不同。通过点语法self.name实质上就是 [self setName:@object];。而name这里是成员变量，直接赋值。 一般来说，在对象的方法里成员变量和方法都是可以访问的，我们通常会重写Setter方法来执行某些额外的工作。比如说，外部传一个模型过来，那么我会直接重写Setter方法，当模型传过来时，也就是意味着数据发生了变化，那么视图也需要更新显示，则在赋值新模型的同时也去刷新UI。这样也不用再额外提供其他方法了。 怎样使用performSelector传入3个以上参数，其中一个为结构体- (id)performSelector:(SEL)aSelector; - (id)performSelector:(SEL)aSelector withObject:(id)object; - (id)performSelector:(SEL)aSelector withObject:(id)object1 withObject:(id)object2; 因为系统提供的performSelector的api中，并没有提供三个参数。因此，我们只能传数组或者字典，但是数组或者字典只有存入对象类型，而结构体并不是对象类型，那么怎么办呢？ 没有办法，我们只能通过对象放入结构作为属性来传过去了： ypedef struct HYBStruct { int a; int b; } *my_struct; @interface HYBObject : NSObject @property (nonatomic, assign) my_struct arg3; @property (nonatomic, copy) NSString *arg1; @property (nonatomic, copy) NSString *arg2; @end @implementation HYBObject // 在堆上分配的内存，我们要手动释放掉 - (void)dealloc { free(self.arg3); } @end 测试： my_struct str = (my_struct)(malloc(sizeof(my_struct))); str->a = 1; str->b = 2; HYBObject *obj = [[HYBObject alloc] init]; obj.arg1 = @"arg1"; obj.arg2 = @"arg2"; obj.arg3 = str; [self performSelector:@selector(call:) withObject:obj]; // 在回调时得到正确的数据的 - (void)call:(HYBObject *)obj { NSLog(@"%d %d", obj.arg3->a, obj.arg3->b); } objc中向一个对象发送消息[obj foo]和objc_msgSend()函数之间有什么关系？实际上，编译器在编译时会转换成objc_msgSend，大概会像这样： ((void (*)(id, SEL))(void)objc_msgSend)((id)obj, sel_registerName("foo")); 也就是说，[obj foo];在objc动态编译时，会被转换为：objc_msgSend(obj, @selector(foo));这样的形式，但是需要根据具体的参数类型及返回值类型进行相应的类型转换。 下面的代码输出什么？@implementation Son : Father - (id)init { self = [super init]; if (self) { NSLog(@"%@", NSStringFromClass([self class])); NSLog(@"%@", NSStringFromClass([super class])); } return self; } @end // 输出 NSStringFromClass([self class]) = Son NSStringFromClass([super class]) = Son 这个题目主要是考察关于Objective-C中对self和super的理解。我们都知道：self是类的隐藏参数，指向当前调用方法的这个类的实例。那super呢？很多人会想当然的认为“super和self类似，应该是指向父类的指针吧！”。这是很普遍的一个误区。其实 super是一个 Magic Keyword，它本质是一个编译器标示符，和self 是指向的同一个消息接受者！他们两个的不同点在于：super会告诉编译器，调用class 这个方法时，要去父类的方法，而不是本类里的。 上面的例子不管调用[self class]还是[super class]，接受消息的对象都是当前 Son ＊xxx 这个对象。当使用self调用方法时，会从当前类的方法列表中开始找，如果没有，就从父类中再找；而当使用super时，则从父类的方法列表中开始找。然后调用父类的这个方法。 若一个类有实例变量NSString *_foo，调用setValue:forKey:时，可以以foo还是_foo作为key？ 两者都可以。 什么时候使用NSMutableArray，什么时候使用NSArray? 当数组在程序运行时，需要不断变化的，使用NSMutableArray，当数组在初始化后，便不再改变的，使用NSArray。需要指出的是，使用NSArray只表明的是该数组在运行时不发生改变，即不能往NSAarry的数组里新增和删除元素，但不表明其数组內的元素的内容不能发生改变。NSArray是线程安全的，NSMutableArray不是线程安全的，多线程使用到NSMutableArray需要注意。 类NSObject的那些方法经常被使用? NSObject是Objetive-C的基类，其由NSObject类及一系列协议构成。 其中类方法alloc、class、 description 对象方法init、dealloc、– performSelector:withObject:afterDelay:等经常被使用 什么是简便构造方法? 简便构造方法一般由CocoaTouch框架提供，如NSNumber的`objc numberWithBool: numberWithChar: numberWithDouble: numberWithFloat: numberWithInt:` Foundation下大部分类均有简便构造方法，我们可以通过简便构造方法，获得系统给我们创建好的对象，并且不需要手动释放。 什么是构造方法，使用构造方法有什么注意点。什么是构造方法：构造方法是对象初始化并一个实例的方法。 构造方法有什么用： 一般在构造方法里 对类进行一些初始化操作 注意点：方法开头必须以init开头，接下来名称要大写 例如 initWithName ，initLayout 创建一个对象需要经过那三个步骤？ 开辟内存空间 初始化参数 返回内存地址值 Get方法的作用是什么？Get方法的作用：为调用者返回对象内部的成员变量 Set方法的作用是什么？Set方法的好处？ Set方法的作用：为外界提供一个设置成员变量值的方法。 Set方法的好处： 不让数据暴露在外，保证了数据的安全性 对设置的数据进行过滤 结构体当中能定义oc对象吗？不能, 因为结构体当中只能是类型的声明不能进行分配空间 点语法本质是什么,写一个点语法的例子,并写上注释 点语法的本质是方法的调用，而不是访问成员变量，当使用点语法时，编译器会自动展开成相应的方法。切记点语法的本质是转换成相应的set和get方法，如果没有set和get方法，则不能使用点语法。 例如有一个Person类 通过@property定义了name和age属性,再提供了一个run方法。 Person *person = [Person new]; person.name=@”sk666”;//调用了person的setName方法 int age = person.age; // 调用了person的age方法 person.run //调用了person的run方法 id类型是什么，instancetype是什么，有什么区别？ id类型：万能指针，能作为参数，方法的返回类型。 instancetype：只能作为方法的范围类型，并且返回的类型是当前定义类的类类型。 成员变量名的命名以下划线开头的好处？ 与get方法的方法名区分开来； 可以和一些其他的局部变量区分开来，下划线开头的变量，通常都是类的成员变量。 这段代码有什么问题吗:@implementation Person - (void)setAge:(int)newAge { self.age = newAge; } @end 会死循环,会重复调用自己!self.age 改为_age即可; 并且书写不规范:setter方法中的newAge应该为age 截取字符串”20 | http://www.baidu.com” 中, ”|”字符前面和后面的数据,分别输出它们。NSString * str = @"20 | http://www.baidu.com"; NSArray *array = [str componentsSeparatedByString:@"|"]; //这是分别输出的截取后的字符串 for (int i = 0; i]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS面试题3--C语言]]></title>
    <url>%2F2018%2F09%2F12%2FiOS%E9%9D%A2%E8%AF%95%E9%A2%983-C%E8%AF%AD%E8%A8%80%2F</url>
    <content type="text"><![CDATA[C语言，开发的基础功底，iOS很多高级应用都要和C语言打交道，所以，C语言在iOS开发中的重要性，你懂的。里面的一些问题可能并不是C语言问题，但是属于计算机的一些原理性的知识点，所以我就不再另外写一篇文章了，直接写在这里。 当你写下面的代码时会发生什么事？ least = MIN(*p++, b); 结果是：((p++) &lt;= (b) ? (p++) : (*p++)) 这个表达式会产生副作用，指针p会作三次++自增操作。 用预处理指令#define声明一个常数，用以表明1年中有多少秒（忽略闰年问题）#define SECONDS_PER_YEAR (60 * 60 * 24 * 365)UL(UL无符号长整形) 写一个”标准”宏MIN ，这个宏输入两个参数并返回较小的一个。#define MIN(A,B) （（A） &lt;= (B) ? (A) : (B)) 写一个标准宏Max，并给出以下代码的输出int array[5] = {1, 2, 3, 4, 5}; int *p = &amp;array[0]; int max = Max(*p++, 1); printf("%d %d", max, *p); 参考答案： 1，2 #define Max(X, Y) ((X) > (Y) ? (X) : (Y)) 当看到宏时，就会想到宏定义所带来的副作用。对于++、–，在宏当中使用是最容易产生副作用的，因此要慎用。 分析： p指针指向了数组array的首地址，也就是第一个元素对应的地址，其值为1. 宏定义时一定要注意每个地方要加上圆括号 *p++相当于*p, p++,所以Max(*p++, 1)相当于： (*p++) > (1) ? (*p++) : (1) => (1) > (1) ? (*p++) : (1) => 第一个*p++的结果是，p所指向的值变成了2，但是1 > 1为値，所以最终max的值就是1。而后面的(*p++)也就不会执行，因此p所指向的地址对应的值就是2，而不是3. 扩展：如果上面的*p++改成*(++p)如何？ (*++p) > (1) ? (*++p) : (1) => (2) > (1) ? (*++p) : (1) => max = *++p; => *p = 3，max = 3; define定义的宏和const定义的常量有什么区别？λ #define定义宏的指令，程序在预处理阶段将用#define所定义的内容只是进行了替换。因此程序运行时，常量表中并没有用#define所定义的宏，系统并不为它分配内存，而且在编译时不会检查数据类型，出错的概率要大一些。 λ const定义的常量，在程序运行时是存放在常量表中，系统会为它分配内存，而且在编译时会进行类型检查。 #define定义表达式时要注意“边缘效应”，例如如下定义： #define N 2 + 3 // 我们预想的N值是5，我们这样使用N int a = N / 2; // 我们预想的a的值是2.5，可实际上a的值是3.5 关键字volatile有什么含意?并给出三个不同的例子 优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。下面是volatile变量的几个例子： 并行设备的硬件寄存器（如：状态寄存器） 一个中断服务子程序中会访问到的非自动变量(Non-automatic variables) 多线程应用中被几个任务共享的变量 完成字符串拷贝可以使用sprintf、strcpy、以及memcpy函数，请问这些函数有什么区别?你喜欢哪一个？为什么？这些函数的区别在于实现功能以及操作对象不同。 strcpy：函数操作的对象是字符串，完成从源字符串到目的字符串的拷贝功能。 sprintf：这个函数主要用来实现（字符串或基本数据类型）向字符串的转换功能。如果源对象是字符串，并且指定%s格式符，也可实现字符串拷贝功能。 memcpy：函数顾名思义就是内存拷贝，实现将一个内存块的内容复制到另一个内存块这一功能。内存块由其首地址以及长度确定。因此，memcpy 的操作对象适用于任意数据类型，只要能给出对象的起始地址和内存长度信息、并且对象具有可操作性即可。鉴于memcpy函数等长拷贝的特点以及数据类型代表的物理意义，memcpy函数通常限于同种类型数据或对象之间的拷贝，其中当然也包括字符串拷贝以及基本数据类型的拷贝。 对于字符串拷贝来说，用上述三个函数都可以实现，但是其实现的效率和使用的方便程度不同： strcpy 无疑是最合适的选择：效率高且调用方便。 snprintf 要额外指定格式符并且进行格式转化，麻烦且效率不高。 memcpy 虽然高效，但是需要额外提供拷贝的内存长度这一参数，易错且使用不便；并且如果长度指定过大的话（最优长度是源字符串长度 + 1），还会带来性能的下降。其实 strcpy 函数一般是在内部调用 memcpy函数或者用汇编直接实现的，以达到高效的目的。因此，使用 memcpy 和 strcpy 拷贝字符串在性能上应该没有什么大的差别。 对于非字符串类型的数据的复制来说，strcpy和snprintf一般就无能为力了，可是对memcpy却没有什么影响。但是，对于基本数据类型来说，尽管可以用 memcpy 进行拷贝，由于有赋值运算符可以方便且高效地进行同种或兼容类型的数据之间的拷贝，所以这种情况下memcpy几乎不被使用。memcpy的长处是用来实现（通常是内部实现居多）对结构或者数组的拷贝，其目的是或者高效，或者使用方便，甚或两者兼有。 sprintf,strcpy,memcpy使用上有什么要注意的地方 strcpy是一个字符串拷贝的函数，它的函数原型为strcpy(char dst, const char src); 将src开始的一段字符串拷贝到dst开始的内存中去，结束的标志符号为 ‘\0’，由于拷贝的长度不是由我们自己控制的，所以这个字符串拷贝很容易出错。 具备字符串拷贝功能的函数有memcpy，这是一个内存拷贝函数，它的函数原型为memcpy(char dst, const char src, unsigned int len);将长度为len的一段内存，从src拷贝到dst中去，这个函数的长度可控。但是会有内存读写错误。(比如len的长度大于要拷贝的空间或目的空间) sprintf是格式化函数。将一段数据通过特定的格式，格式化到一个字符串缓冲区中去。sprintf格式化的函数的长度不可控，有可能格式化后的字符串会超出缓冲区的大小，造成溢出。 static关键字的作用 隐藏。编译多个文件时，所有未加static前缀的全局变量和函数都全局可见。 保持变量内容的持久。全局变量和static变量都存储在静态存储区，程序开始运行就初始化，只初始化一次。static控制了变量的作用范围。 默认初始化为0.在静态数据区，内存中的所有字节都是0x00，全局变量和static变量都是默认初始化为0. static关键字区别： static全局变量与普通的全局变量有什么区别：static全局变量只初使化一次，防止在其他文件单元中被引用; static局部变量和普通局部变量有什么区别：static局部变量只被初始化一次，下一次依据上一次结果值； static函数与普通函数有什么区别：static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝 关键字const const int a;int const a; 作用是一样：a 是一个常整型数 const int a;int const a; a 是一个指向常整型数的指针(整型数是不可修改的，但指针可以) int * const a;a 是一个指向整型数的常指针(指针指向的整型数是可以修改的，但指针是不可修改的) int const * const a;a 是一个指向常整型数的常指针(指针指向的整型数是不可修改的，同时指针也是不可修改的) 堆栈 管理方式：对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生内存泄露 (memory leak)。 申请大小： 栈：在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在Windows下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示 overflow。因此，能从栈获得的空间较小。 堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。 碎片问题： 对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个 问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出 分配方式： 堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由 alloc函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。 分配效率： 栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的 效率比较高。堆则是C/C++函数库提供的，它的机制是很复杂的 数组和指针的区别 数组可以申请在栈区和数据区；指针可以指向任意类型的内存块 sizeof作用于数组时，得到的是数组所占的内存大小；作用于指针时，得到的都是4个字节的大小 数组名表示数组首地址，是常量指针，不可修改指向。比如不可以将＋＋作用于数组名上；普通指针的值可以改变，比如可将＋＋作用于指针上 用字符串初始化字符数组是将字符串的内容拷贝到字符数组中；用字符串初始化字符指针是将字符串的首地址赋给指针，也就是指针指向了该字符串 引用和指针的区别 指针指向一块内存，内容存储所指内存的地址。 引用是某块内存的别名。 引用使用时不需要解引用（*）而指针需要 引用只在定义时被初始化，之后不可变，指针可变。 引用没有const 引用不能为空 sizeof引用得到的是所指向变量（对象）的大小，sizeof指针是指针本身的大小。 指针和引用的自增(++)运算意义不一样：引用++为引用对象自己++，指针++是指向对象后面的内存 程序需要为指针分配内存区域，引用不需要。 用变量a给出下面的定义 一个整型数（An integer） 一个指向整型数的指针（ A pointer to an integer） 一个指向指针的的指针，它指向的指针是指向一个整型数（ A pointer to a pointer to an intege）r 一个有10个整型数的数组（ An array of 10 integers） 一个有10个指针的数组，该指针是指向一个整型数的。（An array of 10 pointers to integers） 一个指向有10个整型数数组的指针（ A pointer to an array of 10 integers） 一个指向函数的指针，该函数有一个整型参数并返回一个整型数（A pointer to a function that takes an integer as an argument and returns an integer） 一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数（ An array of ten pointers to functions t hat take an integer argument and return an integer ） 答案是： int a; // An integer int *a; // A pointer to an integer int **a; // A pointer to a pointer to an integer int a[10]; // An array of 10 integers int *a[10]; // An array of 10 pointers to integers int (*a)[10]; // A pointer to an array of 10 integers int (*a)(int); // A pointer to a function a that takes an integer argument and returns an integer int (*a[10])(int); // An array of 10 pointers to functions that take an integer argument and return an integer 请写出以下代码输出int a[5] = {1, 2, 3, 4, 5}; int *ptr = (int *)(&amp;a + 1); printf("%d, %d", *(a + 1), *(ptr + 1)); 参考答案： 2, 随机值 这种类型题好像挺常见的。考的就是C语言上的指针的理解和数组的理解。 分析： a代表有5个元素的数组的首地址，a[5]的元素分别是1，2，3，4，5。接下来，a + 1表示数据首地址加1，那么就是a[1]，也就是对应于值为2.但是，这里是&amp;a + 1，因为a代表的是整个数组，它的空间大小为5 * sizeof(int)，因此&amp;a + 1就是a+5。a是个常量指针，指向当前数组的首地址，指针+1就是移动sizeof(int)个字节。 因此，ptr是指向int *类型的指针，而ptr指向的就是a + 5，那么ptr + 1也相当于a + 6，所以最后的*(ptr + 1)就是一个随机值了。而*(ptr – 1)就相当于a + 4，对应的值就是5。 简述内存分区情况 代码区：存放函数二进制代码 数据区：系统运行时申请内存并初始化，系统退出时由系统释放，存放全局变量、静态变量、常量 堆区：通过malloc等函数或new等操作符动态申请得到，需程序员手动申请和释放 栈区：函数模块内申请，函数结束时由系统自动释放，存放局部变量、函数参数 用NSLog函数输出一个浮点类型，结果四舍五入，并保留一位小数float money = 1.011; NSLog(@"%.1f", money);]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS面试题2--UNIX常用命令]]></title>
    <url>%2F2018%2F09%2F12%2FiOS%E9%9D%A2%E8%AF%95%E9%A2%982-UNIX%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[做开发说用不到命令行，那肯定是不可能的。所以记住几个常用的命令还是很有用。 cd 改变工作目录 pwd 输出当前工作目录的绝对路径 在UNIX中要执行什么命令，一定要知道自己当前所在的工作目录 ls 查看文件 $ ls 显示文件 $ ls -a 显示所有文件 $ ls -l 列表显示文件 $ ls -la 列表显示所有文件 touch 用于更改文件访问和修改时间的标准UNIX程序，也被用于创建新文件 $ touch test.txt 注意：touch不修改test.txt内容，只更改它的访问、修改时间，如果test.txt不存在，它会被创建 cat 连续查看文件内容 more 分页查看文件内容 提示： 1&gt; 命令和参数之间需要添加空格 2&gt; 如果要使用当前目录中的文件名，输入到一半时，按TAB键能够补全]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS面试题1--版本控制]]></title>
    <url>%2F2018%2F09%2F12%2FiOS%E9%9D%A2%E8%AF%95%E9%A2%981-%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[面试过程中，可能会问及一些关于版本控制的问题，理解下SVN和Git的原理，记住常用命令即可。 SVN SVN 是集中式源代码管理工具 概念： 1&gt; Repository 代码仓库，保存代码的仓库 2&gt; Server 服务器，保存所有版本的代码仓库 3&gt; Client 客户端，只保存当前用户的代码仓库 4&gt; 用户名&amp;密码 访问代码仓库需要使用自己的&quot;用户名和密码&quot;，从而可以区分出不同的人对代码做的修改 操作： 1&gt; checkout 将服务器上最新的代码仓库下载到本地，&quot;只需要做一次&quot; 2&gt; update 从服务器上将其他人所做的修改下载到本地，&quot;每天上班必须要做的事情&quot; 3&gt; commit 将工作提交到服务器，&quot;每天下班之前至少做一次&quot; SVN服务器安装(略) SVN常用命令 切换工作目录 $ cd 工作目录 checkout服务器上的代码仓库 $ svn co http://xxx/svn/xxxx --username=manager --password=manager 提示：checkout(co)之后，命令行会记录用户名和密码，后续操作不用再另行指定 查看本地代码库状态 $ svn st 错误提示：&quot;is not a working copy&quot;，必须在svn的工作目录下才能正确使用svn的命令 查看svn日志 $ svn log 查看某一个文件的日志 $ svn log filename 查看某一个文件某个版本的日志 $ svn log filename@1 创建文件 $ touch main.c 打开并编写文件内容 $ open main.c 查看工作目录状态 $ svn st 将文件添加到本地版本库中 $ svn add main.c/main.* 将文件提交到服务器的版本库中 $ svn ci -m &quot;备注信息&quot; 注意：一定要养成写注释的良好习惯 删除文件 $ svn rm Person.h 提交删除 $ svn ci -m &quot;删除了文件&quot; 注意：不要使用文件管理器直接删除文件 撤销修改 $ svn revert Person.m 恢复到之前的某个版本 $ svn update -r 5 冲突解决 (p) postpone 对比 (mc) mine-conflict 使用我的 (tc) theirs-conflict 使用对方的 svn st 显示的文件状态 &#39; &#39; 没有修改 &#39;A&#39; 被添加到本地代码仓库 &#39;C&#39; 冲突 &#39;D&#39; 被删除 &#39;I&#39; 被忽略 &#39;M&#39; 被修改 &#39;R&#39; 被替换 &#39;X&#39; 外部定义创建的版本目录 &#39;?&#39; 文件没有被添加到本地版本库内 &#39;!&#39; 文件丢失或者不完整（不是通过svn命令删除的文件） &#39;~&#39; 受控文件被其他文件阻隔 Git git是一款开源的分布式版本控制工具 $ git help 查看git所有命令的帮助 $ git help 子命令 要退出帮助信息，按&quot;q&quot; 翻看下页，按&quot;空格&quot; 翻看上页，按&quot;CTRL+B&quot; 要搜索相关文字，按&quot;/&quot;然后输入&quot;相关文字&quot; 创建代码仓库 $ git init 配置用户名和邮箱 $ git config user.name manager $ git config user.email manager@gmail.com 以上两个命令会将用户信息保存在当前代码仓库中 如果要一次性配置完成可以使用一下命令 $ git config --global user.name manager $ git config --global user.email manager@gmail.com 以上两个命令会将用户信息保存在用户目录下的 .gitconfig 文件中 查看当前所有配置 $ git config -l 创建代码，开始开发 $ touch main.c $ open main.c 将代码添加到代码库 查看当前代码库状态 $ git status 将文件添加到代码库 $ git add main.c 将修改提交到代码库 $ git commit -m &quot;添加了main.c&quot; 在此一定要使用 -m 参数指定修改的备注信息 否则会进入 vim 编辑器，如果对vim不熟悉，会是很糟糕的事情 将当前文件夹下的所有新建或修改的文件一次性添加到代码库 $ git add . 添加多个文件 $ touch Person.h Person.m $ git add . $ git commit -m &quot;添加了Person类&quot; $ open Person.h $ git add . $ git commit -m &quot;增加Person类属性&quot; 注意 使用git时，每一次修改都需要添加再提交，这一点是与svn不一样的 查看所有版本库日志 $ git log 查看指定文件的版本库日志 $ git log 文件名 回到当前版本，放弃所有没有提交的修改 $ git reset --hard HEAD 回到上一个版本 $ git reset --hard HEAD^ 回到之前第3个修订版本 $ git reset --hard HEAD~3 回到指定版本号的版本 $ git reset --hard e695b67 查看分支引用记录 $ git reflog 为什么要用源代码管理工具 能追踪一个项目从诞生一直到定案的过程 记录一个项目的所有内容变化 方便地查阅特定版本的修订情况 最常用的版本控制工具是什么，能大概讲讲原理么？参考答案： 最常用的版本控制工具有SourceTree（GIT）和CornerStone（SVN）； 原理提到svn是集中式代码管理，解释下具体意思，git也这样回答就行了。 集中式代码管理（SVN）的核心是服务器，所有开发者在开始新一天的工作之前必须从服务器获取代码，然后开发，最后解决冲突，提交。所有的版本信息都放在服务器上。如果脱离了服务器，开发者基本上可以说是无法工作的。 分布式的版本控制系统，在Git中并不存在主库这样的概念，每一份出的库都可以独立使用，任何两个库之间的不一致之处都可以进行合并。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS体系结构图]]></title>
    <url>%2F2018%2F09%2F12%2FiOS%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[这张图是github上一位大牛所制作。建议找工作的同学，把这张图打印出来，自己对着看，有哪些知识点遗忘的，赶紧去复习，每天过一遍，保证你面试的时候胸有成竹。 在这里，我将总结这段时间收集的和面试记录下来的各类问题，助各位同学面试一臂之力。文章如有问题，请留言，我将及时更正。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[速学block在ARC和MRC中的使用]]></title>
    <url>%2F2018%2F09%2F04%2F%E9%80%9F%E5%AD%A6block%E5%9C%A8ARC%E5%92%8CMRC%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1.ARC转MRC MRC转ARC首先, 先要了解下ARC转MRC和MRC转ARC.ARC项目转MRC创建项目, 打开Xcode, 点击项目, 找到Build Phases中的Compile Sources, 将需要转为MRC的 .m文件加入编译标记 -fno-objc-arc MRC项目转ARC给MRC项目中.m文件添加ARC标记 -fobjc-arc 2.示例演示Example A void exampleA() { char a = 'A'; ^{ printf("%c\n", a); }(); } 1.ARC和MRC都有效 ?2.只有ARC 有效?3.MRC有效 ?4.都没有效? Example B void exampleB_addBlockToArray(NSMutableArray *array) { char b = 'B'; [array addObject:^{ printf("%c\n", b); }]; } void exampleB() { NSMutableArray *array = [NSMutableArray array]; exampleB_addBlockToArray(array); void (^block)(void) = [array objectAtIndex:0]; block(); //MRC 断点查看下 __NSStackBlock__ NSLog(@"%@", [block class]);// ARC __NSMallocBlock__ } 1.ARC和MRC都有效 ?2.只有ARC 有效?3.MRC有效 ?4.都没有效? Example C void exampleC_addBlockToArray(NSMutableArray *array) { [array addObject:^{ printf("C\n"); }]; } void exampleC() { NSMutableArray *array = [NSMutableArray array]; exampleC_addBlockToArray(array); void (^block)(void) = [array objectAtIndex:0]; block(); NSLog(@"%@", [block class]); // __NSGlobalBlock__ } 1.ARC和MRC都有效 ?2.只有ARC 有效?3.MRC有效 ?4.都没有效? Example D typedef void (^dBlock)(void); dBlock exampleD_getBlock() { char d = 'D'; return ^{ printf("%c\n", d); } ; } void exampleD() { exampleD_getBlock()(); } 1.ARC和MRC都有效 ?2.只有ARC 有效?3.MRC有效 ?4.都没有效? Example E typedef void (^eBlock)(void); eBlock exampleE_getBlock() { char e = 'E'; void (^block)(void) = ^{ printf("%c\n", e); }; return block; } void exampleE() { eBlock block = exampleE_getBlock(); block(); //MRC 断点查看下 __NSStackBlock__ NSLog(@"%@", [block class]); // ARC __NSMallocBlock__ } 1.ARC和MRC都有效 ?2.只有ARC 有效?3.MRC有效 ?4.都没有效? 3.解析Example A: ARC和MRC都有效 不管在 ARC 还是 MRC 下，不论 block 存放在 stack 还是 heap 内存中，当example A 被调用时，block 仍然有效，都能正常执行. Example B: 只有ARC 有效 在 MRC 下，exampleB_addBlockToArray 中的 block 是 NSStackBlock 类型，存放在stack内存中。当执行 exampleB 时，stack 内存被释放，block 失效. 在 ARC 下，block 是 autoreleased NSMallocBlock 类型，存放在 heap 内存中，所以 Exmaple B 只有ARC 有效. Example C: ARC和MRC都有效 当 block 不需要从外部获取变量时，它不需要在 runtime 设置任何状态。此时，block 被编译成 NSGlobalBlock 类型，放在内存 data 段，就像 C 函数一样，属于代码的一部分，所以 ARC和MRC都有效. Example D: 只有ARC 有效 这题有点类似于 Example B. 在 MRC 下，exampleD_getBlock 中的block 会被创建在 stack 内存中，当函数返回时，block马上失效。鉴于本题的错误实在太明显，编译器在编译时，就会抛出错误 error: returning block that lives on the local stack. 而在 ARC 下，block 会被编译成 autoreleased NSMallocBlock 类型，存放于 heap 内存中。所以 只有ARC 有效. Example E: 只有ARC 有效 本题类似于 Example D，区别在于本题代码不会出现编译错误，而是在运行时才会崩溃。更槽糕的是，如果你关闭了编译器优化选项，代码运行正常，而无法发现这个隐藏的bug。 而在 ARC 下，block 会被编译成 autoreleased NSMallocBlock 类型，存放于 heap 内存中。所以 只有ARC 有效. 4.总结总结1: MRC 中block 没有引用外部变量, block为 NSGlobalBlock 类型,存储在全局数据区.MRC 中block 引用外部变量,block为NSStackBlock 类型,存储在栈内存中.所以, 在block所属的栈作用域外使用block时, 需要将调用copy方法将该block存储在堆区. 总结2: ARC 中 没有引用外部变量, block为 NSGlobalBlock 类型,存储在全局数据区.ARC 中 引用外部变量, block为 autoreleased NSMallocBlock 类型,存储在堆内存中. 例外:匿名block 引用外部变量 在ARC下其实很少见到 NSStackBlock 类的Block，大多数情况编译器都保证了Block是在堆上创建的 int count = 11; NSLog(@"Stack Block:%@", [^{NSLog(@"Stack Block:%d",count);} class]); //打印：Stack Block:__NSStackBlock__ 5.以上这么多例子告诉我们什么？告诉我们要使用ARC！在ARC下，block总能正确运行。如果你不用ARC，最好能保证在 stack 内存中声明定义的block，能够拷贝到heap内存，保证block的正常运行。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>block</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown语法]]></title>
    <url>%2F2018%2F08%2F30%2Fmarkdown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[欢迎使用马克飞象@(示例笔记本)[马克飞象|帮助|Markdown] 马克飞象是一款专为印象笔记（Evernote）打造的Markdown编辑器，通过精心的设计与技术实现，配合印象笔记强大的存储和同步功能，带来前所未有的书写体验。特点概述： 功能丰富 ：支持高亮代码块、LaTeX 公式、流程图，本地图片以及附件上传，甚至截图粘贴，工作学习好帮手； 得心应手 ：简洁高效的编辑器，提供[桌面客户端][1]以及[离线Chrome App][2]，支持移动端 Web； 深度整合 ：支持选择笔记本和添加标签，支持从印象笔记跳转编辑，轻松管理。 [TOC] (不支持) Markdown简介(hexo引用不一样) Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。 —— 维基百科 正如您在阅读的这份文档，它使用简单的符号标识不同的标题，将某些文字标记为粗体或者斜体，创建一个链接或一个脚注[^demo]。下面列举了几个高级功能，更多语法请按Cmd + /查看帮助。 代码块@requires_authorization def somefunc(param1='', param2=0): '''A docstring''' if param1 > param2: # interesting print 'Greater' return (param2 - param1 + 1) or None class SomeClass: pass >>> message = '''interpreter ... prompt''' LaTeX 公式 (hexo不支持此写法)可以创建行内公式，例如 $\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N$。或者块级公式： $$ x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a} $$ 表格 (不一样) Item Value Qty Computer 1600 USD 5 Phone 12 USD 12 Pipe 1 USD 234 流程图 (hexo不支持此写法)st=>start: Start e=>end op=>operation: My Operation cond=>condition: Yes or No? st->op->cond cond(yes)->e cond(no)->op 以及时序图: Alice->Bob: Hello Bob, how are you? Note right of Bob: Bob thinks Bob-->Alice: I am good thanks! 提示：想了解更多，请查看流程图[语法][3]以及时序图[语法][4]。 复选框使用 - [ ] 和 - [x] 语法可以创建复选框，实现 todo-list 等功能。例如： 已完成事项 待办事项1 待办事项2 注意：目前支持尚不完全，在印象笔记中勾选复选框是无效、不能同步的，所以必须在马克飞象中修改 Markdown 原文才可生效。下个版本将会全面支持。 印象笔记相关笔记本和标签马克飞象增加了@(笔记本)[标签A|标签B]语法, 以选择笔记本和添加标签。 绑定账号后， 输入(自动会出现笔记本列表，请从中选择。 笔记标题马克飞象会自动使用文档内出现的第一个标题作为笔记标题。例如本文，就是第一行的 欢迎使用马克飞象。 快捷编辑保存在印象笔记中的笔记，右上角会有一个红色的编辑按钮，点击后会回到马克飞象中打开并编辑该笔记。 注意：目前用户在印象笔记中单方面做的任何修改，马克飞象是无法自动感知和更新的。所以请务必回到马克飞象编辑。 数据同步马克飞象通过将Markdown原文以隐藏内容保存在笔记中的精妙设计，实现了对Markdown的存储和再次编辑。既解决了其他产品只是单向导出HTML的单薄，又规避了服务端存储Markdown带来的隐私安全问题。这样，服务端仅作为对印象笔记 API调用和数据转换之用。 隐私声明：用户所有的笔记数据，均保存在印象笔记中。马克飞象不存储用户的任何笔记数据。 离线存储马克飞象使用浏览器离线存储将内容实时保存在本地，不必担心网络断掉或浏览器崩溃。为了节省空间和避免冲突，已同步至印象笔记并且不再修改的笔记将删除部分本地缓存，不过依然可以随时通过文档管理打开。 注意：虽然浏览器存储大部分时候都比较可靠，但印象笔记作为专业云存储，更值得信赖。以防万一，请务必经常及时同步到印象笔记。 编辑器相关设置右侧系统菜单（快捷键Cmd + M）的设置中，提供了界面字体、字号、自定义CSS、vim/emacs 键盘模式等高级选项。 快捷键帮助 Cmd + /同步文档 Cmd + S创建文档 Cmd + Opt + N最大化编辑器 Cmd + Enter预览文档 Cmd + Opt + Enter文档管理 Cmd + O系统菜单 Cmd + M 加粗 Cmd + B插入图片 Cmd + G插入链接 Cmd + L提升标题 Cmd + H 关于收费马克飞象为新用户提供 10 天的试用期，试用期过后需要续费才能继续使用。未购买或者未及时续费，将不能同步新的笔记。之前保存过的笔记依然可以编辑。 反馈与建议 微博：@马克飞象，@GGock 邮箱：&#104;&#x75;&#x73;&#116;&#103;&#x6f;&#x63;&#x6b;&#64;&#x67;&#x6d;&#97;&#105;&#108;&#46;&#x63;&#111;&#x6d; 感谢阅读这份帮助文档。请点击右上角，绑定印象笔记账号，开启全新的记录与分享体验吧。 [^demo] (hexo不支持) [^demo]: 这是一个示例脚注。请查阅 MultiMarkdown 文档 关于脚注的说明。 限制： 印象笔记的笔记内容使用 [ENML][5] 格式，基于 HTML，但是不支持某些标签和属性，例如id，这就导致脚注和TOC无法正常点击。 (支持) [1]: http://maxiang.info/client_zh [2]: https://chrome.google.com/webstore/detail/kidnkfckhbdkfgbicccmdggmpgogehop [3]: http://adrai.github.io/flowchart.js/ [4]: http://bramp.github.io/js-sequence-diagrams/ [5]: https://dev.yinxiang.com/doc/articles/enml.php]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo语法体验]]></title>
    <url>%2F2018%2F08%2F30%2Fhexo%E8%AF%AD%E6%B3%95%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[标签插件（Tag Plugins）引用块在文章中插入引言，可包含作者、来源和标题。 别号： quotecontent [author[source]] [link] [source_link_title] 样例没有提供参数，则只输出普通的 blockquote Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem. 111111 222222 333 代码块在文章中插入代码。 别名： codecode snippet 样例普通的代码块alert(&#39;Hello World!&#39;); alert(‘Hello World!’); 指定语言[rectangle setX: 10 y: 10 width: 20 height: 20]; [rectangle setX: 10 y: 10 width: 20 height: 20]; [rectangle setX: 10 y: 10 width: 20 height: 20]; 附加说明array.map(callback[, thisArg]) Array.maparray.map(callback[, thisArg]) 附加说明和网址_.compact([0, 1, false, 2, &#39;&#39;, 3]); =&gt; [1, 2, 3] _.compactUnderscore.js_.compact([0, 1, false, 2, ‘’, 3]);=&gt; [1, 2, 3] 反引号代码块另一种形式的代码块，不同的是它使用三个反引号来包裹。 [title] [url] [link text] code snippet Image在文章中插入指定大小的图片。 Link在文章中插入链接，并自动给外部链接添加 target=”_blank” 属性。 text url [external] [title] Youtube在文章中插入 Youtube 视频。 Vimeo在文章中插入 Vimeo 视频。 引用文章引用其他文章的链接。 引用资源引用文章的资源。 window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdPic":"","bdStyle":"0","bdSize":"16"},"share":{},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["qzone","tsina","tqq","renren","weixin"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客开篇]]></title>
    <url>%2F2018%2F08%2F30%2F%E5%8D%9A%E5%AE%A2%E5%BC%80%E7%AF%87%2F</url>
    <content type="text"><![CDATA[终于下决心要开始写博客了，做程序员快四年了，四年的时间里，由一个嫩头青，成长为了一个能在公司项目里独立完成一些业务逻辑复杂的大模块的中坚程序员。首先我还是概括下这几年的成长历程吧。 由于本人的脸长得比较缓慢，刚出道时还是一张孩童脸，用时下流行的一个词来描述那就是“萌”。因为太萌，刚安排到客户现场做开发时，还被客户开玩笑说你们公司违法招收童工，我一怒之下蓄了几个月胡须，留了几个月飘逸的长发，想让自己在外表上看上去更老成。但不巧的是，此时的我又与那时刚出道的“犀利哥”风格极为类似，又被戏称为犀利程序哥，再怒之下，开始潜心工作，不再追求表面的浮夸，在工作中逐渐展露头角，完成了项目中几个重要需求的开发，在后来的普选中当选为公司年度优秀员工之一。最近1，2年波澜不惊，因为自学没有断过，技术也在逐步积累。 下面进入主题，关于我的博客，我用自问自答的方式来介绍： 1、我为什么要写博客？ 做程序员这几年，技术不断积累，思想不断在升华，有些思考和想法在与同事、朋友的交流中会迸发出来。在交流的过程中，我觉得很过瘾。有些模糊不清的事情，通过交流明确了，有些以为自己把握的很准的事情，通过交流颠覆了，而有些自己已经明白的事情，又开阔了新的思路。但交流只是瞬时的、已逝的，我们的讨论不是国家政要接见外国领导，没有人把我们的谈话记录下来。就像在内存里一样，断电后恢复不了，事后很难回忆起来那些曾经闪光的思想。所以我要把我在程序人生中得到的思想给持久化了，给固化下来。再一个就是，我的同事、朋友始终是我身边熟悉的人，我需要一个更大的世界，所以，我也想通过博客与大家交流！ 2、我的博客写些什么东西？ 这个问题我想了很久，以前想写些关于iOS的、关于前端博文。有时候在草稿中写好一段文字，最后一搜索，全世界拥有同样知识点的，同样解决方案的数不胜数，太多了。作为一个讨厌重复的人，我不能再罗列这些网上一抓一大把的普世技术知识点，更何况以我现在的积累，还不能做到非常好。当然我不是说罗列技术点没有技术含量，正是因为网上这些庞大的知识，我才能很快的找到我想要的，解决我的问题。综上，我不能做重复的事，也不要因为说的东西不扎实而误导别人。当然了，在某个技术领域达到一定境界了，我也会写研究技术细节的博文。 那我写什么？什么是不重复的？那必须斩钉截铁的说那就是我的思想，世上没有任何一个人和我的人生轨迹完全一样，在这个过程中，我会思考我会总结，我要把我的思想留存于世，即使有时候会有相同思想的东西同时存在，那也会因为是我个人的总结和反思而有所不同！ 3、写博客的计划？ 不追求一个月一定要写几篇几篇的，当我有深刻的感触，对事物有不同的理解，我就写一篇，记录下来，一步一个脚印，向卓越程序员迈进！ 夜空霓虹，都是我不要的繁荣，完。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[timeline]]></title>
    <url>%2Ftimeline%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[categories]]></title>
    <url>%2Fcategories%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[tags]]></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"></content>
  </entry>
</search>
