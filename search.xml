<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[iOS开发]iOS13 Scene Delegate]]></title>
    <url>%2F2020%2F07%2F04%2FiOS%E5%BC%80%E5%8F%91-iOS13-Scene-Delegate%2F</url>
    <content type="text"><![CDATA[为了实现iPadOS支持多窗口，Xcode11后创建新工程默认会通过 UIScene 创建并管理多个 UIWindow 的应用，工程中除了 AppDelegate 外还会有一个 SceneDelegate。 一、SceneDelegate介绍1)、Window与SceneiOS13以后，SceneDelegate将负责AppDelegate的某些功能。 window（窗口）的概念被window（场景）的概念所代替， 一个scene现在可以作为您应用程序的用户界面和内容的载体。iOS13以前一个应用程序可以有不止一个window，同样现在一个应用程序也可以有不止一个scene。 2)、SceneDelegate三处新增内容iOS13以后，Xcode新建iOS项目中有增加三处新增内容: 1&gt; 添加一个新的类SceneDelegate 2&gt; AppDelegate类中新增与scene sessions相关的新方法： application(_:configurationForConnecting:options:) application(_:didDiscardSceneSessions:) 3&gt; Info.plist文件中新增Application Scene Manifest配置项，用于配置App的scene，包括它们的scene配置名，delegate类名和storyboard 下面分别讲解下新增三处内容: 二、SceneDelegate三处新增内容详解1)、SceneDelegate类SceneDelegate和AppDelegate中方法名相似, 是任何应用程序生命周期都会调用方法。 //SceneDelegate.swift 代码 class SceneDelegate: UIResponder, UIWindowSceneDelegate { var window: UIWindow? func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) { guard let _ = (scene as? UIWindowScene) else { return } } func sceneDidDisconnect(_ scene: UIScene) { } func sceneDidBecomeActive(_ scene: UIScene) { } func sceneWillResignActive(_ scene: UIScene) { } func sceneWillEnterForeground(_ scene: UIScene) { } func sceneDidEnterBackground(_ scene: UIScene) { } } scene(_:willConnectTo:options:)函数 : SceneDelegate的最重要的函数，相当于iOS 12上的 application(_:didFinishLaunchingWithOptions:) 函数。当将scene添加到app中时scene(_:willConnectTo:options:)函数会被调用的，因此在这里对scene进行配置。 这里需要特别注意的是，使用一个SceneDelegate来配置App中的所有scene，并且这个delegate通常会响应任何scene。在上面的代码中，我们可以手动地设置了视图控制器堆栈，稍后会进行详细介绍。 SceneDelegate其他方法: sceneDidDisconnect(_:) 当scene与app断开连接是调用（注意，以后它可能被重新连接） sceneDidBecomeActive(_:) 当用户开始与scene进行交互（例如从应用切换器中选择场景）时，会调用 sceneWillResignActive(_:) 当用户停止与scene交互（例如通过切换器切换到另一个场景）时调用 sceneWillEnterForeground(_:) 当scene变成活动窗口时调用，即从后台状态变成开始或恢复状态 sceneDidEnterBackground(_:) 当scene进入后台时调用，即该应用已最小化但仍存活在后台中 2)、AppDelegate类新增两个方法//AppDelegate.swift 代码 @UIApplicationMain class AppDelegate: UIResponder, UIApplicationDelegate { func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool { return true } // MARK: UISceneSession Lifecycle func application(_ application: UIApplication, configurationForConnecting connectingSceneSession: UISceneSession, options: UIScene.ConnectionOptions) -&gt; UISceneConfiguration { return UISceneConfiguration(name: &quot;Default Configuration&quot;, sessionRole: connectingSceneSession.role) } func application(_ application: UIApplication, didDiscardSceneSessions sceneSessions: Set&lt;UISceneSession&gt;) { } } 在iOS13中AppDelegate中新增的两个函数是负责管理Senen Session的代理函数。在应用创建scene(场景)后，scene session对象将跟踪与该scene相关的所有信息。 这两个函数是: application(_:configurationForConnecting:options:) : 方法会返回一个UISceneConfiguration对象，其中包含场景详细信息，包括要创建的场景类型，用于管理场景的代理对象以及包含要显示的初始视图控制器的StoryBoard。 如果未实现此方法，则必须在应用程序的Info.plist文件中提供场景配置数据。注意：该代理方法中返回UISceneConfiguration对象的配置名为Default Configuration，则系统就会自动去调用SceneDelegate这个类。这样SceneDelegate和AppDelegate产生了关联。 application(_:didDiscardSceneSessions:) : 在分屏中关闭其中一个或多个scene时候回调用，可以在该函数中销毁场景所使用的资源。该方法与application(_:didDiscardSceneSessions:)的区别是，该方法仅在场景断开连接时调用，不会被丢弃，它可能会重新连接。而application(_: didDiscardSceneSessions:)发生在使用应用程序切退出场景时。 3)、Info.plist 中的Application Scene Manifest Info.plist文件文件包含App的配置信息，如App的名称，版本，支持的设备方向，现在我们可以通过配置Application Scene Manifest项来支持的不同场景。大多数应用程序只有一个场景，但是可以通过配置该项创建更多场景，如用于响应推送通知或特定操作的特定场景。 Enable Multiple Windows: 默认为NO，其设置为YES可以支持多个窗口。 Application Session Role: 是一个数组，用于在应用程序中声明场景。 该数组每个元素是一个字典，字典中有三个键值,分别为Configuration Name: 当前配置的名字，必须是唯一的;Delegate Class Name: 场景的代理类名，将与该Scene代理对象关联;StoryBoard name: 场景用于创建初始UI的storyboard名称。 AppDelegate方法application(_:configurationForConnecting:options:)返回值为UISceneConfiguration实例，上边三个键值分别对应UISceneConfiguration三个属性name、delegateClass、storyboard 。 默认在info.plist中进行了配置， 不用application(_:configurationForConnecting:options:)方法也没有关系。如果没有在info.plist配置Application Scene Manifest项就需要实现这个方法并返回一个UISceneConfiguration对象。 那么AppDelegate中的SceneDelegate、UISceneSession和Info.plist中的Application Scene Manifest是如何一起创建多窗口应用的呢？ 首先，SceneDelegate类管理场景的生命周期，处理各种响应，如 sceneDidBecomeActive(_:) and sceneDidEnterBackground(_:)之类的事件。 然后，AppDelegate类中的新函数。 它管理scene sessions(场景会话)，提供场景的配置数据，并响应用户丢弃场景的事件。 最后，Application Scene Manifest 列出了当前应用程序支持的场景，并将它们连接到delegate类并初始化storyboard。 三、SceneDelegate适配从iOS13开始AppDelegate不再有window属性，window属性被定义在SceneDelegate中。这是因为iOS13中AppDelegate的职责发现了改变： iOS13之前，AppDelegate的职责全权处理App生命周期和UI生命周期； iOS13之后，AppDelegate的职责是：1、处理 App 生命周期2、新的 Scene Session 生命周期3、UI的生命周期交给新增的Scene Delegate处理。 因此，iOS13以前创建项目如果不需要多窗口就不需要任何改动，而iOS13以后创建新项目时，就要做一些适配: 1. 不需要多窗口（multiple windows） 删除掉info.plist中Application Scene Manifest选项，同时，注释SceneDelegate文件中所有代码，SceneDelegate文件删不删除都可以。 注释 AppDelegate中关于Scene的代理方法 如果使用纯代码来实现显示界面，需要在AppDelegate.h中手动添加window属性，添加以下代码即可： class AppDelegate: UIResponder, UIApplicationDelegate { //手动添加window属性 var window: UIWindow? func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool { self.window = UIWindow(frame:UIScreen.main.bounds) self.window!.backgroundColor = UIColor.white //设置root let rootVC = UIViewController() self.window!.rootViewController = rootVC self.window!.makeKeyAndVisible() return true } // MARK: UISceneSession Lifecycle // func application(_ application: UIApplication, configurationForConnecting connectingSceneSession: UISceneSession, options: UIScene.ConnectionOptions) -&gt; UISceneConfiguration { // return UISceneConfiguration(name: &quot;Default Configuration&quot;, sessionRole: connectingSceneSession.role) // } // func application(_ application: UIApplication, didDiscardSceneSessions sceneSessions: Set&lt;UISceneSession&gt;) { // } } 2. 支持多窗口适配iOS 13后新项目中info.plist中的配置项Application Scene Manifest是针对iPad multiple windows功能推出的。在保留Application Scene Manifest配置项不予删除时（其中，项目是否支持多窗口功能是个可勾选项），AppDelegate的生命周期方法不再起作用，需要在SceneDelegate中使用UIScene提供的生命周期方法，并且需要针对 iOS 13 在Scene中配置和 iOS 13 以下在AppDelegate中做两套配置。 下面是纯代码实现界面显示的代码：Swift适配代码步骤: 1)第一步，SceneDelegate中添加@available(iOS 13, *) //SceneDelegate.swift @available(iOS 13, *) //在类的头部@available(iOS 13, *)添加即可 class SceneDelegate: UIResponder, UIWindowSceneDelegate { .... .... } 2)第二步，AppDelegate中声明window属性，didFinishLaunchingWithOptions中添加版本判断，AppDelegate中新增两个方法前添加@available(iOS 13, )。也可以将这两个方法添加到AppDelegate分类中,分类前添加@available(iOS 13, )。 // AppDelegate.swift @UIApplicationMain class AppDelegate: UIResponder, UIApplicationDelegate { //手动添加window属性 var window: UIWindow? func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool { if #available(iOS 13, *) { } else { window = UIWindow(frame:UIScreen.main.bounds) window!.backgroundColor = UIColor.blue //设置root let rootVC = UIViewController() window!.rootViewController = rootVC window!.makeKeyAndVisible() } return true } //新增方法添加@available(iOS 13, *) @available(iOS 13.0, *) func application(_ application: UIApplication, configurationForConnecting connectingSceneSession: UISceneSession, options: UIScene.ConnectionOptions) -&gt; UISceneConfiguration { return UISceneConfiguration(name: &quot;Default Configuration&quot;, sessionRole: connectingSceneSession.role) } @available(iOS 13.0, *) func application(_ application: UIApplication, didDiscardSceneSessions sceneSessions: Set&lt;UISceneSession&gt;) { } } 3)第三步，SceneDelegate中初始化UIWindow，并添加根视图控制器 @available(iOS 13, *) class SceneDelegate: UIResponder, UIWindowSceneDelegate { var window: UIWindow? func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) { guard let windowScene = (scene as? UIWindowScene) else { return } let window = UIWindow(windowScene: windowScene) let vc = ViewController() vc.view.backgroundColor = .red let navigation = UINavigationController(rootViewController: vc) window.rootViewController = navigation window.makeKeyAndVisible() self.window = window } ... ... } OC适配代码: // AppDelegate.m中 - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions { if (@available(iOS 13.0, *)) { } else { self.window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds]; [self.window setBackgroundColor:[UIColor whiteColor]]; ViewController *vc = [[ViewController alloc] init]; UINavigationController *nav = [[UINavigationController alloc] initWithRootViewController:vc]; [self.window setRootViewController:nav]; [self.window makeKeyAndVisible]; } return YES; } // SceneDelegate.m中 - (void)scene:(UIScene *)scene willConnectToSession:(UISceneSession *)session options:(UISceneConnectionOptions *)connectionOptions { //在这里手动创建新的window if (@available(iOS 13.0, *)) { UIWindowScene *windowScene = (UIWindowScene *)scene; self.window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds]; [self.window setWindowScene:windowScene]; [self.window setBackgroundColor:[UIColor whiteColor]]; ViewController *con = [[ViewController alloc] init]; UINavigationController *nav = [[UINavigationController alloc] initWithRootViewController:con]; [self.window setRootViewController:nav]; [self.window makeKeyAndVisible]; } } 注意:如果不使用storyboard，需要将配置中的storyboard项删除 注意2:AppDelegate中的有关事件循环的方法，在iOS 13后是不会走的，iOS13以下的才会收到事件回调的。iOS13以上会走SceneDelegate对应的方法事件循环方法func applicationWillResignActive(_ application: UIApplication) { } ... ... 四、SwiftUI中SceneDelegateSwiftUI创建的iOS 13项目，所以SwiftUI应用程序主要依靠SceneDelegate来设置应用程序的初始UI。 SwiftUI项目info.plist文件中Application Scene Manifest项配置如下： 默认配置中没有设置“Storyboard Name”这一项。但是如果要配置支持多个窗口，则需要将Enable Multiple Windows设置为YES。 AppDelegate类，和上边iOS新建项目AppDelegate一样。 SceneDelegate类中实现代码，如下 //SceneDelegate.swift import UIKit import SwiftUI class SceneDelegate: UIResponder, UIWindowSceneDelegate { var window: UIWindow? func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) { let contentView = ContentView() if let windowScene = scene as? UIWindowScene { let window = UIWindow(windowScene: windowScene) window.rootViewController = UIHostingController(rootView: contentView) self.window = window window.makeKeyAndVisible() } } ..... ..... } 上面的代码中发生了什么？使用此方法可以有选择地配置UIWindow窗口并将其附加到提供的UIWindowScene场景。如果使用storyboard，则window属性将自动初始化并附加到场景中。 首先，添加新场景会调用scene(_: willConnectTo: options:)方法。 方法传入一个scene对象和一个session，传入的scene对象是由应用程序创建的。 其次，window属性会在这里用到。 App仍然使用UIWindow对象，但现在它们已成为scene（场景）的一部分。 在if let代码块中，使用scene来初始化UIWindow对象。 然后设置window的rootViewController，将window实例赋值给场景的window属性，并且设置窗口makeKeyAndVisible为true，即将该窗口置于App的前面。接着为SwiftUI项目创建了ContentView实例，并通过使用UIHostingController将其添加为根视图控制器。 该控制器用于将基于SwiftUI的视图显示在屏幕上。 最后，UIScene的实例化对象scene实际上是UIWindowScene类型的对象。 这就是as?对可选类型转换的原因。 （到目前为止，已创建的场景通常为“ UIWindowScene”类型，但将来可能还会有更多类型的场景。） 将上边归纳如下内容： 当scene(_: willConnectTo: options:)被调用时，SceneDelegate会在正确的时间配置场景。 AppDelegate和Manifest的默认配置，他们没有涉及storyboard的任何东西。 scene(_: willConnectTo: options: )函数内，创建一个SwiftUI视图，将其放置在托管控制器中，然后将控制器分配给window属性的根视图控制器，并将该窗口放置在应用程序UI的前面 。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Flutter] 09-Flutter真机调试错误处理]]></title>
    <url>%2F2020%2F07%2F02%2FFlutter-09-Flutter%E7%9C%9F%E6%9C%BA%E8%B0%83%E8%AF%95%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[Flutter真机调试错误处理总结:问题1:运行FlutterSDK低版本项目的建议问题2:Xcode iOS Flutter真机调试错误 It appears that your application still contains the default signing identifier问题3:Xcode iOS Flutter真机调试错误: Could not build the precompiled application for the device问题4:Xcode iOS Flutter真机调试错误:Could not install build/ios/iphoneos/Runner.app on 问题1:运行FlutterSDK低版本项目的建议由于FlutterSDK更新比较频繁，有时下载一个项目后会发现，报各种bug，各种问题，下面总结下处理步骤：1&gt; 找到pubspec.yaml 文件，执行 flutter get pub 安装项目所需插件。2&gt; 确定低版本项目的环境配置是否和当前电脑环境一致，下面给出一个笔者下载的低版本项目所需运行环境: Flutter SDK (Channel stable, v1.5.4-hotfix.2, on Mac OS X 10.13.6 17G2112, locale zh-Hans-CN， Dart SDK : 2.5.0) 如果报一些的第三方库方法或者参数错误，查看电脑配置环境Flutter SDK是否高于v1.5.4。笔者当时配置Flutter SDK版本为1.7.2，找到Flutter SDK所在文件夹，git reset --hard commit_id 回退到指定版本v1.5.4后解决。Flutter官网获取commitIdFlutter github项目下获取commitId 问题2:Xcode iOS Flutter真机调试错误 It appears that your application still contains the default signing identifier错误信息: Could not build the precompiled application for the device. It appears that your application still contains the default signing identifier. Try replacing ‘com.example‘ with your signing id in Xcode: open ios/Runner.xcworkspace Error launching application on iPhone. 原因：真机调试时候，应用bundle Id和苹果证书上注册的不一致，或者没有安装苹果开发者证书。 解决：打开xcode修改bundle Id。选择有效期内的苹果开发者证书。注意xcode版本和编译系统版本要和iphone手机系统搭配。 问题3:Xcode iOS Flutter真机调试错误: Could not build the precompiled application for the device错误信息: Could not build the precompiled application for the device. Error launching application on iPhone8p. 解决： 打开Xcode, File-&gt;Workspace Settings-&gt; 找到Build System 选项修改为: Legacy Build System 最后一定要在真机上, 设置信任运行的app! 啰嗦下步骤: 手机设置-&gt;通用-&gt;设备管理-&gt;找到运行app设置信任 问题4:Xcode iOS Flutter真机调试错误:Could not install build/ios/iphoneos/Runner.app on错误信息: Could not install build/ios/iphoneos/Runner.app on xxxxxx. Try launching Xcode and selecting &quot;Product &gt; Run&quot; to fix the problem: open ios/Runner.xcworkspace Error launching application on iPhonesk8p. 原因: 真机上没有信任运行的app!解决: 手机设置-&gt;通用-&gt;设备管理-&gt;找到运行app设置信任]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Flutter] 08-Flutter中的Json转Model]]></title>
    <url>%2F2020%2F06%2F22%2FFlutter-08-Flutter%E4%B8%AD%E7%9A%84Json%E8%BD%ACModel%2F</url>
    <content type="text"><![CDATA[背景: 在开发中，服务端通常返回Json数据，我们需要将Json数据转模型对象来使用。一般情况下，我们会使用一些第三方库来动态转化Model，但是Flutter中没有像Java的Gson/Jackson这类Json序列化类库，因为Flutter中禁用运行时反射。官方解释是运行时反射会干扰Dart的tree shaking，使用tree shaking可以在release版中去除未使用的代码，这可以显著优化应用程序的大小。由于反射会默认应用到所有代码，因此tree shaking会很难工作，因为在启用反射时很难知道哪些代码未被使用，因此冗余代码很难剥离，所以Flutter中禁用了Dart的反射功能，而正因如此也就无法实现动态转化Model的功能。 在此基础上，接下来我们看下Flutter中还有哪几种Json转模型的方式: 一. 手动转化在上篇[Flutter] 07-Flutter中反序列化Json已经通过6个示例分析过了, 这里不再讨论。 二. json_serializablejson_serializable是dart官方推荐和提供的JSON转Model的方式： 一个自动化源代码生成器来为你生成 JSON 序列化数据模板； 由于序列化数据代码不再需要手动编写或者维护，你可以将序列化 JSON 数据在运行时的异常风险降到最低； 第1步：添加相关的依赖依赖分为项目依赖（dependencies），开发依赖（dev_dependencies），在pubspec.yaml中添加如下依赖: dependencies: json_annotation:^3.0.1 dev_dependencies: json_serializable:^3.2.5 build_runner:^1.8.0 注意：添加后需要执行flutter pub get确保我们的项目中有这些依赖。 注意：yaml配置文件对于缩进要求十分严格，下面的build_runner和json_serializable应该是与flutter_test平级的，千万不要写在flutter_test缩进后，这样它会认为这两个是flutter_test的子集目录！ 由于很多朋友在这一步遇到了问题，这里贴出源码: 第2步：以json_serializable 的方式创建模型类 根据下面简单Json数据创建模型类: final jsonInfo = { &quot;nickname&quot;: &quot;coderTao&quot;, &quot;age&quot;: 20, &quot;courses&quot;: [&quot;政治&quot;, &quot;高数&quot;, &quot;英语&quot;], &quot;register_date&quot;: &quot;2018-2-22&quot;, &quot;computer&quot;: { &quot;brand&quot;: &quot;MackBook&quot;, &quot;price&quot;: 9999 } }; User类的代码： // 1.import 导入json_annotation.dart import &#39;package:json_annotation/json_annotation.dart&#39;; import &#39;computer_model.dart&#39;; // 2.user.g.dart 将在我们运行生成命令后json_serializable帮我们自动生成.g.dart文件，在未执行命令前该行可能会报错 part &#39;user_model.g.dart&#39;; // 3.这个标注是告诉生成器，这个类是需要生成Model类的 @JsonSerializable() class User { String name; int age; //显式关联JSON字段名与Model属性的对应关系, // 如下将属性registerDate和register_date字段关联 @JsonKey(name: &quot;register_date&quot;) String registerDate; List&lt;String&gt; courses; Computer computer; // 4.必须的构造方法 User(this.name, this.age, this.registerDate, this.courses, this.computer); // 5.必须有的对应工厂构造器 factory User.fromJson(Map&lt;String, dynamic&gt; json) =&gt; _$UserFromJson(json); Map&lt;String, dynamic&gt; toJson() =&gt; _$UserToJson(this); //这里 toString方法不是必须的, 只是用测试数据 @override String toString() { return&#39;User{name: $name, age: ${age}, registerDate: $registerDate, courses: $courses, computer: $computer}&#39;; } } Computer类的代码： // 1.import 导入json_annotation.dart import &#39;package:json_annotation/json_annotation.dart&#39;; // 2.computer.g.dart 将在我们运行生成命令后json_serializable帮我们自动生成.g.dart文件，在未执行命令前该行可能会报错 part &#39;computer.g.dart&#39;; // 3.这个标注告诉json_serializable哪一个类需要进行转换生成Model类 @JsonSerializable() class Computer { String brand; double price; //4.必须的构造方法 Computer(this.brand, this.price); //5.必须有的对应工厂构造器 factory Computer.fromJson(Map&lt;String, dynamic&gt; json) =&gt; _$ComputerFromJson(json); Map&lt;String, dynamic&gt; toJson() =&gt; _$ComputerToJson(this); //这里 toString方法不是必须的, 只是用测试数据 @override String toString() { return&#39;Computer{brand: $brand, price: $price}&#39;; } } 最后总结一下以json_serializable 的方式创建模型类必须5步: 1.import 导入json_annotation.dart。import &#39;package:json_annotation/json_annotation.dart&#39;; 2.json_serializable根据当前类，以part 类名.g.dart格式生成的文件。以user.dart为例如下: part &#39;user.g.dart&#39;; 3.在class上标注 @JsonSerializable() 告诉json_serializable哪一个类需要进行转换生成Model类。 4.创建必须的构造方法。 5.创建必须的对应的工厂构造器。 备注1:第五步实际就是创建两个方法: 提供一个工厂构造方法User.fromJson，该方法实际调用生成文件的UserFromJson方法进行反序列化。 提供一个toJson()序列化对象的方法，实际调用生成文件的_$UserToJson()方法，并将调用对象解析生成Map。 备注2: _$UserFromJson(json) : 它接收了一个map：Map&lt;String, dynamic&gt;，并将这个Map里的值映射为我们所需要的实体类对象。我们就可以使用这个方法，将存有json数据的map转化为我们需要的实体类对象。 _$UserToJson(this): 将调用此方法的对象直接根据字段映射成Map。而这两个都是私有方法，part让两个文件共享作用域与命名空间，所以我们需要将生成的方法暴露给外部。 备注3:UserFromJson(json)和 ToJson()调用方法，在未执行生成对应的.g.dart文件指令前该行可能会报错。 part &#39;computer.g.dart&#39;;和 part &#39;user.g.dart&#39;; ，在未执行生成对应的.g.dart文件指令前该行可能会报错。 备注4:toString方法不是必须的，只用来打印输出进行测试。 第3步：生成对应的.g.dart文件指令该操作有两种指令:一次性生成指令和 持续性生成指令。 一次性生成指令 在项目终端运行下面的指令： flutter pub run build_runner build 该指令是一次性生成JSON序列化的代码。 该指令通过我们的源文件，找出需要生成Model类的源文件（包含@JsonSerializable标注的）来生成对应的.g.dart文件。建议将所有Model类放在一个单独的目录下，然后在该目录下执行命令。 持续性生成指令 如果感觉每次更改Model时都需要执行一次性生成指令比较繁琐，这时可以使用下面的持续生成指令: flutter pub run build_runner watch 在项目根目录下运行该指令后会启动观察器, 观察器可以监视我们项目中文件的变化，并在需要时自动构建必要的文件。只需启动一次观察器，然后它就会在后台运行，这种方式也很安全。 第4步：测试并打印final jsonInfo = { &quot;nickname&quot;: &quot;coderTao&quot;, &quot;age&quot;: 20, &quot;courses&quot;: [&quot;政治&quot;, &quot;高数&quot;, &quot;英语&quot;], &quot;register_date&quot;: &quot;2018-2-22&quot;, &quot;computer&quot;: { &quot;brand&quot;: &quot;MackBook&quot;, &quot;price&quot;: 9999 } }; final user = User.fromJson(jsonInfo); print(user); 三. 网页转换app.quicktype.io 是一个将JSON转换成模型类的工具网站，目前来看支持大部分常用语言，并且灵活的可选项也非常多： 优点: 这种方式操作起来会比使用json_serializable操作起来更简便一些，并且带下划线字段会自动转换为驼峰命名的属性名。缺点: 如果数据过于复杂的话，在生成的时候可能会少了某一个类，并且不能进行父类抽取。 四. 编辑器插件目前Android Studio(或IntelliJ)有几个插件，可以将json文件转成Model类，但插件质量参差不齐，甚至还有一些沾染上了抄袭风波，故笔者在此不做优先推荐，读者有兴趣可以自行了解。 Json转Model几种方式总结: 手动序列化JSON：比较麻烦，效率低，但新手还是多做尝试和了解比较好。 json_serializable：效率高，watch很好用。 工具网站：效率高，更多功能可选。 总体推荐使用后两种，可以大大提升开发效率，不用埋头去搞一些重复的序列化工作。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Flutter] 07-Flutter中反序列化Json]]></title>
    <url>%2F2020%2F06%2F21%2FFlutter-07-Flutter%E4%B8%AD%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96Json%2F</url>
    <content type="text"><![CDATA[由于Flutter中禁用运行时反射，所以如果项目简单的话可以考虑手动JSON 反序列化，如果你的项目很复杂的话，可以考虑官方建议的 json_serializable 代码生成器库。在本文中，我们主要讨论对象反序列化，即如何将服务器端返回的字符串数据转化为对象, 其他的Json转Model方式在下章讨论。 首先先要了解什么是序列化和反序列化? 把对象转换为字节序列的过程称为对象的序列化；把字节序列恢复为对象的过程称为对象的反序列化。 接下来我们看下几种Json格式,如何反序列化的: 一 简单map1) 分析的Json数据分析要诀: 1&gt; Json中用花括号是 Map，用方括号是 List。 2&gt; 对于嵌套结构，首先创建类和构造函数，然后从底层添加工厂方法。 student.json 代码如下: { &quot;id&quot;:&quot;123456&quot;, &quot;name&quot;:&quot;codeTao&quot;, &quot;score&quot; : 99 } 该Json数据很明显是一个Map结构，可以创建一个Student类，通过factory构造方法来反序列化。 2) 与Json结构对应的Model类student_model.dart 文件代码如下: class Student{ String studentId; String studentName; int studentScores; Student({ this.studentId, this.studentName, this.studentScores }); factory Student.fromJson(Map&lt;String, dynamic&gt; parsedJson){ return Student( studentId: parsedJson[&#39;id&#39;], studentName : parsedJson[&#39;name&#39;], studentScores : parsedJson [&#39;score&#39;] ); } } 注意: fromJson 方法中的参数是一个 Map&lt;String, dynamic&gt; ，这意味着直到运行时我们才知道值的类型。 3) 请求数据并反序列化student_services.dart 中请求数据, 并解析json, 最后调用 Student.fromJson 来反序列化，从 Student 对象中获取值。代码如下: //1.import 导入相关文件 import &#39;dart:async&#39; show Future; import &#39;package:flutter/services.dart&#39; show rootBundle; import &#39;dart:convert&#39;; import &#39;package:parsing_json_demo/model/student_model.dart&#39;; // 导入模型文件 //2.加载 Json Asset Future&lt;String&gt; _loadAStudentAsset() async { return await rootBundle.loadString(&#39;assets/student.json&#39;); } //3. 加载响应数据 Future loadStudent() async { //从 assets 中加载原始 json 字符串 String jsonString = await _loadAStudentAsset(); //解析 json 字符串 final jsonResponse = json.decode(jsonString); //通过调用 Student.fromJson 方法反序列化解析的 json，以便可以使用 Student 对象来访问数据 Student student = new Student.fromJson(jsonResponse); //Student 类里打印了 studentScores print(&quot;student.studentScores= ${student.studentScores}&quot;); } 在这项目中，所有 json 文件放在 assets 文件夹下，所以我们必须这样加载 json。你也可以进行网络调用，网络调用不在这篇文章的讨论范围内。 使用Flutter内置的dart:convert库Json解码器json.decode() 来实现，该方法可以根据 Json 字符串具体内容将其转为 List 或 Map。 注意：请记住上面请求数据并反序列化的 3 个步骤(1.import 导入相关文件; 2.加载 Json Asset; 3.加载响应数据)，接下来 json 解析都会用到（只更改文件名和方法名），我不会再重复书写该代码。但你可以在示例项目中查看所有内容。 二. Map含有简单List结构1) 分析的Json数据{ &quot;city&quot;: &quot;广州&quot;, &quot;streets&quot;: [ &quot;北京路&quot;, &quot;上下九街&quot; ] } 该数据是一个含有 List&lt;String&gt;的Map 2) 与Json结构对应的Model类class Address { final String city; final List&lt;String&gt; streets; Address({ this.city, this.streets }); factory Address.fromJson(Map&lt;String, dynamic&gt; parsedJson) { var streetsFromJson = parsedJson[&#39;streets&#39;]; print(streetsFromJson.runtimeType); //List&lt;dynamic&gt; // 显式地转换成 List&lt;String&gt; // List&lt;String&gt; streetsList = new List&lt;String&gt;.from(streetsFromJson); List&lt;String&gt; streetsList = streetsFromJson.cast&lt;String&gt;(); return new Address( city: parsedJson[&#39;city&#39;], streets: streetsList, ); } } 三 Map含有简单Map嵌套结构1) 分析的Json数据{ &quot;shape_name&quot;:&quot;rectangle&quot;, &quot;property&quot;:{ &quot;width&quot;:5.0, &quot;height&quot;:10.0 } } 2) 与Json结构对应的Model类class Shape{ String shapeName; Property property; Shape({ this.shapeName, this.property }); factory Shape.fromJson(Map&lt;String, dynamic&gt; parsedJson){ return Shape( shapeName: parsedJson[&#39;shape_name&#39;], property: Property.fromJson(parsedJson[&#39;property&#39;]) ); } } class Property{ double width; double height; Property({ this.width, this.height }); factory Property.fromJson(Map&lt;String, dynamic&gt; json){ return Property( width: json[&#39;width&#39;], height: json[&#39;height&#39;] ); } } 四 Map含有对象列表的嵌套结构1) 分析的Json数据{ &quot;id&quot;:1, &quot;name&quot;:&quot;盒装牛奶&quot;, &quot;images&quot;:[ { &quot;id&quot;:11, &quot;imageName&quot;:&quot;telunsu.png&quot; }, { &quot;id&quot;:22, &quot;imageName&quot;:&quot;wahaha.png&quot; } ] } Map含有 对象列表 的嵌套结构 2) 与Json结构对应的Model类class Product { final int id; final String name; final List&lt;Image&gt; images; Product({this.id, this.name, this.images}); factory Product.fromJson(Map&lt;String, dynamic&gt; parsedJson){ var list = parsedJson[&#39;images&#39;] as List; print(list.runtimeType); //List&lt;dynamic&gt; List&lt;Image&gt; imagesList = list.map((i) =&gt; Image.fromJson(i)).toList(); //print(imagesList.runtimeType); // map操作后imagesList类型为 &#39;MappedListIterable&lt;dynamic, Image&gt; //不转化为List&lt;Image&gt;就会报错: Unhandled Exception: type &#39;MappedListIterable&lt;dynamic, Image&gt;&#39; is not a subtype of type &#39;List&lt;Image&gt;&#39; return Product( id: parsedJson[&#39;id&#39;], name: parsedJson[&#39;name&#39;], images: imagesList ); } } class Image { final int imageId; final String imageName; Image({this.imageId, this.imageName}); factory Image.fromJson(Map&lt;String, dynamic&gt; parsedJson){ return Image( imageId:parsedJson[&#39;id&#39;], imageName:parsedJson[&#39;imageName&#39;] ); } } 其中 List&lt;Image&gt; imagesList = list.map((i) =&gt; Image.fromJson(i)).toList();list 在这里是一个 List。现在我们通过调用 Image.fromJson 遍历整个列表，并把 list 中的每个对象映射到 Image 中，然后我们将每个 map 对象放入一个带有 toList() 的新列表中，并将它存储在 List imagesList。 五 map列表1) 分析的Json数据[ { &quot;albumId&quot;: 1, &quot;id&quot;: 1, &quot;title&quot;: &quot;美丽的小径&quot;, &quot;url&quot;: &quot;http://b.zol-img.com.cn/sjbizhi/images/11/640x1136/1592364145769.jpg&quot;, &quot;thumbnailUrl&quot;: &quot;http://b.zol-img.com.cn/sjbizhi/images/11/480x800/1592364145769.jpg&quot; }, { &quot;albumId&quot;: 1, &quot;id&quot;: 2, &quot;title&quot;: &quot;小朋友说，别笑，我在办公呢？&quot;, &quot;url&quot;: &quot;http://b.zol-img.com.cn/sjbizhi/images/11/640x1136/1592366115586.jpg&quot;, &quot;thumbnailUrl&quot;: &quot;http://b.zol-img.com.cn/sjbizhi/images/11/480x800/1592366115586.jpg&quot; }, { &quot;albumId&quot;: 1, &quot;id&quot;: 3, &quot;title&quot;: &quot;豪华跑车&quot;, &quot;url&quot;: &quot;http://sjbz.fd.zol-img.com.cn/t_s640x1136c/g3/M08/0E/0B/ChMlWF7oPRuIcWdWABs0s8RzN5wAAU0PwJXf0sAGzTL604.jpg&quot;, &quot;thumbnailUrl&quot;: &quot;http://sjbz.fd.zol-img.com.cn/t_s480x800c/g3/M08/0E/0B/ChMlWF7oPRuIcWdWABs0s8RzN5wAAU0PwJXf0sAGzTL604.jpg&quot; } ] 2) 与Json结构对应的Model类class PhotosList { final List&lt;Photo&gt; photos; PhotosList({ this.photos, }); factory PhotosList.fromJson(List&lt;dynamic&gt; parsedJson) { List&lt;Photo&gt; photos = new List&lt;Photo&gt;(); photos = parsedJson.map((i)=&gt;Photo.fromJson(i)).toList(); return new PhotosList( photos: photos ); } } class Photo{ final String id; final String title; final String url; Photo({ this.id, this.url, this.title }) ; factory Photo.fromJson(Map&lt;String, dynamic&gt; json){ return new Photo( id: json[&#39;id&#39;].toString(), title: json[&#39;title&#39;], url: json[&#39;json&#39;], ); } } 六 复杂的嵌套结构1) 分析的Json数据{ &quot;page&quot;: 1, &quot;per_page&quot;: 3, &quot;total&quot;: 12, &quot;total_pages&quot;: 4, &quot;author&quot;:{ &quot;name&quot;: &quot;CodeTao&quot; }, &quot;data&quot;: [ { &quot;id&quot;: 1, &quot;name&quot;: &quot;Harry&quot;, &quot;avatar&quot;: &quot;https://upload-images.jianshu.io/upload_images/126164-be76091e050f0605.png&quot;, &quot;images&quot;: [ { &quot;id&quot; : 22, &quot;imageName&quot;: &quot;aaa.jpeg&quot; }, { &quot;id&quot; : 23, &quot;imageName&quot;: &quot;bbb.jpeg&quot; } ] }, { &quot;id&quot;: 2, &quot;name&quot;: &quot;Jame&quot;, &quot;avatar&quot;: &quot;https://upload-images.jianshu.io/upload_images/126164-be76091e050f0605.png&quot;, &quot;images&quot;: [ { &quot;id&quot; : 33, &quot;imageName&quot;: &quot;ccc.jpeg&quot; }, { &quot;id&quot; : 34, &quot;imageName&quot;: &quot;ddd.jpeg&quot; } ] }, { &quot;id&quot;: 3, &quot;name&quot;: &quot;Henry&quot;, &quot;avatar&quot;: &quot;https://upload-images.jianshu.io/upload_images/126164-be76091e050f0605.png&quot;, &quot;images&quot;: [ { &quot;id&quot; : 44, &quot;imageName&quot;: &quot;eee.jpeg&quot; }, { &quot;id&quot; : 45, &quot;imageName&quot;: &quot;fff.jpeg&quot; } ] } ] } 2) 与Json结构对应的Model类class Page{ int page; int perPage; int total; int totalPages; Author author; List&lt;Data&gt; data; Page({ this.page, this.perPage, this.total, this.totalPages, this.author, this.data}); factory Page.fromJson(Map&lt;String, dynamic&gt; parsedJson){ var list = parsedJson[&#39;data&#39;] as List; List&lt;Data&gt; data = list.map((i) =&gt; Data.fromJson(i)).toList(); return Page( page: parsedJson[&#39;page&#39;], perPage: parsedJson[&#39;per_page&#39;], total: parsedJson[&#39;total&#39;], totalPages: parsedJson[&#39;total_pages&#39;], author: Author.fromJson(parsedJson[&#39;author&#39;]), data: data ); } } class Author{ String name; Author({this.name}); factory Author.fromJson(Map&lt;String, dynamic&gt; parsedJson){ return Author( name: parsedJson[&#39;name&#39;], ); } } class Data{ int id; String name; // add others List&lt;Image&gt; imagesList; Data({ this.id, this.name, this.imagesList }); factory Data.fromJson(Map&lt;String, dynamic&gt; parsedJson){ var list = parsedJson[&#39;images&#39;] as List; List&lt;Image&gt; images = list.map((i) =&gt; Image.fromJson(i)).toList(); return Data( id: parsedJson[&#39;id&#39;], name: parsedJson[&#39;name&#39;], imagesList: images ); } } class Image{ int id; String imageName; Image({ this.id, this.imageName }); factory Image.fromJson(Map&lt;String, dynamic&gt; parsedJson){ return Image( id: parsedJson[&#39;id&#39;], imageName : parsedJson[&#39;imageName&#39;], ); } } 七 手动Json转Model优缺点: 优点：完全是自己可控的，并且需要哪些字段就转化哪些字段，对于不需要的，忽略即可；并且继承关系也会一目了然 缺点：麻烦，并且容易出错 所以如果数据嵌套层级多的话，建议使用dart官方推荐json_serializable方式进行Json转Model ，进一步了解查看下一篇 [Flutter] 08-Flutter中的Json转Model。 由于笔者水平有限，文中如果有错误的地方，或者有更好的方法，还望大神指出。附上本文的所有 demo 下载链接，【GitHub】。如果你看完后觉得对你有所帮助，还望在 GitHub 上点个 star。赠人玫瑰，手有余香。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Flutter] 06-Flutter的网络请求]]></title>
    <url>%2F2020%2F06%2F20%2FFlutter-06-Flutter%E7%9A%84%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[我们项目中展示的大部分数据都是来自服务器，我们需要向服务器请求数据，并且对他们进行解析展示。向服务器发出请求就需要用到网络请求相关的知识。 一. 网络请求的方式 在Flutter中常见的网络请求方式有三种：HttpClient、http库、dio库； 1.1. HttpClientHttpClient是dart自带的请求类，在io包中，实现了基本的网络请求相关的操作。需要导入httpClient包，import ‘dart:convert’; 和 import ‘dart:io’ ; 网络调用通常遵循如下步骤： 创建 client. 构造 Uri. 发起请求, 等待请求，同时您也可以配置请求headers、 body。 关闭请求, 等待响应. 解码响应的内容. 网络请求实例： import &#39;dart:convert&#39;; import &#39;dart:io&#39;; main(List&lt;String&gt; args) { requestNetwork(); } void requestNetwork() async { // 1.创建HttpClient对象 final httpClient = HttpClient(); // 2.构建请求的uri final uri = Uri.parse(&quot;http://123.207.32.32:8000/api/v1/recommend&quot;); // 3.构建请求 final request = await httpClient.getUrl(uri); // 4.发送请求，必须 final response = await request.close(); if (response.statusCode == HttpStatus.ok) { print(await response.transform(utf8.decoder).join()); } else { print(response.statusCode); } } OK，其实HttpClient也可以发送post相关的请求，我们这里就不再演练。 HttpClient虽然可以发送正常的网络请求，但是会暴露过多的细节： 比如需要主动关闭request请求，拿到数据后也需要手动的进行字符串解码 在开发中，我们一般很少直接面向HttpClient进行网络请求，而是使用一些库来完成。 1.2. http库http 是 Dart 官方提供的另一个网络请求类，相比于 HttpClient，易用性提升了不少。 但是，没有默认集成到Dart的SDK中，所以我们需要先在pubspec中依赖它： http: ^0.12.0+2 导入并且使用即可 import &#39;package:http/http.dart&#39; as http; void httpNetwork() async { // 1.创建Client final client = http.Client(); // 2.构建uri final url = Uri.parse(&quot;http://123.207.32.32:8000/api/v1/recommend&quot;); // 3.发送请求 final response = await client.get(url); // 4.获取结果 if (response.statusCode == HttpStatus.ok) { print(response.body); } else { print(response.statusCode); } } 1.3. dio三方库官方提供的HttpClient和http都可以正常的发送网络请求，但是对于现代的应用程序开发来说，我们通常要求的东西会更多：比如拦截器、取消请求、文件上传/下载、超时设置等等； 这个时候，我们可以使用一个在Flutter中非常流行的三方库：dio； 官网有对dio进行解释： dio是一个强大的Dart Http请求库，支持Restful API、FormData、拦截器、请求取消、Cookie管理、文件上传/下载、超时、自定义适配器等… 使用dio三方库必然也需要先在pubspec中依赖它： dio: ^3.0.1 代码演练： import &#39;package:dio/dio.dart&#39;; void dioNetwork() async { // 1.创建Dio请求对象 final dio = Dio(); // 2.发送网络请求 final response = await dio.get(&quot;&quot;); // 3.打印请求结果 if (response.statusCode == HttpStatus.ok) { print(response.data); } else { print(&quot;请求失败：${response.statusCode}&quot;); } } 1.4. dio库的封装http_config.dart class HTTPConfig { static const baseURL = &quot;https://httpbin.org&quot;; static const timeout = 5000; } http_request.dart import &#39;package:dio/dio.dart&#39;; import &#39;package:testflutter001/service/config.dart&#39;; class HttpRequest { static final BaseOptions options = BaseOptions( baseUrl: HTTPConfig.baseURL, connectTimeout: HTTPConfig.timeout); static final Dio dio = Dio(options); static Future&lt;T&gt; request&lt;T&gt;(String url, {String method = &#39;get&#39;, Map&lt;String, dynamic&gt; params, Interceptor inter}) async { // 1.请求的单独配置 final options = Options(method: method); // 2.添加第一个拦截器 Interceptor dInter = InterceptorsWrapper( onRequest: (RequestOptions options) { // 1.在进行任何网络请求的时候, 可以添加一个loading显示 // 2.很多页面的访问必须要求携带Token,那么就可以在这里判断是有Token // 3.对参数进行一些处理,比如序列化处理等 print(&quot;拦截了请求&quot;); return options; }, onResponse: (Response response) { print(&quot;拦截了响应&quot;); return response; }, onError: (DioError error) { print(&quot;拦截了错误&quot;); return error; } ); List&lt;Interceptor&gt; inters = [dInter]; if (inter != null) { inters.add(inter); } dio.interceptors.addAll(inters); // 3.发送网络请求 try { Response response = await dio.request&lt;T&gt;(url, queryParameters: params, options: options); return response.data; } on DioError catch(e) { return Future.error(e); } } } 代码使用： HttpRequest.request(&quot;https://httpbin.org/get&quot;, params: {&quot;name&quot;: &quot;tao&quot;, &#39;age&#39;: 18}).then((res) { print(res); }); HttpRequest.request(&quot;https://httpbin.org/post&quot;, method: &quot;post&quot;, params: {&quot;name&quot;: &quot;tao&quot;, &#39;age&#39;: 18}).then((res) { print(res); });]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Flutter] 05-Dart中异步]]></title>
    <url>%2F2020%2F06%2F19%2FFlutter-05-Dart%E4%B8%AD%E5%BC%82%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[一. Dart的异步模型 我们先来看一下Dart是如何进行异步操作的 1.1. Dart是单线程的1.1.1. 程序中的耗时操作开发中的耗时操作： 在开发中，我们经常会遇到一些耗时的操作需要完成，比如网络请求、文件读取等等； 如果我们的主线程一直在等待这些耗时的操作完成，那么就会进行阻塞，无法响应其它事件，比如用户的点击； 如何处理耗时的操作呢？ 针对如何处理耗时的操作，不同的语言有不同的处理方式。 处理方式一： 多线程，比如Java、C++，我们普遍的做法是开启一个新的线程（Thread），在新的线程中完成这些异步的操作，再通过线程间通信的方式，将拿到的数据传递给主线程。 处理方式二： 单线程+事件循环，比如JavaScript、Dart都是基于单线程加事件循环来完成耗时操作的处理。不过单线程如何能进行耗时的操作呢？！ 1.1.2. 单线程的异步操作很多开发者可能都对单线程的异步操作充满了问号？？？ 其实它们并不冲突： 因为我们的一个应用程序大部分时间都是处于空闲的状态的，并不是无限制的在和用户进行交互。 比如等待用户点击、网络请求数据的返回、文件读写的IO操作，这些等待的行为并不会阻塞我们的线程； 这是因为类似于网络请求、文件读写的IO，我们都可以基于非阻塞调用； 阻塞式调用和非阻塞式调用 如果想搞懂这个点，我们需要知道操作系统中的阻塞式调用和非阻塞式调用的概念。 阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态。 阻塞式调用： 调用结果返回之前，当前线程会被挂起，调用线程只有在得到调用结果之后才会继续执行。 非阻塞式调用： 调用执行之后，当前线程不会停止执行，只需要过一段时间来检查一下有没有结果返回即可。 我们用一个生活中的例子来模拟： 你中午饿了，需要点一份外卖，点外卖的动作就是我们的调用，拿到最后点的外卖就是我们要等待的结果。 阻塞式调用： 点了外卖，不再做任何事情，就是在傻傻的等待，你的线程停止了任何其他的工作。 非阻塞式调用： 点了外卖，继续做其他事情：继续工作、打把游戏，你的线程没有继续执行其他事情，只需要偶尔去看一下有没有人敲门，外卖有没有送到即可。 而我们开发中的很多耗时操作，都可以基于这样的 非阻塞式调用： 比如网络请求本身使用了Socket通信，而Socket本身提供了select模型，可以进行非阻塞方式的工作； 比如文件读写的IO操作，我们可以使用操作系统提供的基于事件的回调机制； 这些操作都不会阻塞我们单线程的继续执行，我们的线程在等待的过程中可以继续去做别的事情：喝杯咖啡、打把游戏，等真正有了响应，再去进行对应的处理即可。 这时，我们可能有两个问题： 问题一： 如果在多核CPU中，单线程是不是就没有充分利用CPU呢？这个问题，我会放在后面来讲解。 问题二： 单线程是如何来处理网络通信、IO操作它们返回的结果呢？答案就是事件循环（Event Loop）。 1.2. Dart事件循环1.2.1. 什么是事件循环单线程模型中主要就是在维护着一个事件循环（Event Loop）。 事件循环是什么呢？ 事实上事件循环并不复杂，它就是将需要处理的一系列事件（包括点击事件、IO事件、网络事件）放在一个事件队列（Event Queue）中。 不断的从事件队列（Event Queue）中取出事件，并执行其对应需要执行的代码块，直到事件队列清空位置。 我们来写一个事件循环的伪代码： // 这里我使用数组模拟队列, 先进先出的原则 List eventQueue = []; var event; // 事件循环从启动的一刻，永远在执行 while (true) { if (eventQueue.length &gt; 0) { // 取出一个事件 event = eventQueue.removeAt(0); // 执行该事件 event(); } } 当我们有一些事件时，比如点击事件、IO事件、网络事件时，它们就会被加入到eventLoop中，当发现事件队列不为空时发现，就会取出事件，并且执行。 1.2.2. 事件循环代码模拟这里我们来看一段伪代码，理解点击事件和网络请求的事件是如何被执行的： 这是一段Flutter代码，很多东西大家可能不是特别理解，但是耐心阅读你会读懂我们在做什么。 一个按钮RaisedButton，当发生点击时执行onPressed函数。 onPressed函数中，我们发送了一个网络请求，请求成功后会执行then中的回调函数。 RaisedButton( child: Text(&#39;Click me&#39;), onPressed: () { final myFuture = http.get(&#39;https://example.com&#39;); myFuture.then((response) { if (response.statusCode == 200) { print(&#39;Success!&#39;); } }); }, ) 这些代码是如何放在事件循环中执行呢？ 1、当用户发生点击的时候，onPressed回调函数被放入事件循环中执行，执行的过程中发送了一个网络请求。 2、网络请求发出去后，该事件循环不会被阻塞，而是发现要执行的onPressed函数已经结束，会将它丢弃掉。 3、网络请求成功后，会执行then中传入的回调函数，这也是一个事件，该事件被放入到事件循环中执行，执行完毕后，事件循环将其丢弃。 尽管onPressed和then中的回调有一些差异，但是它们对于事件循环来说，都是告诉它：我有一段代码需要执行，快点帮我完成。 二. Dart的异步操作 Dart中的异步操作主要使用Future以及async、await。 如果你之前有过前端的ES6、ES7编程经验，那么完全可以将Future理解成Promise，async、await和ES7中基本一致。 但是如果没有前端开发经验，Future以及async、await如何理解呢？ 2.1. 认识Future2.1.1. 同步的网络请求我们先来看一个例子吧： 在这个例子中，我使用getNetworkData来模拟了一个网络请求； 该网络请求需要3秒钟的时间，之后返回数据； import &quot;dart:io&quot;; main(List&lt;String&gt; args) { print(&quot;main function start&quot;); print(getNetworkData()); print(&quot;main function end&quot;); } String getNetworkData() { sleep(Duration(seconds: 3)); return &quot;network data&quot;; } 这段代码会运行怎么的结果呢？ getNetworkData会阻塞main函数的执行 main function start // 等待3秒 network data main function end 显然，上面的代码不是我们想要的执行效果，因为网络请求阻塞了main函数，那么意味着其后所有的代码都无法正常的继续执行。 2.1.2. 异步的网络请求我们来对我们上面的代码进行改进，代码如下： 和刚才的代码唯一的区别在于我使用了Future对象来将耗时的操作放在了其中传入的函数中； 稍后，我们会讲解它具体的一些API，我们就暂时知道我创建了一个Future实例即可； import &quot;dart:io&quot;; main(List&lt;String&gt; args) { print(&quot;main function start&quot;); print(getNetworkData()); print(&quot;main function end&quot;); } Future&lt;String&gt; getNetworkData() { return Future&lt;String&gt;(() { sleep(Duration(seconds: 3)); return &quot;network data&quot;; }); } 我们来看一下代码的运行结果： 1、这一次的代码顺序执行，没有出现任何的阻塞现象； 2、和之前直接打印结果不同，这次我们打印了一个Future实例； 结论：我们将一个耗时的操作隔离了起来，这个操作不会再影响我们的主线程执行了。 问题：我们如何去拿到最终的结果呢？ main function start Instance of &#39;Future&lt;String&gt;&#39; main function end 获取Future得到的结果 有了Future之后，如何去获取请求到的结果：通过.then的回调： main(List&lt;String&gt; args) { print(&quot;main function start&quot;); // 使用变量接收getNetworkData返回的future var future = getNetworkData(); // 当future实例有返回结果时，会自动回调then中传入的函数 // 该函数会被放入到事件循环中，被执行 future.then((value) { print(value); }); print(future); print(&quot;main function end&quot;); } 上面代码的执行结果： main function start Instance of &#39;Future&lt;String&gt;&#39; main function end // 3s后执行下面的代码 network data 执行中出现异常 如果调用过程中出现了异常，拿不到结果，如何获取到异常的信息呢？ import &quot;dart:io&quot;; main(List&lt;String&gt; args) { print(&quot;main function start&quot;); var future = getNetworkData(); future.then((value) { print(value); }).catchError((error) { // 捕获出现异常时的情况 print(error); }); print(future); print(&quot;main function end&quot;); } Future&lt;String&gt; getNetworkData() { return Future&lt;String&gt;(() { sleep(Duration(seconds: 3)); // 不再返回结果，而是出现异常 // return &quot;network data&quot;; throw Exception(&quot;网络请求出现错误&quot;); }); } 上面代码的执行结果： main function start Instance of &#39;Future&lt;String&gt;&#39; main function end // 3s后没有拿到结果，但是我们捕获到了异常 Exception: 网络请求出现错误 2.1.3. Future使用补充补充一：上面案例的小结 我们通过一个案例来学习了一些Future的使用过程： 1、创建一个Future（可能是我们创建的，也可能是调用内部API或者第三方API获取到的一个Future，总之你需要获取到一个Future实例，Future通常会对一些异步的操作进行封装）； 2、通过.then(成功回调函数)的方式来监听Future内部执行完成时获取到的结果； 3、通过.catchError(失败或异常回调函数)的方式来监听Future内部执行失败或者出现异常时的错误信息； 补充二：Future的两种状态 事实上Future在执行的整个过程中，我们通常把它划分成了两种状态： 状态一：未完成状态（uncompleted） 执行Future内部的操作时（在上面的案例中就是具体的网络请求过程，我们使用了延迟来模拟），我们称这个过程为未完成状态 状态二：完成状态（completed） 当Future内部的操作执行完成，通常会返回一个值，或者抛出一个异常。 这两种情况，我们都称Future为完成状态。 Dart官网有对这两种状态解析，之所以贴出来是区别于Promise的三种状态 补充三：Future的链式调用 上面代码我们可以进行如下的改进： 我们可以在then中继续返回值，会在下一个链式的then调用回调函数中拿到返回的结果 import &quot;dart:io&quot;; main(List&lt;String&gt; args) { print(&quot;main function start&quot;); getNetworkData().then((value1) { print(value1); return &quot;content data2&quot;; }).then((value2) { print(value2); return &quot;message data3&quot;; }).then((value3) { print(value3); }); print(&quot;main function end&quot;); } Future&lt;String&gt; getNetworkData() { return Future&lt;String&gt;(() { sleep(Duration(seconds: 3)); // 不再返回结果，而是出现异常 return &quot;network data1&quot;; }); } 打印结果如下： main function start main function end // 3s后拿到结果 network data1 content data2 message data3 补充四：Future其他API Future.value(value) 直接获取一个完成的Future，该Future会直接调用then的回调函数 main(List&lt;String&gt; args) { print(&quot;main function start&quot;); Future.value(&quot;哈哈哈&quot;).then((value) { print(value); }); print(&quot;main function end&quot;); } 打印结果如下： main function start main function end 哈哈哈 疑惑：为什么立即执行，但是哈哈哈是在最后打印的呢？ 这是因为Future中的then会作为新的任务会加入到事件队列中（Event Queue），加入之后你肯定需要排队执行了 Future.error(object) 直接获取一个完成的Future，但是是一个发生异常的Future，该Future会直接调用catchError的回调函数 main(List&lt;String&gt; args) { print(&quot;main function start&quot;); Future.error(Exception(&quot;错误信息&quot;)).catchError((error) { print(error); }); print(&quot;main function end&quot;); } 打印结果如下： main function start main function end Exception: 错误信息 Future.delayed(时间, 回调函数) 在延迟一定时间时执行回调函数，执行完回调函数后会执行then的回调； 之前的案例，我们也可以使用它来模拟，但是直接学习这个API会让大家更加疑惑； main(List&lt;String&gt; args) { print(&quot;main function start&quot;); Future.delayed(Duration(seconds: 3), () { return &quot;3秒后的信息&quot;; }).then((value) { print(value); }); print(&quot;main function end&quot;); } 2.2. await、async2.2.1. 理论概念理解如果你已经完全搞懂了Future，那么学习await、async应该没有什么难度。 await、async是什么呢？ 它们是Dart中的关键字 它们可以让我们用同步的代码格式，去实现异步的调用过程。 并且，通常一个async的函数会返回一个Future。 我们已经知道，Future可以做到不阻塞我们的线程，让线程继续执行，并且在完成某个操作时改变自己的状态，并且回调then或者errorCatch回调。 如何生成一个Future呢？ 1、通过我们前面学习的Future构造函数，或者后面学习的Future其他API都可以。 2、还有一种就是通过async的函数。 2.2.2. 案例代码演练我们来对之前的Future异步处理代码进行改造，改成await、async的形式。 我们知道，如果直接这样写代码，代码是不能正常执行的： 因为Future.delayed返回的是一个Future对象，我们不能把它看成同步的返回数据：&quot;network data&quot;去使用 也就是我们不能把这个异步的代码当做同步一样去使用！ import &quot;dart:io&quot;; main(List&lt;String&gt; args) { print(&quot;main function start&quot;); print(getNetworkData()); print(&quot;main function end&quot;); } String getNetworkData() { var result = Future.delayed(Duration(seconds: 3), () { return &quot;network data&quot;; }); return &quot;请求到的数据：&quot; + result; } 现在我使用await修改下面这句代码： 你会发现，我在Future.delayed函数前加了一个await。 一旦有了这个关键字，那么这个操作就会等待Future.delayed的执行完毕，并且等待它的结果。 String getNetworkData() { var result = await Future.delayed(Duration(seconds: 3), () { return &quot;network data&quot;; }); return &quot;请求到的数据：&quot; + result; } 修改后执行代码，会看到如下的错误： 错误非常明显：await关键字必须存在于async函数中。 所以我们需要将getNetworkData函数定义成async函数。 继续修改代码如下： 也非常简单，只需要在函数的()后面加上一个async关键字就可以了 String getNetworkData() async { var result = await Future.delayed(Duration(seconds: 3), () { return &quot;network data&quot;; }); return &quot;请求到的数据：&quot; + result; } 运行代码，依然报错： 错误非常明显：使用async标记的函数，必须返回一个Future对象。 所以我们需要继续修改代码，将返回值写成一个Future。 继续修改代码如下： Future&lt;String&gt; getNetworkData() async { var result = await Future.delayed(Duration(seconds: 3), () { return &quot;network data&quot;; }); return &quot;请求到的数据：&quot; + result; } 这段代码应该是我们理想当中执行的代码了 我们现在可以像同步代码一样去使用Future异步返回的结果； 等待拿到结果之后和其他数据进行拼接，然后一起返回； 返回的时候并不需要包装一个Future，直接返回即可，但是返回值会默认被包装在一个Future中； 2.3. 读取json案例 我这里给出了一个在Flutter项目中，读取一个本地的json文件，并且转换成模型对象，返回出去的案例； 这个案例作为大家学习前面Future和await、async的一个参考，我并不打算展开来讲，因为需要用到Flutter的相关知识； 后面我会在后面的案例中再次讲解它在Flutter中我使用的过程中； 读取json案例代码（了解一下即可） import &#39;package:flutter/services.dart&#39; show rootBundle; import &#39;dart:convert&#39;; import &#39;dart:async&#39;; main(List&lt;String&gt; args) { getAnchors().then((anchors) { print(anchors); }); } class Anchor { String nickname; String roomName; String imageUrl; Anchor({ this.nickname, this.roomName, this.imageUrl }); Anchor.withMap(Map&lt;String, dynamic&gt; parsedMap) { this.nickname = parsedMap[&quot;nickname&quot;]; this.roomName = parsedMap[&quot;roomName&quot;]; this.imageUrl = parsedMap[&quot;roomSrc&quot;]; } } Future&lt;List&lt;Anchor&gt;&gt; getAnchors() async { // 1.读取json文件 String jsonString = await rootBundle.loadString(&quot;assets/yz.json&quot;); // 2.转成List或Map类型 final jsonResult = json.decode(jsonString); // 3.遍历List，并且转成Anchor对象放到另一个List中 List&lt;Anchor&gt; anchors = new List(); for (Map&lt;String, dynamic&gt; map in jsonResult) { anchors.add(Anchor.withMap(map)); } return anchors; } 三. Dart的异步补充3.1. 任务执行顺序3.1.1. 认识微任务队列在前面学习学习中，我们知道Dart中有一个事件循环（Event Loop）来执行我们的代码，里面存在一个事件队列（Event Queue），事件循环不断从事件队列中取出事件执行。 但是如果我们严格来划分的话，在Dart中还存在另一个队列：微任务队列（Microtask Queue）。 微任务队列的优先级要高于事件队列； 也就是说事件循环都是优先执行微任务队列中的任务，再执行 事件队列 中的任务； 那么在Flutter开发中，哪些是放在事件队列，哪些是放在微任务队列呢？ 所有的外部事件任务都在事件队列中，如IO、计时器、点击、以及绘制事件等； 而微任务通常来源于Dart内部，并且微任务非常少。这是因为如果微任务非常多，就会造成事件队列排不上队，会阻塞任务队列的执行（比如用户点击没有反应的情况）； 说道这里，你可能已经有点凌乱了，在Dart的单线程中，代码到底是怎样执行的呢？ 1、Dart的入口是main函数，所以main函数中的代码会优先执行； 2、main函数执行完后，会启动一个事件循环（Event Loop）就会启动，启动后开始执行队列中的任务； 3、首先，会按照先进先出的顺序，执行 微任务队列（Microtask Queue）中的所有任务； 4、其次，会按照先进先出的顺序，执行 事件队列（Event Queue）中的所有任务； 3.1.2. 如何创建微任务在开发中，我们可以通过dart中async下的scheduleMicrotask来创建一个微任务： import &quot;dart:async&quot;; main(List&lt;String&gt; args) { scheduleMicrotask(() { print(&quot;Hello Microtask&quot;); }); } 在开发中，如果我们有一个任务不希望它放在Event Queue中依次排队，那么就可以创建一个微任务了。 Future的代码是加入到事件队列还是微任务队列呢？ Future中通常有两个函数执行体： Future构造函数传入的函数体 then的函数体（catchError等同看待） 那么它们是加入到什么队列中的呢？ Future构造函数传入的函数体放在事件队列中 then的函数体要分成三种情况： 情况一：Future没有执行完成（有任务需要执行），那么then会直接被添加到Future的函数执行体后； 情况二：如果Future执行完后就then，该then的函数体被放到如微任务队列，当前Future执行完后执行微任务队列； 情况三：如果Future世链式调用，意味着then未执行完，下一个then不会执行； // future_1加入到eventqueue中，紧随其后then_1被加入到eventqueue中 Future(() =&gt; print(&quot;future_1&quot;)).then((_) =&gt; print(&quot;then_1&quot;)); // Future没有函数执行体，then_2被加入到microtaskqueue中 Future(() =&gt; null).then((_) =&gt; print(&quot;then_2&quot;)); // future_3、then_3_a、then_3_b依次加入到eventqueue中 Future(() =&gt; print(&quot;future_3&quot;)).then((_) =&gt; print(&quot;then_3_a&quot;)).then((_) =&gt; print(&quot;then_3_b&quot;)); 3.1.3. 代码执行顺序我们根据前面的规则来学习一个极的代码执行顺序案例： import &quot;dart:async&quot;; main(List&lt;String&gt; args) { print(&quot;main start&quot;); Future(() =&gt; print(&quot;task1&quot;)); final future = Future(() =&gt; null); Future(() =&gt; print(&quot;task2&quot;)).then((_) { print(&quot;task3&quot;); scheduleMicrotask(() =&gt; print(&#39;task4&#39;)); }).then((_) =&gt; print(&quot;task5&quot;)); future.then((_) =&gt; print(&quot;task6&quot;)); scheduleMicrotask(() =&gt; print(&#39;task7&#39;)); Future(() =&gt; print(&#39;task8&#39;)) .then((_) =&gt; Future(() =&gt; print(&#39;task9&#39;))) .then((_) =&gt; print(&#39;task10&#39;)); print(&quot;main end&quot;); } 代码执行的结果是： main start main end task7 task1 task6 task2 task3 task5 task4 task8 task9 task10 代码分析： 1、main函数先执行，所以main start和main end先执行，没有任何问题； 2、main函数执行过程中，会将一些任务分别加入到EventQueue和MicrotaskQueue中； 3、task7通过scheduleMicrotask函数调用，所以它被最早加入到MicrotaskQueue，会被先执行； 4、然后开始执行EventQueue，task1被添加到EventQueue中被执行； 5、通过final future = Future(() =&gt; null);创建的future的then被添加到微任务中，微任务直接被优先执行，所以会执行task6； 6、一次在EventQueue中添加task2、task3、task5被执行； 7、task3的打印执行完后，调用scheduleMicrotask，那么在执行完这次的EventQueue后会执行，所以在task5后执行task4（注意：scheduleMicrotask的调用是作为task3的一部分代码，所以task4是要在task5之后执行的） 8、task8、task9、task10一次添加到EventQueue被执行； 事实上，上面的代码执行顺序有可能出现在面试中，我们开发中通常不会出现这种复杂的嵌套，并且需要完全搞清楚它的执行顺序； 但是，了解上面的代码执行顺序，会让你对EventQueue和microtaskQueue有更加深刻的理解。 3.2. 多核CPU的利用3.2.1. Isolate的理解在Dart中，有一个Isolate的概念，它是什么呢？ 我们已经知道Dart是单线程的，这个线程有自己可以访问的内存空间以及需要运行的事件循环； 我们可以将这个空间系统称之为是一个Isolate； 比如Flutter中就有一个Root Isolate，负责运行Flutter的代码，比如UI渲染、用户交互等等； 在 Isolate 中，资源隔离做得非常好，每个 Isolate 都有自己的 Event Loop 与 Queue， Isolate 之间不共享任何资源，只能依靠消息机制通信，因此也就没有资源抢占问题。 但是，如果只有一个Isolate，那么意味着我们只能永远利用一个线程，这对于多核CPU来说，是一种资源的浪费。 如果在开发中，我们有非常多耗时的计算，完全可以自己创建Isolate，在独立的Isolate中完成想要的计算操作。 如何创建Isolate呢？ 创建Isolate是比较简单的，我们通过Isolate.spawn就可以创建了： import &quot;dart:isolate&quot;; main(List&lt;String&gt; args) { Isolate.spawn(foo, &quot;Hello Isolate&quot;); } void foo(info) { print(&quot;新的isolate：$info&quot;); } 3.2.2. Isolate通信机制但是在真实开发中，我们不会只是简单的开启一个新的Isolate，而不关心它的运行结果： 我们需要新的Isolate进行计算，并且将计算结果告知Main Isolate（也就是默认开启的Isolate）； Isolate 通过发送管道（SendPort）实现消息通信机制； 我们可以在启动并发Isolate时将Main Isolate的发送管道作为参数传递给它； 并发在执行完毕时，可以利用这个管道给Main Isolate发送消息； import &quot;dart:isolate&quot;; main(List&lt;String&gt; args) async { // 1.创建管道 ReceivePort receivePort= ReceivePort(); // 2.创建新的Isolate Isolate isolate = await Isolate.spawn&lt;SendPort&gt;(foo, receivePort.sendPort); // 3.监听管道消息 receivePort.listen((data) { print(&#39;Data：$data&#39;); // 不再使用时，我们会关闭管道 receivePort.close(); // 需要将isolate杀死 isolate?.kill(priority: Isolate.immediate); }); } void foo(SendPort sendPort) { sendPort.send(&quot;Hello World&quot;); } 但是我们上面的通信变成了单向通信，如果需要双向通信呢？ 事实上双向通信的代码会比较麻烦； Flutter提供了支持并发计算的compute函数，它内部封装了Isolate的创建和双向通信； 利用它我们可以充分利用多核心CPU，并且使用起来也非常简单； 注意：下面的代码不是dart的API，而是Flutter的API，所以只有在Flutter项目中才能运行 main(List&lt;String&gt; args) async { int result = await compute(powerNum, 5); print(result); } int powerNum(int num) { return num * num; }]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Flutter] 04-Dart语法二]]></title>
    <url>%2F2020%2F06%2F18%2FFlutter-04-Dart%E8%AF%AD%E6%B3%95%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[一. 运算符1.1. 除法、整除、取模运算我们来看一下除法、整除、取模运算 var num = 7; print(num / 3); // 除法操作, 结果2.3333.. print(num ~/ 3); // 整除操作, 结果2; print(num % 3); // 取模操作, 结果1; 1.2. ??=赋值操作dart有一个很多语言都不具备的赋值运算符： 当变量为null时，使用后面的内容进行赋值。 当变量有值时，使用自己原来的值。 main(List&lt;String&gt; args) { var name1 = &#39;coderTao&#39;; print(name1); // var name2 = &#39;kobe&#39;; var name2 = null; name2 ??= &#39;james&#39;; print(name2); // 当name2初始化为kobe时，结果为kobe，当初始化为null时，赋值了james } 1.3. 条件运算符：Dart中包含一直比较特殊的条件运算符：expr1 ?? expr2 如果expr1是null，则返回expr2的结果; 如果expr1不是null，直接使用expr1的结果。 var temp = &#39;tao&#39;; var temp = null; var name = temp ?? &#39;kobe&#39;; print(name); 1.4. 级联语法：.. 某些时候，我们希望对一个对象进行连续的操作，这个时候可以使用级联语法 class Person { String name; void run() { print(&quot;${name} is running&quot;); } void eat() { print(&quot;${name} is eating&quot;); } void swim() { print(&quot;${name} is swimming&quot;); } } main(List&lt;String&gt; args) { final p1 = Person(); p1.name = &#39;tao&#39;; p1.run(); p1.eat(); p1.swim(); final p2 = Person() ..name = &quot;tao&quot; ..run() ..eat() ..swim(); } 二. 流程控制 和大部分语言的特性比较相似，这里就不再详细赘述，看一下即可。 2.1. if和else和其他语言用法一样 这里有一个注意点：不支持非空即真或者非0即真，必须有明确的bool类型 我们来看下面name为null的判断 main(List&lt;String&gt; args) { var name = null; if (name) { print(name); } } 错误: Unhandled exception: Failed assertion: boolean expression must not be null 2.2. 循环操作基本的for循环 for (var i = 0; i &lt; 5; i++) { print(i); } for in遍历List和Set类型 var names = [&#39;tao&#39;, &#39;kobe&#39;, &#39;curry&#39;]; for (var name in names) { print(name); } while和do-while和其他语言一致 break和continue用法也是一致 2.3. switch-case普通的switch使用 注意：每一个case语句，默认情况下必须以一个break结尾 main(List&lt;String&gt; args) { var direction = &#39;east&#39;; switch (direction) { case &#39;east&#39;: print(&#39;东面&#39;); break; case &#39;south&#39;: print(&#39;南面&#39;); break; case &#39;west&#39;: print(&#39;西面&#39;); break; case &#39;north&#39;: print(&#39;北面&#39;); break; default: print(&#39;其他方向&#39;); } } 三. 类和对象 Dart是一个面向对象的语言，面向对象中非常重要的概念就是类，类产生了对象。 这一节，我们就具体来学习类和对象，但是Dart对类进行了很多其他语言没有的特性，所以，这里我会花比较长的篇幅来讲解。 3.1. 类的定义在Dart中，定义类用class关键字。 类通常有两部分组成：成员（member）和方法（method）。 定义类的伪代码如下： class 类名 { 类型 成员名; 返回值类型 方法名(参数列表) { 方法体 } } 编写一个简单的Person类： 这里有一个注意点: 我们在方法中使用属性(成员/实例变量)时，并没有加this； Dart的开发风格中，在方法中通常使用属性时，会省略this，但是有命名冲突时，this不能省略； class Person { String name; eat() { print(&#39;$name在吃东西&#39;); } } 我们来使用这个类，创建对应的对象： 注意：从Dart2开始，new关键字可以省略。 main(List&lt;String&gt; args) { // 1.创建类的对象 var p = new Person(); // 直接使用Person()也可以创建 // 2.给对象的属性赋值 p.name = &#39;tao&#39;; // 3.调用对象的方法 p.eat(); } 3.2. 构造方法3.2.1. 普通构造方法我们知道, 当通过类创建一个对象时，会调用这个类的构造方法。 当类中没有明确指定构造方法时，将默认拥有一个无参的构造方法。 前面的Person中我们就是在调用这个构造方法. 我们也可以根据自己的需求，定义自己的构造方法: 注意一：当有了自己的构造方法时，默认的构造方法将会失效，不能使用 当然，你可能希望明确的写一个默认的构造方法，但是会和我们自定义的构造方法冲突； 这是因为Dart本身不支持函数的重载（名称相同, 参数不同的方式）。 注意二：这里我还实现了toString方法 class Person { String name; int age; Person(String name, int age) { this.name = name; this.age = age; } @override String toString() { return &#39;name=$name age=$age&#39;; } } 另外，在实现构造方法时，通常做的事情就是通过参数给属性赋值 为了简化这一过程, Dart提供了一种更加简洁的语法糖形式. 上面的构造方法可以优化成下面的写法： Person(String name, int age) { this.name = name; this.age = age; } // 等同于 Person(this.name, this.age); 3.2.2. 命名构造方法但是在开发中, 我们确实希望实现更多的构造方法，怎么办呢？ 因为不支持方法（函数）的重载，所以我们没办法创建相同名称的构造方法。 我们需要使用命名构造方法: class Person { String name; int age; Person() { name = &#39;&#39;; age = 0; } // 命名构造方法 Person.withArgments(String name, int age) { this.name = name; this.age = age; } @override String toString() { return &#39;name=$name age=$age&#39;; } } // 创建对象 var p1 = new Person(); print(p1); var p2 = new Person.withArgments(&#39;tao&#39;, 18); print(p2); 在之后的开发中, 我们也可以利用命名构造方法，提供更加便捷的创建对象方式: 比如开发中，我们需要经常将一个Map转成对象，可以提供如下的构造方法 // 新的构造方法 Person.fromMap(Map&lt;String, Object&gt; map) { this.name = map[&#39;name&#39;]; this.age = map[&#39;age&#39;]; } // 通过上面的构造方法创建对象 var p3 = new Person.fromMap({&#39;name&#39;: &#39;kobe&#39;, &#39;age&#39;: 30}); print(p3); 3.2.3. 初始化列表我们来重新定义一个类Point, 传入x/y，可以得到它们的距离distance: class Point { final num x; final num y; final num distance; // 错误写法 // Point(this.x, this.y) { // distance = sqrt(x * x + y * y); // } // 正确的写法 Point(this.x, this.y) : distance = sqrt(x * x + y * y); } 上面这种初始化变量的方法, 我们称之为初始化列表(Initializer list) 3.2.4. 重定向构造方法在某些情况下, 我们希望在一个构造方法中去调用另外一个构造方法, 这个时候可以使用重定向构造方法： 在一个构造函数中，去调用另外一个构造函数（注意：是在冒号后面使用this调用） class Person { String name; int age; Person(this.name, this.age); Person.fromName(String name) : this(name, 0); } 3.2.5. 常量构造方法在某些情况下，传入相同值时，我们希望返回同一个对象，这个时候，可以使用常量构造方法. 默认情况下，创建对象时，即使传入相同的参数，创建出来的也不是同一个对象，看下面代码: 这里我们使用identical(对象1, 对象2)函数来判断两个对象是否是同一个对象: main(List&lt;String&gt; args) { var p1 = Person(&#39;tao&#39;); var p2 = Person(&#39;tao&#39;); print(identical(p1, p2)); // false } class Person { String name; Person(this.name); } 但是, 如果将构造方法前加const进行修饰，那么可以保证同一个参数，创建出来的对象是相同的 这样的构造方法就称之为常量构造方法。 main(List&lt;String&gt; args) { var p1 = const Person(&#39;tao&#39;); var p2 = const Person(&#39;tao&#39;); print(identical(p1, p2)); // true } class Person { final String name; const Person(this.name); } 常量构造方法有一些注意点: 注意一：拥有常量构造方法的类中，所有的成员变量必须是final修饰的. 注意二: 为了可以通过常量构造方法，创建出相同的对象，不再使用 new关键字，而是使用const关键字 如果是将结果赋值给const修饰的标识符时，const可以省略. 3.2.6. 工厂构造方法Dart提供了factory关键字, 用于通过工厂去获取对象 main(List&lt;String&gt; args) { var p1 = Person(&#39;tao&#39;); var p2 = Person(&#39;tao&#39;); print(identical(p1, p2)); // true } class Person { String name; static final Map&lt;String, Person&gt; _cache = &lt;String, Person&gt;{}; factory Person(String name) { if (_cache.containsKey(name)) { return _cache[name]; } else { final p = Person._internal(name); _cache[name] = p; return p; } } Person._internal(this.name); } 3.3. setter和getter默认情况下，Dart中类定义的属性是可以直接被外界访问的。 但是某些情况下，我们希望监控这个类的属性被访问的过程，这个时候就可以使用setter和getter了 main(List&lt;String&gt; args) { final d = Dog(&quot;黄色&quot;); d.setColor = &quot;黑色&quot;; print(d.getColor); } class Dog { String color; String get getColor { return color; } set setColor(String color) { this.color = color; } Dog(this.color); } 3.4. 类的继承面向对象的其中一大特性就是继承，继承不仅仅可以减少我们的代码量，也是多态的使用前提。 Dart中的继承使用extends关键字，子类中使用super来访问父类。 父类中的所有成员变量和方法都会被继承,，但是构造方法除外。 main(List&lt;String&gt; args) { var p = new Person(); p.age = 18; p.run(); print(p.age); } class Animal { int age; run() { print(&#39;在奔跑ing&#39;); } } class Person extends Animal { } 子类可以拥有自己的成员变量, 并且可以对父类的方法进行重写： class Person extends Animal { String name; @override run() { print(&#39;$name在奔跑ing&#39;); } } 子类中可以调用父类的构造方法，对某些属性进行初始化： 子类的构造方法在执行前，将隐含调用父类的无参默认构造方法（没有参数且与类同名的构造方法）。 如果父类没有无参默认构造方法，则子类的构造方法必须在初始化列表中通过super显式调用父类的某个构造方法。 class Animal { int age; Animal(this.age); run() { print(&#39;在奔跑ing&#39;); } } class Person extends Animal { String name; Person(String name, int age) : name=name, super(age); @override run() { print(&#39;$name在奔跑ing&#39;); } @override String toString() { return &#39;name=$name, age=$age&#39;; } } 3.5. 抽象类我们知道，继承是多态使用的前提。 所以在定义很多通用的调用接口时, 我们通常会让调用者传入父类，通过多态来实现更加灵活的调用方式。 但是，父类本身可能并不需要对某些方法进行具体的实现，所以父类中定义的方法,，我们可以定义为抽象方法。 什么是 抽象方法? 在Dart中没有具体实现的方法(没有方法体)，就是抽象方法。 抽象方法，必须存在于抽象类中。 抽象类是使用abstract声明的类。 下面的代码中, Shape类就是一个抽象类, 其中包含一个抽象方法. abstract class Shape { getArea(); } class Circle extends Shape { double r; Circle(this.r); @override getArea() { return r * r * 3.14; } } class Reactangle extends Shape { double w; double h; Reactangle(this.w, this.h); @override getArea() { return w * h; } } 注意事项: 注意一：抽象类不能实例化. 注意二：抽象类中的抽象方法必须被子类实现, 抽象类中的已经被实现方法, 可以不被子类重写. 3.6. 隐式接口Dart中的接口比较特殊, 没有一个专门的关键字来声明接口. 默认情况下，定义的每个类都相当于默认也声明了一个接口，可以由其他的类来实现(因为Dart不支持多继承) 在开发中，我们通常将用于给别人实现的类声明为抽象类: abstract class Runner { run(); } abstract class Flyer { fly(); } class SuperMan implements Runner, Flyer { @override run() { print(&#39;超人在奔跑&#39;); } @override fly() { print(&#39;超人在飞&#39;); } } 3.7. Mixin混入在通过implements实现某个类时，类中所有的方法都必须被重新实现(无论这个类原来是否已经实现过该方法)。 但是某些情况下，一个类可能希望直接复用之前类的原有实现方案，怎么做呢? 使用继承吗？但是Dart只支持单继承，那么意味着你只能复用一个类的实现。 Dart提供了另外一种方案: Mixin混入的方式 除了可以通过class定义类之外，也可以通过mixin关键字来定义一个类。 只是通过mixin定义的类用于被其他类混入使用，通过with关键字来进行混入。 main(List&lt;String&gt; args) { var superMan = SuperMain(); superMan.run(); superMan.fly(); } mixin Runner { run() { print(&#39;在奔跑&#39;); } } mixin Flyer { fly() { print(&#39;在飞翔&#39;); } } // implements的方式要求必须对其中的方法进行重新实现 // class SuperMan implements Runner, Flyer {} class SuperMain with Runner, Flyer { } 3.8. 类成员和方法前面我们在类中定义的成员和方法都属于对象级别的, 在开发中, 我们有时候也需要定义类级别的成员和方法 在Dart中我们使用static关键字来定义: main(List&lt;String&gt; args) { var stu = Student(); stu.name = &#39;tao&#39;; stu.sno = 110; stu.study(); Student.time = &#39;早上8点&#39;; // stu.time = &#39;早上9点&#39;; 错误做法, 实例对象不能访问类成员 Student.attendClass(); // stu.attendClass(); 错误做法, 实现对象补鞥呢访问类方法 } class Student { String name; int sno; static String time; study() { print(&#39;$name在学习&#39;); } static attendClass() { print(&#39;去上课&#39;); } } 3.9. 枚举类型枚举在开发中也非常常见, 枚举也是一种特殊的类, 通常用于表示固定数量的常量值。 3.9.1. 枚举的定义枚举使用enum关键字来进行定义: main(List&lt;String&gt; args) { print(Colors.red); } enum Colors { red, green, blue } 3.9.2. 枚举的属性枚举类型中有两个比较常见的属性: index: 用于表示每个枚举常量的索引, 从0开始. values: 包含每个枚举值的List. main(List&lt;String&gt; args) { print(Colors.red.index); print(Colors.green.index); print(Colors.blue.index); print(Colors.values); } enum Colors { red, green, blue } 枚举类型的注意事项: 注意一: 您不能子类化、混合或实现枚举。 注意二: 不能显式实例化一个枚举 四. 泛型4.1. 为什么使用泛型?对于有基础的同学, 这部分不再解释 4.2. List和Map的泛型List使用时的泛型写法: // 创建List的方式 var names1 = [&#39;tao&#39;, &#39;kobe&#39;, &#39;james&#39;, 111]; print(names1.runtimeType); // List&lt;Object&gt; // 限制类型 var names2 = &lt;String&gt;[&#39;tao&#39;, &#39;kobe&#39;, &#39;james&#39;, 111]; // 最后一个报错 List&lt;String&gt; names3 = [&#39;tao&#39;, &#39;kobe&#39;, &#39;james&#39;, 111]; // 最后一个报错 Map使用时的泛型写法: // 创建Map的方式 var infos1 = {1: &#39;one&#39;, &#39;name&#39;: &#39;tao&#39;, &#39;age&#39;: 18}; print(infos1.runtimeType); // _InternalLinkedHashMap&lt;Object, Object&gt; // 对类型进行显示 Map&lt;String, String&gt; infos2 = {&#39;name&#39;: &#39;tao&#39;, &#39;age&#39;: 18}; // 18不能放在value中 var infos3 = &lt;String, String&gt;{&#39;name&#39;: &#39;tao&#39;, &#39;age&#39;: 18}; // 18不能放在value中 4.3. 类定义的泛型如果我们需要定义一个类, 用于存储位置信息Location, 但是并不确定使用者希望使用的是int类型,还是double类型, 甚至是一个字符串, 这个时候如何定义呢? 一种方案是使用Object类型, 但是在之后使用时, 非常不方便 另一种方案就是使用泛型. Location类的定义: Object方式 main(List&lt;String&gt; args) { Location l1 = Location(10, 20); print(l1.x.runtimeType); // Object } class Location { Object x; Object y; Location(this.x, this.y); } Location类的定义: 泛型方式 main(List&lt;String&gt; args) { Location l2 = Location&lt;int&gt;(10, 20); print(l2.x.runtimeType); // int Location l3 = Location&lt;String&gt;(&#39;aaa&#39;, &#39;bbb&#39;); print(l3.x.runtimeType); // String } } class Location&lt;T&gt; { T x; T y; Location(this.x, this.y); } 如果我们希望类型只能是num类型, 怎么做呢? main(List&lt;String&gt; args) { Location l2 = Location&lt;int&gt;(10, 20); print(l2.x.runtimeType); // 错误的写法, 类型必须继承自num Location l3 = Location&lt;String&gt;(&#39;aaa&#39;, &#39;bbb&#39;); print(l3.x.runtimeType); } class Location&lt;T extends num&gt; { T x; T y; Location(this.x, this.y); } 4.4. 泛型方法的定义最初，Dart仅仅在类中支持泛型。后来一种称为泛型方法的新语法允许在方法和函数中使用类型参数。 main(List&lt;String&gt; args) { var names = [&#39;tao&#39;, &#39;kobe&#39;]; var first = getFirst(names); print(&#39;$first ${first.runtimeType}&#39;); // tao String } T getFirst&lt;T&gt;(List&lt;T&gt; ts) { return ts[0]; } 五. 库的使用 在Dart中，你可以导入一个库来使用它所提供的功能。 库的使用可以使代码的重用性得到提高，并且可以更好的组合代码。 Dart中任何一个dart文件都是一个库，即使你没有用关键字library声明 5.1. 库的导入import语句用来导入一个库，后面跟一个字符串形式的Uri来指定表示要引用的库，语法如下： import &#39;库所在的uri&#39;; 常见的库URI有三种不同的形式 来自dart标准版，比如dart:io、dart:html、dart:math、dart:core(但是这个可以省略) //dart:前缀表示Dart的标准库，如dart:io、dart:html、dart:math import &#39;dart:io&#39;; 使用相对路径导入的库，通常指自己项目中定义的其他dart文件 //当然，你也可以用相对路径或绝对路径的dart文件来引用 import &#39;lib/student/student.dart&#39;; Pub包管理工具管理的一些库，包括自己的配置以及一些第三方的库，通常使用前缀package //Pub包管理系统中有很多功能强大、实用的库，可以使用前缀 package: import &#39;package:flutter/material.dart&#39;; 库文件中内容的显示和隐藏 如果希望只导入库中某些内容，或者刻意隐藏库里面某些内容，可以使用show和hide关键字 show关键字：可以显示某个成员（屏蔽其他） hide关键字：可以隐藏某个成员（显示其他） import &#39;lib/student/student.dart&#39; show Student, Person; import &#39;lib/student/student.dart&#39; hide Person; 库中内容和当前文件中的名字冲突 当各个库有命名冲突的时候，可以使用as关键字来使用命名空间 import &#39;lib/student/student.dart&#39; as Stu; Stu.Student s = new Stu.Student(); 5.2. 库的定义library关键字 通常在定义库时，我们可以使用library关键字给库起一个名字。 但目前我发现，库的名字并不影响导入，因为import语句用的是字符串URI library math; part关键字 在之前我们使用student.dart作为演练的时候，只是将该文件作为一个库。 在开发中，如果一个库文件太大，将所有内容保存到一个文件夹是不太合理的，我们有可能希望将这个库进行拆分，这个时候就可以使用part关键字了 不过官方已经不建议使用这种方式了： dart.dev/guides/libr… mathUtils.dart文件 part of &quot;utils.dart&quot;; int sum(int num1, int num2) { return num1 + num2; } dateUtils.dart文件 part of &quot;utils.dart&quot;; String dateFormat(DateTime date) { return &quot;2020-12-12&quot;; } utils.dart文件 part &quot;mathUtils.dart&quot;; part &quot;dateUtils.dart&quot;; test_libary.dart文件 import &quot;lib/utils.dart&quot;; main(List&lt;String&gt; args) { print(sum(10, 20)); print(dateFormat(DateTime.now())); } export关键字 官方不推荐使用part关键字，那如果库非常大，如何进行管理呢？ 将每一个dart文件作为库文件，使用export关键字在某个库文件中单独导入 mathUtils.dart文件 int sum(int num1, int num2) { return num1 + num2; } dateUtils.dart文件 String dateFormat(DateTime date) { return &quot;2020-12-12&quot;; } utils.dart文件 library utils; export &quot;mathUtils.dart&quot;; export &quot;dateUtils.dart&quot;; test_libary.dart文件 import &quot;lib/utils.dart&quot;; main(List&lt;String&gt; args) { print(sum(10, 20)); print(dateFormat(DateTime.now())); } 最后，也可以通过Pub管理自己的库自己的库，在项目开发中个人觉得不是非常有必要，所以暂时不讲解这种方式。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Flutter] 03-Dart语法一]]></title>
    <url>%2F2020%2F06%2F17%2FFlutter-03-Dart%E8%AF%AD%E6%B3%95%E4%B8%80%2F</url>
    <content type="text"><![CDATA[一. Hello Dart1.1. Hello World在VSCode中新建一个helloWorld.dart文件，添加下面的内容： main(List&lt;String&gt; args) { print(&#39;Hello World&#39;); } 复制代码然后在终端执行dart helloWorld.dart，就能看到Hello World的结果了。 VSCode快捷键运行 control+ option+ n打开\关闭终端 command + shift + y 1.2. 程序的分析 一、Dart语言的入口也是main函数，并且必须显示的进行定义； 二、Dart的入口函数main是没有返回值的； 三、传递给main的命令行参数，是通过List&lt;String&gt;完成的。从字面值就可以理解List是Dart中的集合类型。其中的每一个String都表示传递给main的一个参数； 四、定义字符串的时候，可以使用单引号或双引号； 五、每行语句必须使用分号结尾，很多语言并不需要分号，比如Swift、JavaScript； 二. 定义变量2.1. 明确声明(Explicit)明确声明变量的方式, 格式如下: 变量类型 变量名称 = 赋值; 示例代码: String name = &#39;codeTao&#39;; int age = 18; double height = 1.88; print(&#39;${name}, ${age}, ${height}&#39;); // 拼接方式后续会讲解 注意事项: 定义的变量可以修改值, 但是不能赋值其他类型 String content = &#39;Hello Dart&#39;; content = &#39;Hello World&#39;; // 正确的 content = 111; // 错误的, 将一个int值赋值给一个String变量 2.2. 类型推导(Type Inference)类型推导声明变量的方式, 格式如下: var/dynamic/const/final 变量名称 = 赋值; 2.3.1. var的使用var的使用示例: runtimeType用于获取变量当前的类型 var name = &#39;codeTao&#39;; name = &#39;kobe&#39;; print(name.runtimeType); // String var的错误用法: var age = 18; age = &#39;tao&#39;; // 不可以将String赋值给一个int类型 2.3.2. dynamic的使用如果确实希望这样做,可以使用dynamic来声明变量: 但是在开发中, 通常情况下不使用dynamic, 因为类型的变量会带来潜在的危险 dynamic name = &#39;codeTao&#39;; print(name.runtimeType); // String name = 18; print(name.runtimeType); // int #####2.3.3. final&amp;const的使用final和const都是用于定义常量的, 也就是定义之后值都不可以修改 final name = &#39;codeTao&#39;; name = &#39;kobe&#39;; // 错误做法 const age = 18; age = 20; // 错误做法 final和const有什么区别呢? const在赋值时, 赋值的内容必须是在编译期间就确定下来的 final在赋值时, 可以动态获取, 比如赋值一个函数 String getName() { return &#39;codeTao&#39;; } main(List&lt;String&gt; args) { const name = getName(); // 错误的做法, 因为要执行函数才能获取到值 final name = getName(); // 正确的做法 } final和const小案例: 首先, const是不可以赋值为DateTime.now() 其次, final一旦被赋值后就有确定的结果, 不会再次赋值 // const time = DateTime.now(); // 错误的赋值方式 final time = DateTime.now(); print(time); // 2020-04-05 09:02:54.052626 sleep(Duration(seconds: 2)); print(time); // 2020-04-05 09:02:54.052626 const放在赋值语句的右边，可以共享对象，提高性能: 这里可以暂时先做了解，后面讲解类的常量构造函数时，我会再次提到这个概念 class Person { const Person(); } main(List&lt;String&gt; args) { final a = const Person(); final b = const Person(); print(identical(a, b)); // true final m = Person(); final n = Person(); print(identical(m, n)); // false } 三. 数据类型3.1. 数字类型对于数值来说，我们也不用关心它是否有符号，以及数据的宽度和精度等问题。只要记着整数用int，浮点数用double就行了。不过，要说明一下的是Dart中的int和double可表示的范围并不是固定的，它取决于运行Dart的平台。 // 1.整数类型int int age = 18; int hexAge = 0x12; print(age); print(hexAge); // 2.浮点类型double double height = 1.88; print(height); 字符串和数字之间的转化: // 字符串和数字转化 // 1.字符串转数字 var one = int.parse(&#39;111&#39;); var two = double.parse(&#39;12.22&#39;); print(&#39;${one} ${one.runtimeType}&#39;); // 111 int print(&#39;${two} ${two.runtimeType}&#39;); // 12.22 double // 2.数字转字符串 var num1 = 123; var num2 = 123.456; var num1Str = num1.toString(); var num2Str = num2.toString(); var num2StrD = num2.toStringAsFixed(2); // 保留两位小数 print(&#39;${num1Str} ${num1Str.runtimeType}&#39;); // 123 String print(&#39;${num2Str} ${num2Str.runtimeType}&#39;); // 123.456 String print(&#39;${num2StrD} ${num2StrD.runtimeType}&#39;); // 123.46 String 3.2. 布尔类型布尔类型中,Dart提供了一个bool的类型, 取值为true和false // 布尔类型 var isFlag = true; print(&#39;$isFlag ${isFlag.runtimeType}&#39;); 注意: Dart中不能判断非0即真, 或者非空即真 Dart的类型安全性意味着您不能使用if(非booleanvalue)或assert(非booleanvalue)之类的代码。 var message = &#39;Hello Dart&#39;; // 错误的写法 if (message) { print(message) } 3.3. 字符串类型Dart字符串是UTF-16编码单元的序列。您可以使用单引号或双引号创建一个字符串: // 1.定义字符串的方式 var s1 = &#39;Hello World&#39;; var s2 = &quot;Hello Dart&quot;; var s3 = &#39;Hello\&#39;Fullter&#39;; var s4 = &quot;Hello&#39;Fullter&quot;; 可以使用三个单引号或者双引号表示多行字符串: // 2.表示多行字符串的方式 var message1 = &#39;&#39;&#39; 哈哈哈 呵呵呵 嘿嘿嘿&#39;&#39;&#39;; 字符串和其他变量或表达式拼接: 使用${expression}, 如果表达式是一个标识符, 那么{}可以省略 // 3.拼接其他变量 var name = &#39;codeTao&#39;; var age = 18; var height = 1.88; print(&#39;my name is ${name}, age is $age, height is $height&#39;); 3.4. 集合类型3.4.1. 集合类型的定义对于集合类型，Dart则内置了最常用的三种：List / Set / Map。其中，List可以这样来定义： // List定义 // 1.使用类型推导定义 var letters = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]; print(&#39;$letters ${letters.runtimeType}&#39;); // 2.明确指定类型 List&lt;int&gt; numbers = [1, 2, 3, 4]; print(&#39;$numbers ${numbers.runtimeType}&#39;); 其中，set可以这样来定义： 其实，也就是把[]换成{}就好了。 Set和List最大的两个不同就是：Set是无序的，并且元素是不重复的。 // Set的定义 // 1.使用类型推导定义 var lettersSet = {&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;}; print(&#39;$lettersSet ${lettersSet.runtimeType}&#39;); // 2.明确指定类型 Set&lt;int&gt; numbersSet = {1, 2, 3, 4}; print(&#39;$numbersSet ${numbersSet.runtimeType}&#39;); 最后，Map是我们常说的字典类型，它的定义是这样的： // Map的定义 // 1.使用类型推导定义 var infoMap1 = {&#39;name&#39;: &#39;tao&#39;, &#39;age&#39;: 18}; print(&#39;$infoMap1 ${infoMap1.runtimeType}&#39;); // 2.明确指定类型 Map&lt;String, Object&gt; infoMap2 = {&#39;height&#39;: 1.88, &#39;address&#39;: &#39;北京市&#39;}; print(&#39;$infoMap2 ${infoMap2.runtimeType}&#39;); 3.4.2. 集合的常见操作了解了这三个集合的定义方式之后，我们来看一些最基础的公共操作第一类，是所有集合都支持的获取长度的属性length： // 获取集合的长度 print(letters.length); print(lettersSet.length); print(infoMap1.length); 第二类, 是添加/删除/包含操作 并且，对List来说，由于元素是有序的，它还提供了一个删除指定索引位置上元素的方法 // 添加/删除/包含元素 numbers.add(5); numbersSet.add(5); print(&#39;$numbers $numbersSet&#39;); numbers.remove(1); numbersSet.remove(1); print(&#39;$numbers $numbersSet&#39;); print(numbers.contains(2)); print(numbersSet.contains(2)); // List根据index删除元素 numbers.removeAt(3); print(&#39;$numbers&#39;); 第三类，是Map的操作 由于它有key和value，因此无论是读取值，还是操作，都要明确是基于key的，还是基于value的，或者是基于key/value对的。 // Map的操作 // 1.根据key获取value print(infoMap1[&#39;name&#39;]); // tao // 2.获取所有的entries print(&#39;${infoMap1.entries} ${infoMap1.entries.runtimeType}&#39;); // (MapEntry(name: tao), MapEntry(age: 18)) MappedIterable&lt;String, MapEntry&lt;String, Object&gt;&gt; // 3.获取所有的keys print(&#39;${infoMap1.keys} ${infoMap1.keys.runtimeType}&#39;); // (name, age) _CompactIterable&lt;String&gt; // 4.获取所有的values print(&#39;${infoMap1.values} ${infoMap1.values.runtimeType}&#39;); // (tao, 18) _CompactIterable&lt;Object&gt; // 5.判断是否包含某个key或者value print(&#39;${infoMap1.containsKey(&#39;age&#39;)} ${infoMap1.containsValue(18)}&#39;); // true true // 6.根据key删除元素 infoMap1.remove(&#39;age&#39;); print(&#39;${infoMap1}&#39;); // {name: tao} 四. 函数4.1. 函数的基本定义Dart是一种真正的面向对象语言，所以即使函数也是对象，所有也有类型, 类型就是Function。这也就意味着函数可以作为变量定义或者作为其他函数的参数或者返回值.函数的定义方式: 返回值 函数的名称(参数列表) { 函数体 return 返回值 } 按照上面的定义方式, 我们定义一个完整的函数: int sum(num num1, num num2) { return num1 + num2; } Effective Dart建议对公共的API, 使用类型注解, 但是如果我们省略掉了类型, 依然是可以正常工作的 sum(num1, num2) { return num1 + num2; } 另外, 如果函数中只有一个表达式, 那么可以使用箭头语法(arrow syntax) 注意, 这里面只能是一个表达式, 不能是一个语句 sum(num1, num2) =&gt; num1 + num2; 4.2. 函数的参数问题 函数的参数可以分成两类: 必须参数和可选参数前面使用的参数都是必须参数. 4.2.1. 可选参数可选参数可以分为 命名可选参数 和 位置可选参数定义方式: 命名可选参数: {param1, param2, ...} 位置可选参数: [param1, param2, ...] 命名可选参数的演示: // 命名可选参数 printInfo1(String name, {int age, double height}) { print(&#39;name=$name age=$age height=$height&#39;); } // 调用printInfo1函数 printInfo1(&#39;tao&#39;); // name=tao age=null height=null printInfo1(&#39;tao&#39;, age: 18); // name=tao age=18 height=null printInfo1(&#39;tao&#39;, age: 18, height: 1.88); // name=tao age=18 height=1.88 printInfo1(&#39;tao&#39;, height: 1.88); // name=tao age=null height=1.88 位置可选参数的演示: // 定义位置可选参数 printInfo2(String name, [int age, double height]) { print(&#39;name=$name age=$age height=$height&#39;); } // 调用printInfo2函数 printInfo2(&#39;tao&#39;); // name=tao age=null height=null printInfo2(&#39;tao&#39;, 18); // name=tao age=18 height=null printInfo2(&#39;tao&#39;, 18, 1.88); // name=tao age=18 height=1.88 命名可选参数, 可以指定某个参数是必传的(使用@required, 有问题) // 命名可选参数的必须 printInfo3(String name, {int age, double height, @required String address}) { print(&#39;name=$name age=$age height=$height address=$address&#39;); } 4.2.2. 参数默认值参数可以有默认值, 在不传入的情况下, 使用默认值 注意, 只有可选参数才可以有默认值, 必须参数不能有默认值 // 参数的默认值 printInfo4(String name, {int age = 18, double height=1.88}) { print(&#39;name=$name age=$age height=$height&#39;); } Dart中的main函数就是一个接受可选的列表参数作为参数的, 所以在使用main函数时, 我们可以传入参数, 也可以不传入 4.3. 函数是一等公民在很多语言中, 函数并不能作为一等公民来使用, 比如Java/OC. 这种限制让编程不够灵活, 所以现代的编程语言基本都支持函数作为一等公民来使用, Dart也支持. 这就意味着你可以将函数赋值给一个变量, 也可以将函数作为另外一个函数的参数或者返回值来使用. main(List&lt;String&gt; args) { // 1.将函数赋值给一个变量 var bar = foo; print(bar); // 2.将函数作为另一个函数的参数 test(foo); // 3.将函数作为另一个函数的返回值 var func =getFunc(); func(&#39;kobe&#39;); } // 1.定义一个函数 foo(String name) { print(&#39;传入的name:$name&#39;); } // 2.将函数作为另外一个函数的参数 test(Function func) { func(&#39;codeTao&#39;); } // 3.将函数作为另一个函数的返回值 getFunc() { return foo; } 4.4. 匿名函数的使用大部分我们定义的函数都会有自己的名字， 比如前面定义的foo、test函数等等。 但是某些情况下，给函数命名太麻烦了，我们可以使用没有名字的函数，这种函数可以被称之为匿名函数( anonymous function)，也可以叫lambda或者closure。 main(List&lt;String&gt; args) { // 1.定义数组 var movies = [&#39;盗梦空间&#39;, &#39;星际穿越&#39;, &#39;少年派&#39;, &#39;大话西游&#39;]; // 2.使用forEach遍历: 有名字的函数 printElement(item) { print(item); } movies.forEach(printElement); // 3.使用forEach遍历: 匿名函数 movies.forEach((item) { print(item); }); movies.forEach((item) =&gt; print(item)); } 4.5. 词法作用域dart中的词法有自己明确的作用域范围，它是根据代码的结构({})来决定作用域范围的 优先使用自己作用域中的变量，如果没有找到，则一层层向外查找。 var name = &#39;global&#39;; main(List&lt;String&gt; args) { // var name = &#39;main&#39;; void foo() { // var name = &#39;foo&#39;; print(name); } foo(); } 4.6. 词法闭包闭包可以访问其词法范围内的变量，即使函数在其他地方被使用，也可以正常的访问。 main(List&lt;String&gt; args) { makeAdder(num addBy) { return (num i) { return i + addBy; }; } var adder2 = makeAdder(2); print(adder2(10)); // 12 print(adder2(6)); // 8 var adder5 = makeAdder(5); print(adder5(10)); // 15 print(adder5(6)); // 11 } 4.7. 返回值问题所有函数都返回一个值。如果没有指定返回值，则语句返回null;隐式附加到函数体。 main(List&lt;String&gt; args) { print(foo()); // null } foo() { print(&#39;foo function&#39;); }]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Flutter] 02-Mac环境搭建Flurrer问题解决]]></title>
    <url>%2F2020%2F06%2F16%2FFlutter-02-Mac%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAFlurrer%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[个人环境搭建遇到问题解决方案总结VS问题1: bin/sh dart:command not foundVS问题2: 提示Could not find a Flutter SDKVS问题3: For full Dart language support, please open a folder containing your Dart files instead of individual loose filesAS问题1: AndroidStudio 打开新项目, 顶部提示: ‘package get’ has not been runAS问题2: 提示Could not find a Flutter SDKAS问题3: For full Dart language support, please open a folder containing your Dart files instead of individual loose filesAS问题4: it is taking an unexpectedly long time.AS问题5: Checking Android licenses is taking an unexpectedly long time…AS问题6: AndroidStudio安装完flutter,dart插件后，重启，AndroidStudio再次提示没有安装dart,实际上flutter sdk中已经有dart了AS问题7: Failed to install the following Android SDK packages as some licences have not been acceptedAS问题8: No active package devtools. pub finished with exit code 65 一、VSCode 配置问题:问题1: bin/sh dart:command not found错误: VSCode 运行时显示错误: bin/sh dart:command not found或者写代码时,基本函数不提示, 比如main函数不自动显示代码块 解决:1.首先确定已经安装Dart和Flutter插件.2.然后要确定环境是否正确配置, 打开.bash_profile,参考上边配置 open ~/.bash_profile 3.安装dart环境 $ brew tap dart-lang/dart $ brew install dart 4.重启VSCode 问题2: 提示Could not find a Flutter SDK使用VSCode打开flutter项目, 如果提示显示错误信息: Could not find a Flutter SDK. Please ensure flutter is installed and in your PATH (you may need to restart). 解决: 这说明我们上面配置flutter命令没有成功，检测一下路径是否有问题，可以cd到本地flutter目录下，使用flutter -h，查看运行结果，如果失败，就检测一下路径。如果上面路径下提示成功，在其他路径下提示不成功，那么进行下面命令： vim ~/.zshrc 在打开的文件里最下面增加一行代码，就是配置的路径 export PATH=本地flutter路径/bin:$PATH 保存退出后，再使用source命令重新加载一下： source ~/.zshrc 到这里，应该可是在任何路径下使用flutter命令了。 问题3: For full Dart language support, please open a folder containing your Dart files instead of individual loose files 原因:如果直接新建一个 .dart 文件进行编辑不支持，需要新建一个文件夹，再在里面新建 .dart文件就可以了. 解决: 提示翻译: 要获得Dart语言的全面支持，请打开一个包含Dart文件的文件夹.所以点击打开文件夹按钮, 找到新建dart文件所在文件夹即可. 二、AndroidStudio配置问题问题1: AndroidStudio 打开新项目, 顶部提示: ‘package get’ has not been run错误信息:Flutter: ‘package get’ has not been run; ‘Pub get’ has not been run 原因: Dart与node类似。它有一个pubspec.yaml相当于package.json包含你的依赖项和内容的项。需要下载这些依赖项。 解决：参考stackoverflow 此警告仅在此处提醒您未下载依赖项 =&gt;单击Get Dependencies第一个警告. 如果卡在flutter packages get, 请看问题2 问题2: flutter packages get 慢或者卡错误信息: Running “flutter pub get” in xxx如果默认镜像已经修改为国内镜像，并重新执行命令安装；结果问题还是出现。 1) .zshrc文件没有配置 如果你使用终端是zsh，终端启动时 ~/.bash_profile 将不会被加载，解决办法就是修改 ～/.zshrc ，在其中添加： source ～/.bash_profile 重启 2) 终端优先执行下面三条指令尝试:此方法修改临时环境的配置 export PUB_HOSTED_URL=https://pub.flutter-io.cn export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn flutter packages get 3) 手动下载插件直接放本地使用如果网络正常，镜像正常，环境正常，三条指令执行后，还是依旧会出现卡在flutter packages get的情况。可以考虑手动下载插件直接放本地使用。这里就直接po出flutter插件默认本地路径： flutter的SDK目录/.pub-cache/hosted/当前使用的镜像地址文件夹/ 参考示例： /usr/local/flutter1.5.4/.pub-cache/hosted/pub.flutter-io.cn/ 在hosted文件夹下，可以发现几个以flutter镜像域名命名的文件夹./hosted .../dart-pub.mirrors.sjtug.sjtu.edu.cn%47/ .../pub.dartlang.org/ .../pub.flutter-io.cn/ 可见下载的依赖包都是按不同镜像分目录存放，所以每切一回镜像，都需要重新下载所有项目的依赖插件；因为加载的插件较多，也就导致等待时间非常久，这也是切换了几个国内镜像依旧卡flutter packages get很久的原因。 解决方法: 第一步，按需选择操作步骤： 耐心等待下载（若下载的插件数量非常多，等待的耗时会比较长） 将其他镜像文件夹下已下载的插件文件，拷贝到当前使用的镜像的目录下，并执行flutter packages get（避免有遗漏的插件） 手动到插件的github下载文件，放到当前使用的镜像目录下 第二步，执行flutter run。 问题3: Waiting for another flutter command to release the startup lock… 方法一: 删除flutter SDK 下的/bin/cache/lockfile文件, 重启Android Studio。 方法二: 启动mac自带的活动监视器, 搜索dart, 将所有dart进程关闭即可。此方法不需要重启Android Studio, 所以建议方法二。 问题4: it is taking an unexpectedly long time.Please try steps below: a. delete all contents under /home/nima/.gradleb. cd to the android folder for your flutter project and run ./gradlew sync command, it will download the gradle-xxx.zip automatically. It this gradle process succeeds, re-run the flutter run command.翻译: 1&gt; 删除 /home/nima/.gradle 下的所有内容 2&gt; cd到flutter项目的android文件夹并运行./gradlew sync 命令，它将自动下载gradle-xxx.zip。如果此gradle过程成功，请重新运行flutter run命令。 3&gt; flutter run -v flutter run -v : it usually download gradle(which is a large file) for the first time you run a flutter program.The above will help you to see the message that its downloading gradle/dist.It wont happen from the next program 问题5: Checking Android licenses is taking an unexpectedly long time…终端运行 flutter doctor --android-licenses 会检查是否需要更新 Android SDK ,并重启电脑 如下提示则成功: All SDK package licenses accepted.======] 100% Computing updates... 问题6: AndroidStudio安装完flutter,dart插件后，重启，AndroidStudio再次提示没有安装dart,实际上flutter sdk中已经有dart了解决：AndroidStudio需要设置flutter的目录，设置方法：file-&gt;setting-&gt;languages&amp;Frameworks-&gt;flutter 问题7: Failed to install the following Android SDK packages as some licences have not been accepted解决： 用flutter进行编写时出现了标题的错误，不是配置的原因，而是需要接受SDK的证书，反正不难操作即可解决。 1、首先打开控制台，使用如下命令： cd /Users/你的用户名/Library/Android/sdk cd tools cd bin 2、最关键的一部就是下面这个语句 sdkmanager.bat --licenses 执行之后，它会提示你去允许认证，然后命令会提醒你确定y/n（accept lincense），一路y下去便可以了。 参考解决方案 问题8: No active package devtools. pub finished with exit code 65 Android Studio 点击 Open in DevTools時，报错： No active package devtools. pub finished with exit code 65 解决：没有安装DevTools, 终端调用命令安装, 安装后重新启动Android Studio, 并运行项目,再次点击Open in DevTools flutter packages pub global activate devtools 如果没有安装成功, 并且提示以下信息,按照信息提示,在.bash_profile文件中添加export PATH=”$PATH”:”你的flutterSDK路径/.pub-cache/bin” Warning: Pub installs executables into /Users/SKFlutter/flutter/.pub-cache/bin, which is not on your path. You can fix that by adding this to your shell&#39;s config file (.bashrc, .bash_profile, etc.): export PATH=&quot;$PATH&quot;:&quot;你的flutterSDK路径/.pub-cache/bin&quot; Activated devtools 0.2.5. 再次执行 flutter packages pub global activate devtools]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Flutter] 01-Mac环境搭建Flurrer]]></title>
    <url>%2F2020%2F06%2F14%2FFlutter-01-Mac%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAFlurrer%2F</url>
    <content type="text"><![CDATA[建议先看官方文档, 下面是作者自己的搭建过程,仅供参考官方中文文档 一、Flutter SDK1.Flutter官网下载其最新可用的安装包下载SDKFlutter官网SDK下载 2.解压安装包到你指定的目录，可以右键用解压工具,也可以用下面命令 cd ~/development unzip ~/Downloads/flutter_macos_1.17.1-stable.zip 3.如果下面指令只在当前命令行窗口执行, 该设置PATH环境变量是临时的，要想永久将Flutter添加到PATH,需要将下面代码添加到.bash_profile文件中: 首先终端输入, 打开.bash_profile文件 open ~/.bash_profile .bash_profile文件中添加下面环境配置 #Flutter环境变量SDK地址 export PATH=本地flutter路径/bin:$PATH #google提供服务地址 export PUB_HOSTED_URL=https://pub.flutter-io.cn export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn 其中google提供服务地址 也可以使用上海交通大学的镜像地址 export PUB_HOSTED_URL=https://dart-pub.mirrors.sjtug.sjtu.edu.cn export FLUTTER_STORAGE_BASE_URL=https://mirrors.sjtug.sjtu.edu.cn 4.运行source ~/.bash_profile命名, 刷新当前终端窗口。 source ~/.bash_profile 或者运行 source $HOME/.bash_profile 注意: 如果你使用终端是zsh，终端启动时 ~/.bash_profile 将不会被加载，解决办法就是修改 ～/.zshrc ，在其中添加：source ～/.bash_profile 打开.zshrc文件 open ~/.zshrc 在其中添加：source ～/.bash_profile 保存退出,执行 souce ~/.zshrc source ~/.zshrc 5.验证“flutter/bin”是否已在PATH中： echo $PATH 二、当前终端窗口检测flutter环境flutter doctor 完成提示: Doctor summary (to see all details, run flutter doctor -v): [✓] Flutter (Channel stable, v1.17.1, on Mac OS X 10.15.4 19E287, locale zh-Hans-CN) [✓] Android toolchain - develop for Android devices (Android SDK version 28.0.3) [✓] Xcode - develop for iOS and macOS (Xcode 11.5) [✓] Android Studio (version 3.5) [✓] VS Code (version 1.45.1) [✓] Connected device (1 available) • No issues found! 三、安装Android Studio如果想为Flutter配置Android开发环境，需要在我们的电脑上安装一个Android Studio。Android Studio是基于IntelliJ IDEA的、Google 官方的 Android 应用集成开发环境 (IDE)。 1.建议从官网下载安装3.5.3版使用, 用最新版3.6.3有和Flutter和Dart插件兼容问题Android Studio所有版本下载 2.下载Flutter和Dart插件 Android Studio安装完后下载Flutter和Dart插件Flutter插件： 支持Flutter开发工作流 (运行、调试、热重载等)。Dart插件： 提供代码分析 (输入代码时进行验证、代码补全等)。 点击左上角Android Studio进入Preferences Plugins中搜索Flutter, 选择第一个Flutter点击install按钮，同样下载Dart。 3.添加模拟器1&gt;. 启动 Android Studio&gt;Tools&gt;Android&gt;AVD Manager 并选择 Create Virtual Device。2&gt;. 选择一个设备并选择 Next。3&gt;. 为要模拟的Android版本选择一个或多个系统映像，然后选择 Next. 建议使用 x86 或 x86_64 image。4&gt;. 在 Emulated Performance下, 选择 Hardware - GLES 2.0 以启用 硬件加速。5&gt;. 验证AVD配置是否正确，然后选择 Finish。有关上述步骤的详细信息，请参阅 Managing AVDs.6&gt;. 在 Android Virtual Device Manager中, 点击工具栏的 Run。模拟器启动并显示所选操作系统版本或设备的启动画面。7&gt;. 运行 flutter run 启动您的设备. 连接的设备名是 Android SDK built for &lt;platform&gt;,其中 platform 是芯片系列, 如 x86。 4. 查看AndroidSDK路径 启动界面中Android Studio可以查看AndroidSDK路径, 启动页点击Configure-&gt;SDKManager。如下图: 或者选择顶部菜单栏 Android Studio&gt;Tools&gt;Android&gt;SDK Manager 四、VSCode 配置1) 安装flutter和Dart插件 1.启动 VS Code。2.选择扩展。3.在搜索框输入 flutter ，在搜索结果列表中选择 Flutter (只有未安装插件才显示Install按钮) ，然后点击 Install。同样搜索Dart后同样安装操作。4.选择 ‘OK’ 重新启动 VS Code。 5.验证配置: 调用 View&gt;Command Palette… 输入 ‘doctor’, 然后选择 ‘Flutter: Run Flutter Doctor’ action。 查看“OUTPUT”窗口中的输出是否有问题 2) VSCode中文配置1.打开“vscode” ，按快捷键“Ctrl+Shift+P”。2.在顶部搜索框中输入“configure language”，按回车键。 3.“vscode”里面就会打开一个语言配置文件，将“en-us”修改成“zh-cn”，按“Ctrl+S”保存设置，重启“vscode”就可以了. 4.如果没有zh-cn ,点击下面 Install additional languages, 下载中文语言包后,再次重复上面操作. 3) VSCode代码提示配置 代码片段Flutter Widget Snippets: 提供 Widget 代码片段Awesome Flutter Snippets: 提供常用函数的代码片段。使用起来非常方便，例如创建一个 Stateful App，只需要输入 fstful，即可快速创建。 高亮Bracket Pair Colorizervscode 自动会为 Dart 代码进行高亮显示，因此无需下载其他高亮插件。但是写过 Flutter 的应该都会觉得， Flutter 简直就是嵌套地狱。因此推荐这个插件，可对括号进行高亮匹配显示，这样更易于阅读以及修改代码。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Swift5.1] 28-响应式编程]]></title>
    <url>%2F2020%2F06%2F11%2FSwift5-1-28-%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[响应式编程响应式编程（Reactive Programming，简称RP） 也是一种编程范式，于1997年提出，可以简化异步编程，提供更优雅的数据绑定 一般与函数式融合在一起，所以也会叫做：函数响应式编程（Functional Reactive Programming，简称FRP） 比较著名的、成熟的响应式框架: ReactiveCocoa简称RAC，有Objective-C、Swift版本官网： http://reactivecocoa.io/github：https://github.com/ReactiveCocoa ReactiveX简称Rx，有众多编程语言的版本，比如RxJava、RxKotlin、RxJS、RxCpp、RxPHP、RxGo、RxSwift等等官网： http://reactivex.io/github： https://github.com/ReactiveX RxSwift RxSwift（ReactiveX for Swift），ReactiveX的Swift版本源码：https://github.com/ReactiveX/RxSwift中文文档： https://beeth0ven.github.io/RxSwift-Chinese-Documentation/ RxSwift的github上已经有详细的安装教程，这里只演示CocoaPods方式的安装 ① Podfile use_frameworks! target &#39;target_name&#39; do pod &#39;RxSwift&#39;, &#39;~&gt; 5&#39; pod &#39;RxCocoa&#39;, &#39;~&gt; 5&#39; end ② 命令行 pod repo update pod install ③ 导入模块 import RxSwift import RxCocoa 模块说明:RxSwift：Rx标准API的Swift实现，不包括任何iOS相关的内容RxCocoa：基于RxSwift，给iOS UI控件扩展了很多Rx特性 RxSwift的核心角色 Observable：负责发送事件（Event） Observer：负责订阅Observable，监听Observable发送的事件（Event） 发出事件为枚举实例: public enum Event&lt;Element> { /// Next element is produced. case next(Element) /// Sequence terminated with an error. case error(Swift.Error) /// Sequence completed successfully. case completed } Event有3种: next：携带具体数据 error：携带错误信息，表明Observable终止，不会再发出事件 completed：表明Observable终止，不会再发出事件 创建、订阅Observable 发送一个事件 var observable = Observable&lt;Int>.create { observer in observer.onNext(1) observer.onCompleted() return Disposables.create() } // 等价于 observable = Observable.just(1) observable = Observable.of(1) observable = Observable.from([1]) 发送多个事件 var observable = Observable&lt;Int>.create { observer in observer.onNext(1) observer.onNext(2) observer.onNext(3) observer.onCompleted() return Disposables.create() } // 等价于 observable = Observable.of(1, 2, 3) observable = Observable.from([1, 2, 3]) observable.subscribe { event in print(event) }.dispose() observable.subscribe(onNext: { print("next", $0) }, onError: { print("error", $0) }, onCompleted: { print("completed") }, onDisposed: { print("dispose") }).dispose() 创建定时器 //参数1: 延迟时间, period:间隔时间, scheduler: 执行线程 let observable = Observable&lt;Int>.timer(.seconds(3), period: .seconds(1), scheduler: MainScheduler.instance) observable.map { "数值是\($0)" } .bind(to: label.rx.text) .disposed(by: bag) 创建Observer 1&gt;AnyObserver 创建Observer let observer = AnyObserver&lt;Int>.init { event in switch event { case .next(let data): print(data) case .completed: print("completed") case .error(let error): print("error", error) } } Observable.just(1).subscribe(observer).dispose() 2&gt; Binder 创建Observer let binder = Binder&lt;String>(label) { label, text in label.text = text } Observable.just(1).map { "数值是\($0)" }.subscribe(binder).dispose() Observable.just(1).map { "数值是\($0)" }.bind(to: binder).dispose() 扩展Binder属性extension Reactive where Base: UIView { var hidden: Binder&lt;Bool> { Binder&lt;Bool>(base) { view, value in view.isHidden = value } } } let observable = Observable&lt;Int>.interval(.seconds(1), scheduler: MainScheduler.instance) observable.map { $0 % 2 == 0 }.bind(to: button.rx.hidden).disposed(by: bag) 传统的状态监听在开发中经常要对各种状态进行监听，传统的常见监听方案有 KVO Target-Action Notification Delegate Block Callback 传统方案经常会出现错综复杂的依赖关系、耦合性较高，还需要编写重复的非业务代码 RxSwift的状态监听1button.rx.tap.subscribe(onNext: { print("按钮被点击了1") }).disposed(by: bag) let data = Observable.just([ Person(name: "Jack", age: 10), Person(name: "Rose", age: 20) ]) data.bind(to: tableView.rx.items(cellIdentifier: "cell")) { row, person, cell in cell.textLabel?.text = person.name cell.detailTextLabel?.text = "\(person.age)" }.disposed(by: bag) tableView.rx.modelSelected(Person.self) .subscribe(onNext: { person in print("点击了", person.name) }).disposed(by: bag) RxSwift的状态监听2class Dog: NSObject { @objc dynamic var name: String? } dog.rx.observe(String.self, "name") .subscribe(onNext: { name in print("name is", name ?? "nil") }).disposed(by: bag) dog.name = "larry" dog.name = "wangwang" NotificationCenter.default.rx .notification(UIApplication.didEnterBackgroundNotification) .subscribe(onNext: { notification in print("APP进入后台", notification) }).disposed(by: bag) 既是Observable，又是ObserverObservable.just(0.8).bind(to: slider.rx.value).dispose() slider.rx.value.map { &quot;当前数值是：\($0)&quot; }.bind(to: textField.rx.text).disposed(by: bag) textField.rx.text .subscribe(onNext: { text in print("text is", text ?? "nil") }).disposed(by: bag) 诸如UISlider.rx.value、UTextField.rx.text这类属性值，既是Observable，又是Observer 它们是RxCocoa.ControlProperty类型 Disposable 每当Observable被订阅时，都会返回一个Disposable实例，当调用Disposable的dispose，就相当于取消订阅 在不需要再接收事件时，建议取消订阅，释放资源。有3种常见方式取消订阅 1&gt; 立即取消订阅（一次性订阅） observable.subscribe { event in print(event) }.dispose() 2&gt; 当bag销毁（deinit）时，会自动调用Disposable实例的dispose let bag = DisposeBag() observable.subscribe { event in print(event) }.disposed(by: bag) 3&gt; self销毁时（deinit）时，会自动调用Disposable实例的dispose let _ = observable.takeUntil(self.rx.deallocated).subscribe { event in print(event) }]]></content>
      <categories>
        <category>iOS笔记</category>
      </categories>
      <tags>
        <tag>Swift5.1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Swift5.1] 27-面向协议编程]]></title>
    <url>%2F2020%2F06%2F10%2FSwift5-1-27-%E9%9D%A2%E5%90%91%E5%8D%8F%E8%AE%AE%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[面向协议编程面向协议编程（Protocol Oriented Programming，简称POP） 是Swift的一种编程范式， Apple于2015年WWDC提出 在Swift的标准库中，能见到大量POP的影子 同时，Swift也是一门面向对象的编程语言（Object Oriented Programming，简称OOP） 在Swift开发中，OOP和POP是相辅相成的，任何一方并不能取代另一方 POP能弥补OOP一些设计上的不足 回顾OOP1&gt; OOP的三大特性：封装、继承、多态 2&gt; 继承的经典使用场合: 当多个类（比如A、B、C类）具有很多共性时，可以将这些共性抽取到一个父类中（比如D类），最后A、B、C类继承D类 OOP的不足1)但有些问题，使用OOP并不能很好解决 比如 如何将 BVC、DVC 的公共方法 run 抽取出来？ class BVC: UIViewController { func run() { print("run") } } class DVC: UITableViewController { func run() { print("run") } } 2) 基于OOP想到的一些解决方案？ 1.将run方法放到另一个对象A中，然后BVC、DVC拥有对象A属性缺点: 多了一些额外的依赖关系 2.将run方法增加到UIViewController分类中缺点: UIViewController会越来越臃肿，而且会影响它的其他所有子类 3.将run方法抽取到新的父类，采用多继承？（C++支持多继承）缺点: 会增加程序设计复杂度，产生菱形继承等问题，需要开发者额外解决 POP的解决方案protocol Runnable { func run() } extension Runnable { func run() { print("run") } } class BVC: UIViewController, Runnable {} class DVC: UITableViewController, Runnable {} 再举例 POP的注意点 优先考虑创建协议，而不是父类（基类） 优先考虑值类型（struct、enum），而不是引用类型（class） 巧用协议的扩展功能 不要为了面向协议而使用协议 利用协议实现前缀效果var string = "123fdsf434" print(string.my.numberCount()) 1&gt; 前缀类型: struct MY&lt;Base> { let base: Base init(_ base: Base) { self.base = base } } 2&gt; 利用协议 扩展前缀属性 protocol MYCompatible {} extension MYCompatible { static var my: MY&lt;Self>.Type { get{ MY&lt;Self>.self } set{} } var my:MY&lt;Self> { get { MY(self) } set {} } } 3&gt; 让扩展功能的类型 遵守协议, 给前缀类型扩展功能 //给字符串扩展功能, 让String拥有my前缀属性 extension String: MYCompatible {} //给String.my , String().my 前缀扩展功能 extension MY where Base == String { func numberCount() -> Int { var count = 0 for c in base where ("0"..."9").contains(c) { count += 1 } return count } } Base: 类class Person {} class Student: Person {} extension Person: MYCompatible {} extension MY where Base: Person { func run() {} static func test() {} } Person.my.test() Student.my.test() let p = Person() p.my.run() let s = Student() s.my.run() Base: 协议var s1: String = "123fdsf434" var s2: NSString = "123fdsf434" var s3: NSMutableString = "123fdsf434" print(s1.my.numberCount()) print(s2.my.numberCount()) print(s3.my.numberCount()) extension String: MYCompatible {} extension NSString: MYCompatible {} extension MY where Base: ExpressibleByStringLiteral { func numberCount() -> Int { let string = base as! String var count = 0 for c in string where ("0"..."9").contains(c) { count += 1 } return count } } 利用协议实现类型判断 协议最终就是一个具体类型, 有 metadate func isArray(_ value: Any) -> Bool { value is [Any] } isArray( [1, 2] ) isArray( ["1", 2] ) isArray( NSArray() ) isArray( NSMutableArray() ) protocol ArrayType {} extension Array: ArrayType {} extension NSArray: ArrayType {} func isArrayType(_ type: Any.Type) -> Bool { type is ArrayType.Type } isArrayType([Int].self) isArrayType([Any].self) isArrayType(NSArray.self) isArrayType(NSMutableArray.self)]]></content>
      <categories>
        <category>iOS笔记</category>
      </categories>
      <tags>
        <tag>Swift5.1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Swift5.1] 26-函数式编程]]></title>
    <url>%2F2020%2F06%2F10%2FSwift5-1-26-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Array的常见操作 arr.map() : 遍历数组每一个元素, 每遍历一个元素调用一次闭包,将元素传入闭包,闭包获取元素进行各种处理, 最后返回一个值. arr.filter() : 遍历数组每一个元素, 每遍历一个元素调用一次闭包,将元素传入闭包, 闭包获取元素进行各种处理, 最后返回Bool值, 如果返回true会将元素添加到新数组中. arr.reduce() : 遍历数组每一个元素,每遍历一个元素调用一次闭包,将元素传入闭包, 闭包中 result上次遍历返回值 , result初始值为reduce传入值, element 每次遍历取出元素 1) map 映射函数 var arr = [1, 2, 3, 4] var arr2 = arr.map { (i) -> Int in return i * 2 } print(arr2) // [2, 4, 6, 8] // 简化为 var arr2 = arr.map { $0 * 2 } 2) filter 过滤函数 var arr = [1, 2, 3, 4] var arr3 = arr.filter { (i) -> Bool in return i % 2 == 0 } print(arr3) // [2, 4] //简化为: var arr3 = arr.filter { $0 % 2 == 0 } 3) reduce 函数 var arr = [1, 2, 3, 4] var result = arr.reduce(0) { (result, element) -> Int in result + element } print(result) //10 //简化为: // $0 上次遍历返回的结果 (初始值为0) // $1 每次遍历到的数组元素 var arr4 = arr.reduce(0) { $0 + $1 } // 10 var arr5 = arr.reduce(0, +) // 10 示例一: func double(_ i: Int) -> Int { i * 2 } var arr = [1, 2, 3, 4] // [2, 4, 6, 8] print(arr.map(double)) 示例二: Map 与 flatMap区别 var arr = [1, 2, 3] // [[1], [2, 2], [3, 3, 3]] var arr2 = arr.map { Array.init(repeating: $0, count: $0) } // [1, 2, 2, 3, 3, 3] var arr3 = arr.flatMap { Array.init(repeating: $0, count: $0) } arr.map(transform: (Int) throws -&gt; T) arr.flatMap(transform: (Int) throws -&gt; Sequence) flatMap: 传入数组元素, 遍历完后,返回Sequence 新的数组, 新数组元素为ElementOfResult. map: 传入数组元素, 返回新数组, 新数组数组元素和传入元素类型相同. 区别: map: 无论返回什么类型, 再次包装可选项 flatMap: 如果以前是非可选项,会包装成可选项. 如果以前是可选项, 不再包装成可选项. 示例三: compactMap() 函数compactMap() 压缩紧凑: 每次遍历后自动将处理结果解包, 如果结果为空则过滤 var arr = ["123", "test", "jack", "-30"] // [Optional(123), nil, nil, Optional(-30)] var arr2 = arr.map { Int($0) } // [123, -30] var arr3 = arr.compactMap { Int($0) } 示例四: 使用reduce实现map、filter的功能 var arr = [1, 2, 3, 4] // [2, 4, 6, 8] print(arr.map { $0 * 2 }) print(arr.reduce([]) { $0 + [$1 * 2] }) // [2, 4] print(arr.filter { $0 % 2 == 0 }) print(arr.reduce([]) { $1 % 2 == 0 ? $0 + [$1] : $0 }) lazy的优化let arr = [1, 2, 3] let result = arr.lazy.map { (i: Int) -> Int in print("mapping \(i)") return i * 2 } print("begin-----") print("mapped", result[0]) print("mapped", result[1]) print("mapped", result[2]) print("end----") 打印结果 begin----- mapping 1 mapped 2 mapping 2 mapped 4 mapping 3 mapped 6 end---- Optional的map和flatMap示例一: var num1: Int? = 10 // Optional(20) var num2 = num1.map { $0 * 2 } var num3: Int? = nil // nil var num4 = num3.map { $0 * 2 } map() 会将传入值解包. map() 会将返回值包装为 Optional map() 如果返回值为nil, 则不再执行闭包, 返回nil 示例二: var num1: Int? = 10 // Optional(Optional(20)) var num2 = num1.map { Optional.some($0 * 2) } // Optional(20) var num3 = num1.flatMap { Optional.some($0 * 2) } flatMap () 返回值如果已经是Optional, 就不会再次包装.如果返回值不是Optional会包装为Optional. 示例三: var num1: Int? = 10 var num2 = (num1 != nil) ? (num1! + 10) : nil var num3 = num1.map { $0 + 10 } // num2、num3是等价的 示例四: var fmt = DateFormatter() fmt.dateFormat = &quot;yyyy-MM-dd&quot; var str: String? = &quot;2011-09-10&quot; // old var date1 = str != nil ? fmt.date(from: str!) : nil var date2 = str.flatMap { fmt.date(from: $0) } //可简写为 // new var date3 = str.flatMap(fmt.date) 示例五: map替换三目运算符 var score: Int? = 98 // old var str1 = score != nil ? &quot;socre is \(score!)&quot; : &quot;No score&quot; // new var str2 = score.map { &quot;score is \($0)&quot; } ?? &quot;No score&quot; 示例六: struct Person { var name: String var age: Int } var items = [ Person(name: &quot;jack&quot;, age: 20), Person(name: &quot;rose&quot;, age: 21), Person(name: &quot;kate&quot;, age: 22) ] // old func getPerson1(_ name: String) -&gt; Person? { let index = items.firstIndex { $0.name == name } return index != nil ? items[index!] : nil } // new func getPerson2(_ name: String) -&gt; Person? { return items.firstIndex { $0.name == name }.map { items[$0] } } 示例七: struct Person { var name: String var age: Int init?(_ json: [String : Any]) { guard let name = json[&quot;name&quot;] as? String, let age = json[&quot;age&quot;] as? Int else { // 逗号代表两边条件必须同时成立 return nil } self.name = name self.age = age } } var json: Dictionary? = [&quot;name&quot; : &quot;Jack&quot;, &quot;age&quot; : 10] // old var p1 = json != nil ? Person(json!) : nil // new var p2 = json.flatMap(Person.init) 函数式编程（Funtional Programming）1&gt; 函数式编程（Funtional Programming，简称FP）是一种编程范式，也就是如何编写程序的方法论. 主要思想：把计算过程尽量分解成一系列可复用函数的调用 主要特征：函数是“第一等公民” 函数与其他数据类型一样的地位，可以赋值给其他变量，也可以作为函数参数、函数返回值 2&gt; 函数式编程最早出现在LISP语言，绝大部分的现代编程语言也对函数式编程做了不同程度的支持，比如 Haskell、JavaScript、Python、Swift、Kotlin、Scala等 3&gt; 函数式编程中几个常用的概念 Higher-Order Function、Function Currying Functor、Applicative Functor、Monad 参考资料:1.Swift Functors, Applicatives, and Monads in Pictures2.Functors, Applicatives, And Monads In Pictures FP实践 – 传统写法假设要实现以下功能：[(num + 3) * 5 - 1] % 10 / 2 传统写法: var num = 1 func add(_ v1: Int, _ v2: Int) -> Int { v1 + v2 } func sub(_ v1: Int, _ v2: Int) -> Int { v1 - v2 } func multiple(_ v1: Int, _ v2: Int) -> Int { v1 * v2 } func divide(_ v1: Int, _ v2: Int) -> Int { v1 / v2 } func mod(_ v1: Int, _ v2: Int) -> Int { v1 % v2 } divide(mod(sub(multiple(add(num, 3), 5), 1), 10), 2) FP实践 – 函数式写法1) 单个加法运算简化 let num = 1 func add(_ v: Int) -> (Int) -> Int{ return { $0 + v // 3传给v , num传入参数 $0 } } let fn = add(3) fn(num) //可以简写为 add(3)(num) //先接收一个参数, 再接收一个参数 最终简化为: let num = 1 func add(_ v: Int) -> (Int) -> Int{ $0 + v } add(3)(num) //先接收一个参数, 再接收一个参数 2) 定义加 减 乘 除 取模 函数 let num = 1 func add(_ v: Int) -> (Int) -> Int {{ $0 + v }} func sub(_ v: Int) -> (Int) -> Int {{ $0 - v }} func multiple(_ v: Int) -> (Int) -> Int {{ $0 * v }} func divide(_ v: Int) -> (Int) -> Int {{ $0 / v }} func mod(_ v: Int) -> (Int) -> Int {{ $0 % v }} 传统调用依然很繁琐: let fn1 = add(3) let fn2 = multiple(5) let fn3 = sub(1) let fn4 = mod(10) let fn5 = divide(2) //num -&gt; fn1 -&gt; fn2 -&gt; fn3 -&gt; fn4 -&gt; fn5 fn5( fn4( fn3( fn2( fn1(num) ) ) ) ) 4) 函数合成 合成加和乘函数 func composite(_ f1: @escaping (Int) -> Int, _ f2: @escaping(Int) -> Int) -> (Int) -> Int { return { f2( f1($0) ) } } let fn = composite(add(3), multiple(5)) fn(num) //20 自定义运算符, 合成函数 infix operator >>> : AdditionPrecedence func >>> (_ f1: @escaping (Int) -> Int, _ f2: @escaping(Int) -> Int) -> (Int) -> Int{ { f2( f1($0) ) } } let fn = add(3) >>> multiple(5) print( fn(num) ) //20 //所有运算 let fn2 = add(3) >>> multiple(5) >>> sub(1) >>> mod(10) >>> divide(2) print( fn2(num) ) //4 //参数传递: num先传入f1的参数, f1返回值传入f2的参数, f2返回值传出 注意: 柯里化参数类型和返回值类型必须相同才能合并! 即 f1参数 必须和f2参数相同. 函数合成最终简化为: // 函数合成 infix operator >>> : AdditionPrecedence func >>> &lt;A, B, C>(_ f1: @escaping (A) -> B, _ f2: @escaping (B) -> C) -> (A) -> C {{ f2(f1($0)) }} var fn = add(3) >>> multiple(5) >>> sub(1) >>> mod(10) >>> divide(2) fn(num) 高阶函数（Higher-Order Function）高阶函数是至少满足下列一个条件的函数: 接受一个或多个函数作为输入（map、filter、reduce等） 返回一个函数 FP中到处都是高阶函数 func add(_ v: Int) -> (Int) -> Int { { $0 + v } } 柯里化（Currying）1) 什么是柯里化？ 将一个接受多参数的函数变换为一系列只接受单个参数的函数 Array、Optional的map方法接收的参数就是一个柯里化函数 2) 函数柯里化后参数顺序 根据给定函数柯里化 func add1(_ v1: Int, _ v2: Int) -> Int {v1 - v2} func add2(_ v1: Int, _ v2: Int, _ v3: Int) -> Int {v1 - v2 - v3} add1 add2分别柯里化 func add1(_ v2: Int) -> (Int)->Int { {$0 - v2} } //$0 == 20 , v2 == 10 print(add1(10)(20) ) // 10 func add2(_ v3: Int) -> (Int)-> (Int)->Int { //v3 == 10 return { v2 in // v2 == 20 return{ v1 in // v1 == 30 return v1 - v2 - v3 } } } print( add2(10)(20)(30) ) // 0 最终写为: func currying&lt;A, B, C>(_ fn: @escaping (A, B) -> C) -> (B) -> (A) -> C { { b in { a in fn(a, b) } } } func currying&lt;A, B, C, D>(_ fn: @escaping (A, B, C) -> D) -> (C) -> (B) -> (A) -> D { { c in { b in { a in fn(a, b, c) } } } // c = 10 , b = 20 , a = 30 } let curriedAdd1 = currying(add1) print(curriedAdd1(10)(20)) // 20 - 10 let curriedAdd2 = currying(add2) print(curriedAdd2(10)(20)(30)) // 30 - 20 - 10 注意: 如果传入参数有运算顺序的, 柯里化后会和原先传入参数顺序相反. 函数add1 柯里化参数 A == v2, B == v1 函数add2 柯里化参数 A == v3, B == v2, C== v1 包装一次少一次参数, 最后包装剩一个参数就开始计算 3) 自定义运算符实现函数柯里化 func add(_ v1: Int, _ v2: Int) -> Int { v1 + v2 } func sub(_ v1: Int, _ v2: Int) -> Int { v1 - v2 } func multiple(_ v1: Int, _ v2: Int) -> Int { v1 * v2 } func divide(_ v1: Int, _ v2: Int) -> Int { v1 / v2 } func mod(_ v1: Int, _ v2: Int) -> Int { v1 % v2 } 示例函数自定义运算符, 函数转为柯里版本 prefix func ~&lt;A, B, C>(_ fn: @escaping (A, B) -> C) -> (B) -> (A) -> C { { b in { a in fn(a, b) } } } print( (~sub)(20)(10) ) //-10 infix operator >>> : AdditionPrecedence func >>>&lt;A, B, C>(_ f1: @escaping (A) -> B, _ f2: @escaping (B) -> C) -> (A) -> C { { f2(f1($0)) } } var num = 1 var fn = (~add)(3) >>> (~multiple)(5) >>> (~sub)(1) >>> (~mod)(10) >>> (~divide)(2) fn(num) 函子（Functor） 像Array、Optional这样支持map运算的类型，称为函子（Functor） public func map&lt;T>(_ fn: (Inner) -> T) -> Type&lt;T> // Inner是Type里边包装的东西 Array的map // Array&lt;Element> public func map&lt;T>(_ transform: (Element) -> T) -> Array&lt;T> Optional的map // Optional&lt;Wrapped> public func map&lt;U>(_ transform: (Wrapped) -> U) -> Optional&lt;U> 图解: 将包装的2先解包, 加3操作后, 再次包装成盒子返回 图解: 如果盒子是空的, 就不能进行加3操作. 图解: 如果传入一堆包装的数据, 每次会遍历出一个盒子并解包进行加3操作, 操作后再次包装成盒子返回 适用函子（Applicative Functor） 对任意一个函子 F，如果能支持以下运算，该函子就是一个适用函子 func pure&lt;A>(_ value: A) -> F&lt;A> func &lt;*>&lt;A, B>(fn: F&lt;(A) -> B>, value: F&lt;A>) -> F&lt;B> Optional可以成为适用函子 func pure&lt;A>(_ value: A) -> A {value} infix operator &lt;*> : AdditionPrecedence func &lt;*>&lt;A, B>(fn: ((A) -> B)?, value:A? ) -> B? { guard let f = fn, let v = value else { return nil } return f(v) } var value: Int? = 10 var fn:((Int) -> Int)? = { $0 * 2 } // Operator(20) print(fn &lt;*> value as Any) Array可以成为适用函子 func pure&lt;A>(_ value: A) -> [A] { [value] } func &lt;*>&lt;A, B>(fn: [(A) -> B], value: [A]) -> [B] { var arr: [B] = [] if fn.count == value.count { for i in fn.startIndex..&lt;fn.endIndex { arr.append(fn[i](value[i])) } } return arr } // [10] print(pure(10)) var arr = [{ $0 * 2}, { $0 + 10 }, { $0 - 5 }] &lt;*> [1, 2, 3] // [2, 12, -2] print(arr) 单子（Monad） 对任意一个类型 F，如果能支持以下运算，那么就可以称为是一个单子（Monad） func pure&lt;A>(_ value: A) -> F&lt;A> func flatMap&lt;A, B>(_ value: F&lt;A>, _ fn: (A) -> F&lt;B>) -> F&lt;B> 很显然，Array、Optional都是单子]]></content>
      <categories>
        <category>iOS笔记</category>
      </categories>
      <tags>
        <tag>Swift5.1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Swift5.1] 25-Swift 常规用法]]></title>
    <url>%2F2020%2F06%2F09%2FSwift5-1-25-Swift-%E5%B8%B8%E8%A7%84%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[StringSwift的字符串类型String，跟OC的NSString，在API设计上还是有较大差异: // 空字符串 var emptyStr1 = "" var emptyStr2 = String() var str: String = "1" // 拼接，jack_rose str.append("_2") // 重载运算符 + str = str + "_3" // 重载运算符 += str += "_4" // \()插值 str = "\(str)_5" // 长度，9，1_2_3_4_5 print(str.count) var str = "123456" print(str.hasPrefix("123")) // true print(str.hasSuffix("456")) // true String的插入和删除var str = "1_2" print(str.count, str.startIndex, str.endIndex) // 3 Index(_rawBits: 1) Index(_rawBits: 196609) 注意: startIndex代表1后面位置, endIndex 代表2后面位置 insert(&quot;&quot; , at:) 只能插入字符 insert(contentsOf: &quot;&quot;, at: ) 插入字符串 var str = "1_2" // 1_2_ str.insert("_", at: str.endIndex) // 1_2_3_4 str.insert(contentsOf: "3_4", at: str.endIndex) // 1666_2_3_4 str.insert(contentsOf: "666", at: str.index(after: str.startIndex)) // 1666_2_3_8884 str.insert(contentsOf: "888", at: str.index(before: str.endIndex)) // 从startIndex开始偏移4,插入hello str.insert(contentsOf: "hello", at: str.index(str.startIndex, offsetBy: 4)) // 1666hello_2_3_8884 // 删除第一个字符 str.remove(at: str.firstIndex(of: "1")!) // 666hello_2_3_8884 // 删除含有6的字符 str.removeAll { $0 == "6" } //hello_2_3_8884 // 删除范围 var range = str.index(str.endIndex, offsetBy: -4)..&lt;str.index(before: str.endIndex) str.removeSubrange(range) //hello_2_3_4 Substring 子串String可以通过下标、 prefix、 suffix等截取子串，子串类型不是String，而是Substring var str = "1_2_3_4_5" // 截取前3个字符的子串 var substr1 = str.prefix(3) //1_2 // 截取后3个字符的子串 var substr2 = str.suffix(3) // 4_5 // 1_2 从开始截取3个字符 var range = str.startIndex..&lt;str.index(str.startIndex, offsetBy: 3) var substr3 = str[range] // 最初的String，1_2_3_4_5 print(substr3.base) // Substring -> String var str2 = String(substr3) Substring和它的base，共享字符串数据 Substring发生修改 或者 转为String时，会分配新的内存存储字符串数据 String 与 Characterfor c in "jack" { // c是Character类型 print(c) } var str = "jack" // c是Character类型 var c = str[str.startIndex] String相关的协议BidirectionalCollection 协议包含的部分内容: startIndex 、 endIndex 属性、index 方法 String、Array 都遵守了这个协议 RangeReplaceableCollection 协议包含的部分内容: append、insert、remove 方法 String、Array 都遵守了这个协议 Dictionary、Set 也有实现上述协议中声明的一些方法，只是并没有遵守上述协议 多行String多行字符串: 三个双引号开头, 三个双引号结尾的字符串 注意: 字符串内容是按照最后一个三双引号对齐. let str = """ 1 "2" 3 '4' """ print(str) 打印结果: 1 &quot;2&quot; 3 &#39;4&#39; // 以下2个字符串是等价的 let str1 = "These are the same." let str2 = """ These are the same. """ // 如果要显示3引号，至少转义1个引号 let str = """ Escaping the first quote \""" Escaping two quotes \"\"" Escaping all three quotes \"\"\" """ Escaping the first quote """ Escaping two quotes """ Escaping all three quotes """ //缩进以结尾的3引号为对齐线 let str = """ 1 "2" 3 '4' """ print(str) 打印结果: 1 &quot;2&quot; 3 &#39;4&#39; String 与 NSString1&gt; String 与 NSString 之间可以随时随地桥接转换 如果你觉得String的API过于复杂难用，可以考虑将String转为NSString var str1: String = "jack" var str2: NSString = "rose" var str3 = str1 as NSString var str4 = str2 as String // ja var str5 = str3.substring(with: NSRange(location: 0, length: 2)) print(str5) 注意: String 与 NSString 之间桥接后是两个不同类型, 修改内容互补影响. 2&gt; 比较字符串内容是否等价 String使用 == 运算符 NSString使用isEqual方法，也可以使用 == 运算符（本质还是调用了isEqual方法） 3&gt; Swift、OC桥接转换表 String与NSString可以互相桥接转换 String不能桥接转换成NSMutableString 总结: 桥接指的是通过 as as? as! 转换类型 Swift中String \ Array \ Dictionary \ Set可以和OC不可变类型相互桥接转换 OC可变类型可以桥接转换成Swift中对应的 String \ Array \ Dictionary \ Set Swift中 String \ Array \ Dictionary \ Set 桥接转换成OC可变类型. 但可以创建新的可变类型存储内容. var str = "123456" //String 不能桥接转换为 NSMutableString var str2 = str as? NSMutableString // nil var str3 = NSMutableString(string: str) //123456 问题: Person 继承NSObject, 内存是否有变化? class Person :NSObject{ var age = 10 var weight = 20 } var p = Person() 答:Person 继承NSObject, 内存是有变化的. Swift中 p占32个字节: 8个字节 metadata, 8个字节 引用计数相关, 8个字节 age , 8个字节weight OC中 p占32个字节: 8个字节 isa指针, 8个字节 age, 8个字节weight, 最后8个字节凑数 只能被class继承的协议只能被class继承的协议, 如下三种方式: protocol Runnable1: AnyObject {} protocol Runnable2: class {} @objc protocol Runnable3 {} 被 @objc 修饰的协议，还可以暴露给OC去遵守实现 可选协议 可以通过 @objc 定义可选协议，这种协议只能被 class 遵守 还可以通过extension 定义可选协议 @objc protocol Runnable { func run1() @objc optional func run2() func run3() } extension Runnable { func run2() { print("Dog run2") } } class Dog: Runnable { func run3() { print("Dog run3") } func run1() { print("Dog run1") } } var d = Dog() d.run1() // Dog run1 d.run3() // Dog run3 dynamic被 @objc dynamic 修饰的内容会具有动态性，比如调用方法会走runtime那一套流程 class Dog: NSObject { @objc dynamic func test1() {} func test2() {} } var d = Dog() d.test1() d.test2() KVC\KVOSwift 支持 KVC \ KVO 的条件 属性所在的类、监听器最终继承自 NSObject 用 @objc dynamic 修饰对应的属性 class Observer: NSObject { override func observeValue(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?) { print("observeValue", change?[.newKey] as Any) } } class Person: NSObject { @objc dynamic var age: Int = 0 var observer: Observer = Observer() override init() { super.init() self.addObserver(observer, forKeyPath: "age", options: .new, context: nil) } deinit { self.removeObserver(observer, forKeyPath: "age") } } var p = Person() // observeValue Optional(20) p.age = 20 // observeValue Optional(25) p.setValue(25, forKey: "age") block方式的KVOclass Person: NSObject { @objc dynamic var age: Int = 0 var observation: NSKeyValueObservation? override init() { super.init() observation = observe(\Person.age, options: .new) { (person, change) in print(change.newValue as Any) } } } var p = Person() // Optional(20) p.age = 20 // Optional(25) p.setValue(25, forKey: "age") 关联对象（Associated Object） 在Swift中，class依然可以使用关联对象 默认情况，extension不可以增加存储属性 借助关联对象，可以实现类似extension为class增加存储属性的效果 class Person {} extension Person { private static var AGE_KEY: Void? var age: Int { get { (objc_getAssociatedObject(self, &amp;Self.AGE_KEY) as? Int) ?? 0 } set { objc_setAssociatedObject(self, &amp;Self.AGE_KEY, newValue, .OBJC_ASSOCIATION_ASSIGN) } } } var p = Person() print(p.age) // 0 p.age = 10 print(p.age) // 10 资源名管理let img = UIImage(named: "logo") let btn = UIButton(type: .custom) btn.setTitle("添加", for: .normal) performSegue(withIdentifier: "login_main", sender: self) let img = UIImage(R.image.logo) let btn = UIButton(type: .custom) btn.setTitle(R.string.add, for: .normal) performSegue(withIdentifier: R.segue.login_main, sender: self) 这种做法实际上是参考了Android的资源名管理方式 实现原理: enum R { enum string: String { case add = "添加" } enum image: String { case logo } enum segue: String { case login_main } } extension UIImage { convenience init?(_ name: R.image) { self.init(named: name.rawValue) } } extension UIViewController { func performSegue(withIdentifier identifier: R.segue, sender: Any?) { performSegue(withIdentifier: identifier.rawValue, sender: sender) } } extension UIButton { func setTitle(_ title: R.string, for state: UIControl.State) { setTitle(title.rawValue, for: state) } } 资源名管理的其他思路let img = UIImage(named: "logo") let font = UIFont(name: "Arial", size: 14) let img = R.image.logo let font = R.font.arial(14) 实现原理: enum R { enum image { static var logo = UIImage(named: "logo") } enum font { static func arial(_ size: CGFloat) -> UIFont? { UIFont(name: "Arial", size: size) } } } 更多优秀的思路参考https://github.com/mac-cain13/R.swifthttps://github.com/SwiftGen/SwiftGen 多线程开发 – 异步public typealias Task = () -> Void public struct Asyncs { public static func async(_ task: @escaping Task) { _async(task) } public static func async(_ task: @escaping Task, _ mainTask: @escaping Task) { _async(task, mainTask) } private static func _async(_ task: @escaping Task, _ mainTask: Task? = nil) { //DispatchWorkItem(block:) 包装任务 let item = DispatchWorkItem(block: task) DispatchQueue.global().async(execute: item) if let main = mainTask { //item 任务执行完后, 执行notify(), 执行主任务 item.notify(queue: DispatchQueue.main, execute: main) } } } 调用: class ViewController: UIViewController { override func viewDidLoad() { super.viewDidLoad() Asyncs.async { print(1) } Asyncs.async({ print(1, Thread.current) }) { print(2, Thread.current) } } } /* 1 1 &lt;NSThread: 0x600000805c00&gt;{number = 4, name = (null)} 2 &lt;NSThread: 0x600000840e40&gt;{number = 1, name = main} */ 多线程开发 – 延迟asyncAfter() 延迟 @discardableResult public static func delay(_ seconds: Double, _ block: @escaping Task) -> DispatchWorkItem { let item = DispatchWorkItem(block: block) DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + seconds, execute: item) return item } 多线程开发 – 异步延迟@discardableResult public static func asyncDelay(_ seconds: Double, _ task: @escaping Task) -> DispatchWorkItem { return _asyncDelay(seconds, task) } @discardableResult public static func asyncDelay(_ seconds: Double, _ task: @escaping Task, _ mainTask: @escaping Task) -> DispatchWorkItem { return _asyncDelay(seconds, task, mainTask) } private static func _asyncDelay(_ seconds: Double, _ task: @escaping Task, _ mainTask: Task? = nil) -> DispatchWorkItem { let item = DispatchWorkItem(block: task) DispatchQueue.global().asyncAfter(deadline: DispatchTime.now() + seconds, execute: item) if let main = mainTask { item.notify(queue: DispatchQueue.main, execute: main) } return item } 多线程开发 – once dispatch_once在Swift中已被废弃，取而代之 可以用类型属性或者全局变量\常量 默认自带 lazy + dispatch_once 效 果 fileprivate let initTask2: Void = { print("initTask2---------") }() class ViewController: UIViewController { static let initTask1: Void = { print("initTask1---------") }() override func viewDidLoad() { super.viewDidLoad() let _ = Self.initTask1 let _ = initTask2 } } 多线程开发 – 加锁 GCD信号量 class Cache { private static var data = [String: Any]() private static var lock = DispatchSemaphore(value: 1) static func set(_ key: String, _ value: Any) { lock.wait() defer { lock.signal() } data[key] = value } } NSLock() 互斥锁但是有递归调用会死锁 private static var lock = NSLock() static func set(_ key: String, _ value: Any) { lock.lock() defer { lock.unlock() } } NSRecursiveLock() 递归锁 private static var lock = NSRecursiveLock() static func set(_ key: String, _ value: Any) { lock.lock() defer { lock.unlock() } }]]></content>
      <categories>
        <category>iOS笔记</category>
      </categories>
      <tags>
        <tag>Swift5.1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Swift5.1] 24-OC与Swift 混编]]></title>
    <url>%2F2020%2F06%2F09%2FSwift5-1-24-OC%E4%B8%8ESwift-%E6%B7%B7%E7%BC%96%2F</url>
    <content type="text"><![CDATA[MARK、TODO、FIXME// MARK: 类似于OC中的 #pragma mark // MARK: - 类似于OC中的 #pragma mark - // TODO: 用于标记未完成的任务 // FIXME: 用于标记待修复的问题 补充: 使用#warning(“undo”) 标记未做的事情 定义有返回值函数, 如果没写完可以用fatalError()占位 func test() -> Int { #warning("undo") fatalError() } 条件编译// 操作系统：macOS\iOS\tvOS\watchOS\Linux\Android\Windows\FreeBSD #if os(macOS) || os(iOS) // CPU 架 构 ：i386\x86_64\arm\arm64 #elseif arch(x86_64) || arch(arm64) // swift版本 #elseif swift(&lt;5) &amp;&amp; swift(>=3) // 模拟器 #elseif targetEnvironment(simulator) // 可以导入某模块 #elseif canImport(Foundation) #else #endif #if DEBUG // debug模式 #else // release模式 #endif #if TEST print("test") #endif #if OTHER print("other") #endif 打印func log&lt;T>(_ msg: T, file: NSString = #file, line: Int = #line, fn: String = #function) { #if DEBUG let prefix = "\(file.lastPathComponent)_\(line)_\(fn):" print(prefix, msg) #endif } 系统版本检测if #available(iOS 10, macOS 10.12, *) { // 对于iOS平台，只在iOS10及以上版本执行 // 对于macOS平台，只在macOS 10.12及以上版本执行 // 最后的*表示在其他所有平台都执行 } API可用性说明@available(iOS 10, macOS 10.15, *) class Person {} struct Student { @available(*, unavailable, renamed: "study") func study_() {} func study() {} @available(iOS, deprecated: 11) @available(macOS, deprecated: 10.12) func run() {} } 更多用法参考：https://docs.swift.org/swift-book/ReferenceManual/Attributes.html iOS程序的入口 在AppDelegate上面默认有个@UIApplicationMain标记，这表示编译器自动生成入口代码（main函数代码），自动设置AppDelegate为APP的代理 也可以删掉@UIApplicationMain，自定义入口代码：新建一个main.swift文件 // main.swift // TestDemo import UIKit class MyApplication: UIApplication {} UIApplicationMain(CommandLine.argc, CommandLine.unsafeArgv, NSStringFromClass(MyApplication.self), NSStringFromClass(AppDelegate.self)) Swift调用OC 1&gt; 新建1个桥接头文件，文件名格式默认为：{targetName}-Bridging-Header.h 如果直接创建OC类文件, 会提示(如下图)并自动创建 {targetName}-Bridging-Header.h文件 2&gt; 在 {targetName}-Bridging-Header.h 文件中 #import OC需要暴露给Swift的内容 #import &quot;Person.h&quot; Swift调用OC 1&gt; Person.h 代码 int sum(int a, int b); @interface Person : NSObject @property (nonatomic, assign) NSInteger age; @property (nonatomic, copy) NSString *name; - (instancetype)initWithAge:(NSInteger)age name:(NSString *)name; + (instancetype)personWithAge:(NSInteger)age name:(NSString *)name; - (void)run; + (void)run; - (void)eat:(NSString *)food other:(NSString *)other; + (void)eat:(NSString *)food other:(NSString *)other; @end 2&gt; Person.m 代码 @implementation Person - (instancetype)initWithAge:(NSInteger)age name:(NSString *)name { if (self = [super init]) { self.age = age; self.name = name; } return self; } + (instancetype)personWithAge:(NSInteger)age name:(NSString *)name { return [[self alloc] initWithAge:age name:name]; } + (void)run { NSLog(@&quot;Person +run&quot;); } - (void)run { NSLog(@&quot;%zd %@ -run&quot;, _age, _name); } + (void)eat:(NSString *)food other:(NSString *)other { NSLog(@&quot;Person +eat %@ %@&quot;, food, other); } - (void)eat:(NSString *)food other:(NSString *)other { NSLog(@&quot;%zd %@-eat %@ %@&quot;, _age, _name, food, other); } @end int sum(int a, int b) { return a + b; } 3&gt; main.swift 中 swift代码 var p = Person(age: 10, name: "Jack") p.age = 18 p.name = "Rose" p.run() // 18 Rose -run p.eat("Apple", other: "Water") // 18 Rose -eat Apple Water Person.run() // Person +run Person.eat("Pizza", other: "Banana") // Person +eat Pizza Banana print(sum(10, 20)) // 30 Swift调用OC – @_silgen_name应用场景1: 如果C语言暴露给Swift的函数名跟Swift中的其他函数名冲突了 可以在Swift中使用 @_silgen_name 修改C函数名 // C语言 int sum(int a, int b) { return a + b; } // Swift @_silgen_name("sum") func swift_sum(_ v1: Int32, _ v2: Int32) -> Int32 // C语言函数名, 重命名函数 swift_sum print(swift_sum(10, 20)) // 30 print(sum(10, 20)) // 30 应用场景2: _silgen_name可以将系统私有函数重命名后使用. OC调用Swift Xcode已经默认生成一个用于OC调用Swift的头文件，文件名格式是： {targetName}-Swift.h OC项目中如果直接创建swift类文件, 会提示(如下图)并自动创建 {targetName}-Bridging-Header.h文件 1&gt; Car.swift 文件 import Foundation @objcMembers class Car: NSObject { var price: Double var band: String init(price: Double, band: String) { self.price = price self.band = band } func run() { print(price, band, "run") } static func run() { print("Car run") } } extension Car { func test() { print(price, band, "test") } } 2&gt; Swift暴露给OC的类最终继承自NSObject 3&gt; 使用@objc修饰需要暴露给OC的成员 4&gt; 使用@objcMembers修饰类代表默认所有成员都会暴露给OC（包括扩展中定义的成员）最终是否成功暴露，还需要考虑成员自身的访问级别 6&gt; OC代码OC文件中导入#import &quot;Test-Swift.h&quot; #import "Test-Swift.h" int sum(int a, int b) { Car *c = [[Car alloc] initWithPrice:10.5 band:@"BMW"]; c.band = @"Bently"; c.price = 108.5; [c run]; // 108.5 Bently run [c test]; // 108.5 Bently test [Car run]; // Car run return a + b; } OC调用Swift – @objc可以通过 @objc 重命名Swift暴露给OC的符号名（类名、属性名、函数名等） @objc(Car) @objcMembers class Car: NSObject { var price: Double @objc(name) var band: String init(price: Double, band: String) { self.price = price self.band = band } @objc(drive) func run() { print(price, band, "run") } static func run() { print("Car run") } } extension Car { @objc(exec:v2:) func test() { print(price, band, "test") } } Car *c = [[Car alloc] initWithPrice:10.5 band:@&quot;BMW&quot;]; c.name = @&quot;Bently&quot;; c.price = 108.5; [c drive]; // 108.5 Bently run [c exec:10 v2:20]; // 108.5 Bently test [Car run]; // Car run 思考:1.为什么Swfit暴露给OC类最终要继承自NSObject?答:OC依赖于runtime机制,runtime要求类有isa指针, 使用消息传递机制就需要继承自NSObject 2.p.run()底层是怎么调用的?反过来,OC调用Swift底层又是如何调用?答:运行runtime机制, 执行obj_msgSend 3.car.run()底层是怎么调用的?答:swift中, 调用暴露给OC类的方法,使用虚表.如果实在要用OC的runtime机制, 可以在方法前加dynamic关键字. 选择器（Selector） Swift中依然可以使用选择器，使用#selector(name)定义一个选择器 必须是被@objcMembers或@objc修饰的方法才可以定义选择器 @objcMembers class Person: NSObject { func test1(v1: Int) { print("test1") } func test2(v1: Int, v2: Int) { print("test2(v1:v2:)") } func test2(_ v1: Double, _ v2: Double) { print("test2(_:_:)") } func run() { perform(#selector(test1)) perform(#selector(test1(v1:))) perform(#selector(test2(v1:v2:))) perform(#selector(test2(_:_:))) perform(#selector(test2 as (Double, Double) -> Void)) } }]]></content>
      <categories>
        <category>iOS笔记</category>
      </categories>
      <tags>
        <tag>Swift5.1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Swift5.1] 23-模式匹配]]></title>
    <url>%2F2020%2F06%2F08%2FSwift5-1-23-%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%2F</url>
    <content type="text"><![CDATA[什么是模式？ 模式是用于匹配的规则，比如switch的case、捕捉错误的catch、if\guard\while\for语句的条件等 Swift中的模式有: 通配符模式（Wildcard Pattern） 标识符模式（Identifier Pattern） 值绑定模式（Value-Binding Pattern） 元组模式（Tuple Pattern） 枚举Case模式（Enumeration Case Pattern） 可选模式（Optional Pattern） 类型转换模式（Type-Casting Pattern） 表达式模式（Expression Pattern） 通配符模式（Wildcard Pattern） _ 匹配任何值 _? 匹配非nil值 enum Life { case human(name: String, age: Int?) case animal(name: String, age: Int?) } func check(_ life: Life) { switch life { case .human(let name, _): print("human", name) case .animal(let name, _?): print("animal", name) default: print("other") } } check(.human(name: "Rose",age: 20)) // human Rose check(.human(name: "Jack",age: nil)) // human Jack check(.animal(name: "Dog",age: 5)) // animal Dog check(.animal(name: "Cat",age: nil)) // other 标识符模式（Identifier Pattern） 给对应的变量、常量名赋值 var age = 10 let name = "jack" 值绑定模式（Value-Binding Pattern） 将元组point 值绑定到 元组 (x, y)中 let point = (3, 2) switch point { case let (x, y): print("The point is at (\(x), \(y)).") } 元组模式（Tuple Pattern）let points = [(0, 0), (1, 0), (2, 0)] for (x, _) in points { print(x) } let name: String? = "jack" let age = 18 let info: Any = [1, 2] switch (name, age, info) { case (_?, _ , _ as String): print("case") default: print("default") } // default var scores = ["jack" : 98, "rose" : 100, "kate" : 86] for (name, score) in scores { print(name, score) } 枚举Case模式（Enumeration Case Pattern）if case语句等价于只有1个case的switch语句 示例一: let age = 2 // 原来的写法 if age >= 0 &amp;&amp; age &lt;= 9 { print("[0, 9]") } // 枚举Case模式 if case 0...9 = age { print("[0, 9]") } guard case 0...9 = age else { return } print("[0, 9]") 等价于: switch age { case 0...9: print("[0, 9]") default: break } 示例二: let ages: [Int?] = [2, 3, nil, 5] for case nil in ages { print("有nil值") break } // 有nil值 示例三: let points = [(1, 0), (2, 1), (3, 0)] for case let (x, 0) in points { print(x) } // 1 3 可选模式（Optional Pattern） 示例一: let age: Int? = 42 if case .some(let x) = age { print(x) } //可选类型本质是枚举 //上行代码等价于下行 if case let x? = age { print(x) } 将age解包赋值给x, 打印x 示例二: let ages: [Int?] = [nil, 2, 3, nil, 5] for case let age? in ages { print(age) } // 2 3 5 将数组ages中元素取出,与age进行匹配,非空的话解包并打印 示例三: let ages: [Int?] = [nil, 2, 3, nil, 5] for item in ages { if let age = item { print(age) } } // 跟上面的for，效果是等价的 示例四: func check(_ num: Int?) { switch num { case 2?:print("2") case 4?:print("4") case 6?: print("6") case _?: print("other") case _: print("nil") } } check(4) // 4 check(8) // other check(nil) // nil 类型转换模式（Type-Casting Pattern） 示例一: let num: Any = 6 switch num { case is Int: // 编译器依然认为num是Any类型 print("is Int", num) // case let n as Int: // print("as Int", n + 1) default: break } is只是判断num是否Int类型, num依然是Any类型as可以强转为Int类型 示例二: class Animal { func eat() { print(type(of: self), "eat") } } class Dog : Animal { func run() { print(type(of: self), "run") } } class Cat : Animal { func jump() { print(type(of: self), "jump") } } func check(_ animal: Animal) { switch animal { case let dog as Dog: dog.eat() dog.run() case is Cat: animal.eat() (animal as? Cat)?.jump() //调用Car 的jump default: break } } // Dog eat // Dog run check(Dog()) // Cat eat check(Cat()) 表达式模式（Expression Pattern）表达式模式用在 case中 let point = (1, 2) switch point { case (0, 0): print("(0, 0) is at the origin.") case (-2...2, -2...2): print("(\(point.0), \(point.1)) is near the origin.") default: print("The point is at (\(point.0), \(point.1)).") } // (1, 2) is near the origin. 自定义表达式模式可以通过重载运算符，自定义表达式模式的匹配规则 struct Student { var score = 0, name = "" static func ~= (pattern: Int, value: Student) -> Bool { value.score >= pattern } static func ~= (pattern: ClosedRange&lt;Int>, value: Student) -> Bool { pattern.contains(value.score) } static func ~= (pattern: Range&lt;Int>, value: Student) -> Bool { pattern.contains(value.score) } } pattern是case后内容, value 是switch后边内容, 示例一: var stu = Student(score: 75, name: "Jack") switch stu { case 100: print(">= 100") case 90: print(">= 90") case 80..&lt;90: print("[80, 90)") case 60...79: print("[60, 79]") case 0: print(">= 0") default: break } // [60, 79] 示例二: if case 60 = stu { print(">= 60") } // >= 60 示例三: var info = (Student(score: 70, name: &quot;Jack&quot;), &quot;及格&quot;) switch info { case let (60, text): print(text) default: break } // 及格 示例四: extension String { static func ~= (pattern: (String) -> Bool, value: String) -> Bool { pattern(value) } } func hasPrefix(_ prefix: String) -> ((String) -> Bool) {{ $0.hasPrefix(prefix) }} func hasSuffix(_ suffix: String) -> ((String) -> Bool) {{ $0.hasSuffix(suffix) }} var str = "jack" switch str { case hasPrefix("j"), hasSuffix("k"): print("以j开头，以k结尾") default: break } // 以j开头，以k结尾 示例五: func isEven(_ i: Int) -> Bool { i % 2 == 0 } func isOdd(_ i: Int) -> Bool { i % 2 != 0 } extension Int{ static func ~= (pattern: (Int) -> Bool, value: Int) -> Bool{ pattern(value) } } var age = 9 switch age { case isEven: print("偶数") case isOdd: print("奇数") default: print("其他") } 示例六: 自定义运算符 prefix operator ~> prefix operator ~>= prefix operator ~&lt; prefix operator ~&lt;= prefix func ~> (_ i: Int) -> ((Int) -> Bool) {{ $0 > i }} prefix func ~>= (_ i: Int) -> ((Int) -> Bool) {{ $0 >= i }} prefix func ~&lt; (_ i: Int) -> ((Int) -> Bool) {{ $0 &lt; i }} prefix func ~&lt;= (_ i: Int) -> ((Int) -> Bool) {{ $0 &lt;= i="" }}="" &lt;="" code="">&lt;/=> var age = 9 switch age { case ~>=0: print("1") case ~>10: print("2") default: break } // [0, 10] where可以使用where为模式匹配增加匹配条件 示例一: 在case后边使用 var data = (10, "Jack") switch data { case let (age, _) where age > 10: print(data.1, "age>10") case let (age, _) where age > 0: print(data.1, "age>0") default: break } 示例二: 在for循环中使用 var ages = [10, 20, 44, 23, 55] for age in ages where age > 30 { print(age) } // 44 55 示例三: 在关联类型后面使用 protocol Stackable { associatedtype Element } protocol Container { associatedtype Stack : Stackable where Stack.Element : Equatable } 示例四: 在函数返回值后面使用 func equal&lt;S1: Stackable, S2: Stackable>(_ s1: S1, _ s2: S2) -> Bool where S1.Element == S2.Element, S1.Element : Hashable { return false } 示例五: 带条件的扩展 extension Container where Self.Stack.Element : Hashable { }]]></content>
      <categories>
        <category>iOS笔记</category>
      </categories>
      <tags>
        <tag>Swift5.1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Swift5.1] 22-字面量]]></title>
    <url>%2F2020%2F06%2F08%2FSwift5-1-22-%E5%AD%97%E9%9D%A2%E9%87%8F%2F</url>
    <content type="text"><![CDATA[字面量var age = 10 var isRed = false var name = &quot;Jack&quot; 上面代码中的10、false、”Jack”就是字面量 常见字面量的默认类型 public typealias IntegerLiteralType = Int public typealias FloatLiteralType = Double public typealias BooleanLiteralType = Bool public typealias StringLiteralType = String // 可以通过typealias修改字面量的默认类型 typealias FloatLiteralType = Float typealias IntegerLiteralType = UInt8 var age = 10 // UInt8 var height = 1.68 // Float Swift自带的绝大部分类型，都支持直接通过字面量进行初始化 Bool、Int、Float、Double、String、Array、Dictionary、Set、Optional等 字面量协议Swift自带类型之所以能够通过字面量初始化，是因为它们遵守了对应的协议: Bool : ExpressibleByBooleanLiteral Int : ExpressibleByIntegerLiteral Float、Double : ExpressibleByIntegerLiteral、ExpressibleByFloatLiteral Dictionary : ExpressibleByDictionaryLiteral String : ExpressibleByStringLiteral Array、Set : ExpressibleByArrayLiteral Optional : ExpressibleByNilLiteral var b: Bool = false // ExpressibleByBooleanLiteral var i: Int = 10 // ExpressibleByIntegerLiteral var f0: Float = 10 // ExpressibleByIntegerLiteral var f1: Float = 10.0 // ExpressibleByFloatLiteral var d0: Double = 10 // ExpressibleByIntegerLiteral var d1: Double = 10.0 // ExpressibleByFloatLiteral var s: String = "jack" // ExpressibleByStringLiteral var arr: Array = [1, 2, 3] // ExpressibleByArrayLiteral var set: Set = [1, 2, 3] // ExpressibleByArrayLiteral var dict: Dictionary = ["jack" : 60] // ExpressibleByDictionaryLiteral var o: Optional&lt;Int> = nil // ExpressibleByNilLiteral 字面量协议应用 Int 赋值Bool类型值 extension Int : ExpressibleByBooleanLiteral { public init(booleanLiteral value: Bool) { self = value ? 1 : 0 } } var num: Int = true print(num) // 1 有点类似于C++中的转换构造函数 class Student : ExpressibleByIntegerLiteral, ExpressibleByFloatLiteral, ExpressibleByStringLiteral, CustomStringConvertible { var name: String = "" var score: Double = 0 required init(floatLiteral value: Double) { self.score = value } required init(integerLiteral value: Int) { self.score = Double(value) } required init(stringLiteral value: String) { self.name = value } required init(unicodeScalarLiteral value: String) { self.name = value } required init(extendedGraphemeClusterLiteral value: String) { self.name = value } var description: String { "name=\(name),score=\(score)" } } var stu: Student = 90 print(stu) // name=,score=90.0 stu = 98.5 print(stu) // name=,score=98.5 stu = "Jack" print(stu) // name=Jack,score=0.0 struct Point { var x = 0.0, y = 0.0 } extension Point : ExpressibleByArrayLiteral, ExpressibleByDictionaryLiteral { init(arrayLiteral elements: Double...) { guard elements.count > 0 else { return } self.x = elements[0] guard elements.count > 1 else { return } self.y = elements[1] } init(dictionaryLiteral elements: (String, Double)...) { for (k, v) in elements { if k == "x" { self.x = v } else if k == "y" { self.y = v } } } } var p: Point = [10.5, 20.5] print(p) // Point(x:10.5, y: 20.5) p = ["x": 11, "y" :22] print(p) // Point(x:11.0, y: 22.0)]]></content>
      <categories>
        <category>iOS笔记</category>
      </categories>
      <tags>
        <tag>Swift5.1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Swift5.1] 21-指针]]></title>
    <url>%2F2020%2F06%2F07%2FSwift5-1-21-%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[指针Swift中也有专门的指针类型，这些都被定性为“Unsafe”（不安全的），常见的有以下4种类型: UnsafePointer&lt;Pointee&gt; 类似于 const Pointee * UnsafeMutablePointer&lt;Pointee&gt; 类似于 Pointee * UnsafeRawPointer 类似于 const void * UnsafeMutableRawPointer 类似于 void * UnsafePointer和UnsafeMutablePointer指针可以通过pointee属性获取指针指向内存地址的值, 并访问或者修改该值. var age = 10 func test1(_ ptr: UnsafeMutablePointer&lt;Int>) { // int * ptr.pointee += 10 } func test2(_ ptr: UnsafePointer&lt;Int>) { // const int * print(ptr.pointee) } test1(&amp;age) test2(&amp;age) // 20 print(age) // 20 UnsafeMutableRawPointer指针通过storeBytes(of: as:) 存储数据. UnsafeRawPointer指针通过load(as:)访问数据. var age = 10 func test3(_ ptr: UnsafeMutableRawPointer) { // void * ptr.storeBytes(of: 20, as: Int.self) } func test4(_ ptr: UnsafeRawPointer) { // const void * print(ptr.load(as: Int.self)) } test3(&amp;age) test4(&amp;age) // 20 print(age) // 20 指针的应用示例var arr = NSArray(objects: 11, 22, 33, 44) arr.enumerateObjects { (obj, idx, stop) in print(idx, obj) if idx == 2 { // 下标为2就停止遍历 stop.pointee = true } } swift推荐遍历使用enumerated, 从(idx, obj) 元组中获取索引和值 var arr = NSArray(objects: 11, 22, 33, 44) for (idx, obj) in arr.enumerated() { print(idx, obj) if idx == 2 { break } } 获得指向某个变量的指针 withUnsafeMutablePointer(to:) { $0 } withUnsafePointer(to:) { $0 } var age = 11 var ptr1 = withUnsafeMutablePointer(to: &amp;age) { $0 } var ptr2 = withUnsafePointer(to: &amp;age) { $0 } ptr1.pointee = 22 print(ptr2.pointee) // 22 print(age) // 22 var ptr3 = withUnsafeMutablePointer(to: &amp;age) { UnsafeMutableRawPointer($0) } var ptr4 = withUnsafePointer(to: &amp;age) { UnsafeRawPointer($0) } ptr3.storeBytes(of: 33, as: Int.self) print(ptr4.load(as: Int.self)) // 33 print(age) // 33 获得指向堆空间实例的指针class Person {} var person = Person() var ptr = withUnsafePointer(to: &amp;person) { UnsafeRawPointer($0) } var heapPtr = UnsafeRawPointer(bitPattern: ptr.load(as: UInt.self)) //ptr.load(as: UInt.self) 堆空间person对象地址值 print(heapPtr!) // 0x000000010055b5d0 ptr指向person指针变量,等价于person本身,存储person地址值 bitPattern: 传入内存地址, heapPtr存储传入的地址 var age = 11 //值类型 var ptr2 = withUnsafePointer(to: &amp;age) { $0 } //ptr2.pointee == age print(ptr2) // 0x00000001000031b0 创建指针1)指定内存创建指针var ptr = UnsafeRawPointer(bitPattern: 0x100001234) 2)malloc方式创建指针// 创建 var ptr = malloc(16) // 堆空间分配16个字节 // 存 ptr?.storeBytes(of: 11, as: Int.self) ptr?.storeBytes(of: 22, toByteOffset: 8, as: Int.self) // toByteOffset 偏移量, 从ptr开始偏移8个字节,后8个字节存储Int类型 22 // 取 print((ptr?.load(as: Int.self))!) // 11 print((ptr?.load(fromByteOffset: 8, as: Int.self))!) // 22 // 销毁 free(ptr) 3)allocate方式创建指针 注意:只有UnsafeMutableRawPointer 和 UnsafeMutablePointer 才可以调用 allocate分配内存. UnsafeMutableRawPointer调用allocate var ptr = UnsafeMutableRawPointer.allocate(byteCount: 16, alignment: 1) // 存储 ptr.storeBytes(of: 11, as: Int.self) // 指针偏移8个字节,存储Int类型 22 ptr.advanced(by: 8).storeBytes(of: 22, as: Int.self) // 取 print(ptr.load(as: Int.self)) // 11 print(ptr.advanced(by: 8).load(as: Int.self)) // 22 //释放 ptr.deallocate() UnsafeMutablePointer 调用allocate泛型指针,建议使用initialize初始化指针注意:该方式一定要调用deinitialize(count:)和deallocate ()销毁对象,否则产生内存泄漏. 反初始化deinitialize(count:)和allocate(capacity:)对应. //创建 //有泛型Int , 只需要写容量即可. capacity 表示申请 3* 8 = 24个字节 var ptr = UnsafeMutablePointer&lt;Int>.allocate(capacity: 3) //存储 ptr.initialize(to: 11) //初始化前8个字节 ptr.successor().initialize(to: 22) //下一个Int 初始化22 ptr.successor().successor().initialize(to: 33) //取值方式一: print(ptr.pointee) // 11 print((ptr + 1).pointee) //22 print((ptr + 2).pointee) //33 //取值方式二: print(ptr[0]) //11 print(ptr[1]) //22 print(ptr[2]) //33 //取值方式三 等价于 方式一和二 print(ptr.pointee) print(ptr.successor().pointee) print(ptr.successor().successor().pointee) //销毁 ptr.deinitialize(count: 3) //反初始化, deinitialize(count:)和allocate(capacity:) 对应 ptr.deallocate() 示例: 创建3个指针指向的Person对象 class Person { var age: Int var name: String init(age: Int, name: String) { self.age = age self.name = name } deinit { print(name, "deinit") } } var ptr = UnsafeMutablePointer&lt;Person>.allocate(capacity: 3) ptr.initialize(to: Person(age: 10, name: "Jack")) (ptr + 1).initialize(to: Person(age: 11, name: "Rose")) (ptr + 2).initialize(to: Person(age: 12, name: "Kate")) // Jack deinit // Rose deinit // Kate deinit ptr.deinitialize(count: 3) ptr.deallocate() 指针之间的转换 assumingMemoryBound(to:) 可以将RawPointer 非泛型指针转为 泛型指针 //创建非泛型指针 var ptr = UnsafeMutableRawPointer.allocate(byteCount: 16, alignment: 1) ptr.assumingMemoryBound(to: Int.self).pointee = 11 //非泛型指针 + 8 , 就是偏移8个字节 (ptr + 8).assumingMemoryBound(to: Double.self).pointee = 22.0 print(unsafeBitCast(ptr, to: UnsafePointer&lt;Int>.self).pointee) // 11 print(unsafeBitCast(ptr + 8, to: UnsafePointer&lt;Double>.self).pointee) // 22.0 ptr.deallocate() unsafeBitCast原理: unsafeBitCast是忽略数据类型的强制转换，不会因为数据类型的变化而改变原来的内存数据.(简单说: 直接将二进制数据搬过去, 只是类型发生改变) 类似于C++中的reinterpret_cast class Person {} var person = Person() var ptr = unsafeBitCast(person, to: UnsafeRawPointer.self) print(ptr)]]></content>
      <categories>
        <category>iOS笔记</category>
      </categories>
      <tags>
        <tag>Swift5.1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Swift5.1] 20-内存管理]]></title>
    <url>%2F2020%2F06%2F07%2FSwift5-1-20-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[内存管理跟OC一样，Swift也是采取基于引用计数的ARC内存管理方案（针对堆空间）. Swift的ARC中有3种引用:1)强引用（strong reference）：默认情况下，引用都是强引用 2)弱引用（weak reference）：通过weak定义弱引用 必须是可选类型的var，因为实例销毁后，ARC会自动将弱引用设置为nil ARC自动给弱引用设置nil时，不会触发属性观察器 3)无主引用（unowned reference）：通过unowned定义无主引用. 不会产生强引用，实例销毁后仍然存储着实例的内存地址（类似于OC中的unsafe_unretained） 试图在实例销毁后访问无主引用，会产生运行时错误（野指针）Fatal error: Attempted to read an unowned reference but object 0x0 was already deallocated weak、unowned的使用限制 weak、unowned只能用在类实例上面 protocol Livable : AnyObject {} class Person {} weak var p0: Person? weak var p1: AnyObject? weak var p2: Livable? unowned var p10: Person? unowned var p11: AnyObject? unowned var p12: Livable? Autoreleasepoolpublic func autoreleasepool&lt;Result>(invoking body: () throws -> Result) rethrows -> Result autoreleasepool { let p = MJPerson(age: 20, name: "Jack") p.run() } 循环引用（Reference Cycle） weak、unowned 都能解决循环引用的问题，unowned 要比 weak 少一些性能消耗 在生命周期中可能会变为 nil 的使用weak 初始化赋值后再也不会变为 nil 的使用 unowned 闭包的循环引用 闭包表达式默认会对用到的外层对象产生额外的强引用（对外层对象进行了retain操作） 下面代码会产生循环引用，导致Person对象无法释放（看不到Person的deinit被调用） class Person { var fn: (() -> ())? func run() { print("run") } deinit { print("deinit") } } func test() { let p = Person() p.fn = { p.run() } } test() 解决闭包的循环引用:在闭包表达式的捕获列表声明weak或unowned引用，解决循环引用问题 p.fn = { [weak p] in p?.run() } p.fn = { [unowned p] in p.run() } 捕获列表可以定义新的名称 p.fn = { [weak wp = p, unowned up = p, a = 10 + 20] in wp?.run() } 闭包的self 1)如果想在定义闭包属性的同时引用self，这个闭包必须是lazy的（因为在实例初始化完毕之后才能引用self） class Person { lazy var fn: (() -> ()) = { [weak self] in self?.run() } func run() { print("run") } deinit { print("deinit") } } func test(){ var p = Person() p.fn() } test() 左边的闭包fn内部如果用到了实例成员（属性、方法） 编译器会强制要求明确写出self 2)如果lazy属性是闭包调用的结果，那么不用考虑循环引用的问题（因为闭包调用后，闭包的生命周期就结束了） class Person { var age: Int = 0 //getAge本质是Int类型, 不是闭包 lazy var getAge: Int = { self.age }() deinit { print("deinit") } } func test(){ var p = Person() print(p.getAge) } test() @escaping非逃逸闭包、逃逸闭包，一般都是当做参数传递给函数: 非逃逸闭包：闭包调用发生在函数结束前，闭包调用在函数作用域内 逃逸闭包：闭包有可能在函数结束后调用，闭包调用逃离了函数的作用域，需要通过@escaping声明 import Dispatch typealias Fn = () -> () // fn是非逃逸闭包 func test1(_ fn: Fn) { fn() } // fn是逃逸闭包 var gFn: Fn? func test2(_ fn: @escaping Fn) { gFn = fn } // fn是逃逸闭包 func test3(_ fn: @escaping Fn) { DispatchQueue.global().async { fn() } } class Person { var fn: Fn // fn是逃逸闭包 init(fn: @escaping Fn) { self.fn = fn } func run() { // DispatchQueue.global().async也是一个逃逸闭包 // 它用到了实例成员（属性、方法），编译器会强制要求明确写出self DispatchQueue.global().async { self.fn() //如果Person对象销毁不再执行闭包,可以这样写 //[weak weakSelf = self] in //weakSelf?.fn() } } } 逃逸闭包的注意点 逃逸闭包不可以捕获inout参数 typealias Fn = () -> () func other1(_ fn: Fn) { fn() } func other2(_ fn: @escaping Fn) { fn() } func test(value: inout Int) -> Fn { other1 { value += 1 } // error: 逃逸闭包不能捕获inout参数 other2 { value += 1 } func plus() { value += 1 } // error: 逃逸闭包不能捕获inout参数 return plus } 内存访问冲突（Conflicting Access to Memory）内存访问冲突会在两个访问满足下列条件时发生：(在全局作用域中) 至少一个是写入操作 它们访问的是同一块内存 它们的访问时间重叠（比如在同一个函数内） // 不存在内存访问冲突 func plus(_ num: inout Int) -> Int { num + 1 } var number = 1 number = plus(&amp;number) 存在内存访问冲突 // 存在内存访问冲突 // Simultaneous accesses to 0x0, but modification requires exclusive access var step = 1 func increment(_ num: inout Int) { num += step } increment(&amp;step) 解决内存访问冲突 // 解决内存访问冲突 var copyOfStep = step increment(&amp;copyOfStep) step = copyOfStep 内存访问冲突示例1)同时访问同一变量内存地址 func balance(_ x: inout Int, _ y: inout Int) { let sum = x + y x = sum / 2 y = sum - x } var num1 = 42 var num2 = 30 balance(&amp;num1, &amp;num2) // OK balance(&amp;num1, &amp;num1) // Error 2)同时访问同一对象属性内存地址 struct Player { var name: String var health: Int var energy: Int mutating func shareHealth(with teammate: inout Player) { balance(&amp;teammate.health, &amp;health) } } var oscar = Player(name: "Oscar", health: 10, energy: 10) var maria = Player(name: "Maria", health: 5, energy: 10) oscar.shareHealth(with: &amp;maria) // OK oscar.shareHealth(with: &amp;oscar) // Error //同时访问同一对象属性health内存地址 3)同时访问同一元组内存地址 var tulpe = (health: 10, energy: 20) // Error balance(&amp;tulpe.health, &amp;tulpe.energy) var holly = Player(name: "Holly", health: 10, energy: 10) // Error balance(&amp;holly.health, &amp;holly.energy) //health和energy在元组中属于同一块内存 内存访问冲突示例二如果下面的条件可以满足，就说明重叠访问结构体的属性是安全的:(在局部作用域中) 你只访问实例存储属性，不是计算属性或者类属性 结构体是局部变量而非全局变量 结构体要么没有被闭包捕获要么只被非逃逸闭包捕获 // Ok func test() { var tulpe = (health: 10, energy: 20) balance(&amp;tulpe.health, &amp;tulpe.energy) var holly = Player(name: "Holly", health: 10, energy: 10) balance(&amp;holly.health, &amp;holly.energy) } test()]]></content>
      <categories>
        <category>iOS笔记</category>
      </categories>
      <tags>
        <tag>Swift5.1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Swift5.1] 19-访问控制]]></title>
    <url>%2F2020%2F06%2F07%2FSwift5-1-19-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[访问控制（Access Control）在访问权限控制这块，Swift提供了5个不同的访问级别:（以下是从高到低排列， 实体指被访问级别修饰的内容） open：允许在定义实体的模块、其他模块中访问，允许其他模块进行继承、重写（open只能用在类、类成员上） public：允许在定义实体的模块、其他模块中访问，不允许其他模块进行继承、重写 internal：只允许在定义实体的模块中访问，不允许在其他模块中访问 fileprivate：只允许在定义实体的源文件中访问 private：只允许在定义实体的封闭声明中访问 绝大部分实体默认都是 internal 级别 访问级别的使用准则一个实体不可以被更低访问级别的实体定义，比如:(左边定义右边, 左边访问级别大于等于右边访问级别) 变量\常量类型 ≥ 变量\常量 (示例一) 参数类型、返回值类型 ≥ 函数 (示例二) 父类 ≥ 子类 父协议 ≥ 子协议 原类型 ≥ typealias (示例三) 原始值类型、关联值类型 ≥ 枚举类型 (示例四) 定义类型A时用到的其他类型 ≥ 类型A (示例五)…… //示例一: fileprivate class Person {} internal var person : Person //编译错误: Variable cannot be declared internal because its type uses a fileprivate type //示例二: internal func test(_ num: Int) -> Double{ } //参数类型Int Double为系统类型, 相当于public //示例三: class Person{ } fileprivate typealias MyPerson = Person //Person默认 internal, internal > fileprivate //示例四: fileprivate typealias MyInt = Int fileprivate typealias MyString = String enum Scroe{ case point(Int) case grade(String) } // 改为下面代码, 编译错误 enum Scroe{ case point(MyInt) // ❌Enum case in an internal enum uses a fileprivate type case grade(MyString) //❌Enum case in an internal enum uses a fileprivate type } //示例五 struct Dog{ } class Person { var age: Int var dog: Dog } //用到的类型Int , Dog一定要大于等于Person访问级别 元组类型 元组类型的访问级别是所有成员类型最低的那个 internal struct Dog {} fileprivate class Person {} // (Dog, Person)的访问级别是fileprivate fileprivate var data1: (Dog, Person) private var data2: (Dog, Person) 泛型类型泛型类型的访问级别是 类型的访问级别 以及 所有泛型类型参数的访问级别 中最低的那个 internal class Car {} fileprivate class Dog {} public class Person&lt;T1, T2> {} // Person&lt;Car, Dog>的访问级别是fileprivate fileprivate var p = Person&lt;Car, Dog>() 成员、嵌套类型 类型的访问级别会影响成员（属性、方法、初始化器、下标）、嵌套类型的默认访问级别 一般情况下，类型为private或fileprivate，那么成员\嵌套类型默认也是private或fileprivate 一般情况下，类型为internal或public，那么成员\嵌套类型默认是internal 如果在类中明确成员\嵌套类型写 private或fileprivate, 那么成员\嵌套类型,只能在当前类中访问,不能在外部调用 public class PublicClass { public var p1 = 0 // public var p2 = 0 // internal fileprivate func f1() {} // fileprivate private func f2() {} // private } class InternalClass { // internal var p = 0 // internal fileprivate func f1() {} // fileprivate private func f2() {} // private } fileprivate class FilePrivateClass { // fileprivate func f1() {} // fileprivate private func f2() {} // private } private class PrivateClass { // private func f() {} // private } 成员的重写 子类重写成员的访问级别必须 ≥ 子类的访问级别，或者 ≥ 父类被重写成员的访问级别 父类的成员不能被成员作用域外定义的子类重写 public class Person { private var age: Int = 0 public class Student : Person { override var age: Int { set {} get {10} } } } 下面代码能否编译通过？private class Person {} fileprivate class Student : Person {} private struct Dog { var age: Int = 0 func run() {} } fileprivate struct Person { var dog: Dog = Dog() mutating func walk() { dog.run() dog.age = 1 } } private struct Dog { private var age: Int = 0 private func run() {} } fileprivate struct Person { var dog: Dog = Dog() mutating func walk() { dog.run() dog.age = 1 } } 直接在全局作用域下定义的private等价于fileprivate 分情况:1.在局部作用域中,编译不通过2.在全局作用域中可以通过 getter、setter getter、setter默认自动接收它们所属环境的访问级别 可以给setter单独设置一个比getter更低的访问级别，用以限制写的权限 fileprivate(set) public var num = 10 class Person { private(set) var age = 0 fileprivate(set) public var weight: Int { set {} get { 10 } } internal(set) public subscript(index: Int) -> Int { set {} get { index } } } 初始化器 如果一个public类想在另一个模块调用编译生成的默认无参初始化器，必须显式提供public的无参初始化器. 因为public类的默认初始化器是internal级别. internal初始化器不能在其他模块调用. required初始化器 ≥ 它的默认访问级别 如果结构体有private \ fileprivate的存储实例属性，那么它的成员初始化器也是private \ fileprivate 否则默认就是internal 枚举类型的case 不能给enum的每个case单独设置访问级别 每个case自动接收enum的访问级别 public enum定义的case也是public 协议 协议中定义的要求自动接收协议的访问级别，不能单独设置访问级别 public协议定义的要求也是public 协议实现的访问级别必须 ≥ 类型的访问级别，或者 ≥ 协议的访问级别(实现协议方法, 属性的访问级别要至少大于等于 协议访问级别或者 类的访问级别 ) 下面代码能编译通过么？ public protocol Runnable { func run() } public class Person : Runnable { func run() {} //public 类的方法默认访问级别 internal } 扩展 如果有显式设置扩展的访问级别，扩展添加的成员自动接收扩展的访问级别 如果没有显式设置扩展的访问级别，扩展添加的成员的默认访问级别，跟直接在类型中定义的成员一样 可以单独给扩展添加的成员设置访问级别 不能给用于遵守协议的扩展显式设置扩展的访问级别 在同一文件中的扩展，可以写成类似多个部分的类型声明.1)在原本的声明中声明一个私有成员，可以在同一文件的扩展中访问它2)在扩展中声明一个私有成员，可以在同一文件的其他扩展中、原本声明中访问它 下面三段代码在同一个文件中: public class Person { private func run0() {} private func eat0() { run1() } } extension Person { private func run1() {} private func eat1() { run0() } } extension Person { private func eat2() { run1() } } 将方法赋值给var\let方法也可以像函数那样，赋值给一个let或者var. struct Person { var age: Int func run(_ v: Int) { print("func run", age, v) } static func run(_ v: Int) { print("static func run", v) } } let fn1 = Person.run fn1(10) // static func run 10 let fn2: (Int) -> () = Person.run fn2(20) // static func run 20 let fn3: (Person) -> ((Int) -> ()) = Person.run fn3(Person(age: 18))(30) // func run 18 30]]></content>
      <categories>
        <category>iOS笔记</category>
      </categories>
      <tags>
        <tag>Swift5.1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Swift5.1] 18-扩展]]></title>
    <url>%2F2020%2F06%2F06%2FSwift5-1-18-%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[扩展（Extension） Swift中的扩展，有点类似于OC中的分类（Category） 扩展可以为枚举、结构体、类、协议添加新功能。可以添加方法、计算属性、下标、（便捷）初始化器、嵌套类型、协议等等。 扩展不能办到的事情:不能覆盖原有的功能不能添加存储属性，不能向已有的属性添加属性观察器不能添加父类不能添加指定初始化器，不能添加反初始化器… 计算属性、下标、方法、嵌套类型1)添加计算属性 extension Double { var km: Double { self * 1_000.0 } var m: Double { self } var dm: Double { self / 10.0 } var cm: Double { self / 100.0 } var mm: Double { self / 1_000.0 } } 2)添加下标 extension Array { subscript(nullable idx: Int) -> Element? { if (startIndex..&lt;endIndex).contains(idx) { return self[idx] } return nil } } 3)添加嵌套类型 extension Int { func repetitions(task: () -> Void) { for _ in 0..&lt;self { task() } } mutating func square() -> Int { self = self * self return self } enum Kind { case negative, zero, positive } var kind: Kind { switch self { case 0: return .zero case let x where x > 0: return .positive default: return .negative } } subscript(digitIndex: Int) -> Int { var decimalBase = 1 for _ in 0..&lt;digitIndex { decimalBase *= 10 } return (self / decimalBase) % 10 } } 协议、初始化器 类扩展协议 class Person { var age: Int var name: String init(age: Int, name:String) { self.age = age self.name = name } } extension Person: Equatable { static func == (left:Person, right: Person) ->Bool{ left.age == right.age &amp;&amp; left.name == right.name } convenience init() { self.init(age:0, name: "") } } 结构体扩展 初始化器 struct Point{ var x: Int = 0 var y: Int = 0 } extension Point { init(_ point: Point) { init(_ point: Point){ self.init(x:point.x, y:point.y) } } } var p1 = Point() var p2 = Point(x: 10) var p3 = Point(y: 20) var p4 = Point(x: 10, y:20) var p5 = Point(p4) //扩展的初始化器 总结: 如果希望自定义初始化器的同时，编译器也能够生成默认初始化器 可以在扩展中编写自定义初始化器 required初始化器, 也不能写在扩展中 扩展协议 如果一个类型已经实现了协议的所有要求，但是还没有声明它遵守了这个协议 可以通过扩展来让它遵守这个协议 protocol TestProtocol { func test() } class TestClass { func test() { print("test") } } extension TestClass : TestProtocol {} 编写一个函数，判断一个整数是否为奇数？ func isOdd&lt;T: BinaryInteger>(_ i: T) -> Bool { i % 2 != 0 } extension BinaryInteger { func isOdd() -> Bool { self % 2 != 0 } } 扩展协议细节 扩展可以给协议提供默认实现，也间接实现可选协议的效果 扩展可以给协议扩充协议中从未声明过的方法 protocol TestProtocol { func test1() } extension TestProtocol { func test1() { print("TestProtocol test1") } func test2() { print("TestProtocol test2") } } class TestClass : TestProtocol {} var cls = TestClass() cls.test1() // TestProtocol test1 cls.test2() // TestProtocol test2 var cls2: TestProtocol = TestClass() cls2.test1() // TestProtocol test1 cls2.test2() // TestProtocol test2 类遵守协议,实现协议方法. class TestClass : TestProtocol { func test1() { print("TestClass test1") } func test2() { print("TestClass test2") } } var cls = TestClass() cls.test1() // TestClass test1 cls.test2() // TestClass test2 var cls2: TestProtocol = TestClass() //结果分析看总结 cls2.test1() // TestClass test1 cls2.test2() // TestProtocol test2 总结: 如果调用方法是在协议声明中的, 编译器优先去实例中查找. 如果调用方法是在协议声明中没有, 同时对象定义为协议类型,编译器会认为实例中没有该方法, 会直接去协议中查找. 扩展泛型 扩展中依然可以使用原类型中的泛型类型. class Stack&lt;E> { var elements = [E]() func push(_ element: E) { elements.append(element) } func pop() -> E { elements.removeLast() } func size() -> Int { elements.count } } // 扩展中依然可以使用原类型中的泛型类型 extension Stack { func top() -> E { elements.last! } } // 符合条件才扩展 extension Stack : Equatable where E : Equatable { static func == (left: Stack, right: Stack) -> Bool { left.elements == right.elements } }]]></content>
      <categories>
        <category>iOS笔记</category>
      </categories>
      <tags>
        <tag>Swift5.1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Swift5.1] 17-高级运算符]]></title>
    <url>%2F2020%2F06%2F06%2FSwift5-1-17-%E9%AB%98%E7%BA%A7%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[溢出运算符（Overflow Operator） Swift的算数运算符出现溢出时会抛出运行时错误 Swift有溢出运算符（&amp;+、&amp;-、&amp;*），用来支持溢出运算溢出时仍在范围内,超出范围从头开始 var min = UInt8.min print(min &amp;- 1) // 255, Int8.max var max = UInt8.max print(max &amp;+ 1) // 0, Int8.min print(max &amp;* 2) // 254, 等价于 max &amp;+ max 运算符重载（Operator Overload）1)运算符重载定义 类、结构体、枚举可以为现有的运算符提供自定义的实现，这个操作叫做：运算符重载 struct Point { var x: Int, y: Int } func + (p1: Point, p2: Point) -> Point { Point(x: p1.x + p2.x, y: p1.y + p2.y) } let p = Point(x: 10, y: 20) + Point(x: 11, y: 22) print(p) // Point(x: 21, y: 42) struct Point { var x: Int, y: Int static func + (p1: Point, p2: Point) -> Point { Point(x: p1.x + p2.x, y: p1.y + p2.y) } } 2)运算符重载前缀和后缀运算符重载默认中缀, 可以用prefix 设置前缀运算符重载, 用postfix设置后缀运算符重载 static func + (p1: Point, p2: Point) -> Point { Point(x: p1.x + p2.x, y: p1.y + p2.y) } static func - (p1: Point, p2: Point) -> Point { Point(x: p1.x - p2.x, y: p1.y - p2.y) } 运算符重载:取反 static prefix func - (p: Point) -> Point { Point(x: -p.x, y: -p.y) } 运算符重载:+= static func += (p1: inout Point, p2: Point) { p1 = p1 + p2 } 运算符重载:== static func == (p1: Point, p2: Point) -&gt; Bool { (p1.x == p2.x) &amp;&amp; (p1.y == p2.y) } 运算符重载:++ static prefix func ++ (p: inout Point) -> Point { p += Point(x: 1, y: 1) return p } static postfix func ++ (p: inout Point) -> Point { let tmp = p p += Point(x: 1, y: 1) return tmp } Equatable 要想得知2个实例是否等价，一般做法是遵守 Equatable 协议，重载 == 运算符 与此同时，等价于重载了 != 运算符 struct Point : Equatable { var x: Int, y: Int } var p1 = Point(x: 10, y: 20) var p2 = Point(x: 11, y: 22) print(p1 == p2) // false print(p1 != p2) // true Swift为以下类型提供默认的 Equatable 实现: 没有关联类型的枚举 (示例一) 只拥有遵守 Equatable 协议关联类型的枚举 (示例二) 只拥有遵守 Equatable 协议存储属性的结构体 //示例一 enum Answer { case wrong case right } var s1 = Answer.wrong var s2 = Answer.right print(s1 == s2) // false //示例二 enum Answer : Equatable{ case wrong(Int) case right } var s1 = Answer.wrong(11) var s2 = Answer.wrong(22) print(s1 == s2) //false 引用类型比较存储的地址值是否相等（是否引用着同一个对象），使用恒等运算符 === 、!== Comparable要想比较2个实例的大小，一般做法是： 遵守 Comparable 协议 重载相应的运算符 // score大的比较大，若score相等，age小的比较大 struct Student : Comparable { var age: Int var score: Int init(score: Int, age: Int) { self.score = score self.age = age } static func &lt; (lhs: Student, rhs: Student) -> Bool { (lhs.score &lt; rhs.score) || (lhs.score == rhs.score &amp;&amp; lhs.age > rhs.age) } static func > (lhs: Student, rhs: Student) -> Bool { (lhs.score > rhs.score) || (lhs.score == rhs.score &amp;&amp; lhs.age &lt; rhs.age) } static func &lt;= (lhs: Student, rhs: Student) -> Bool { !(lhs > rhs) } static func >= (lhs: Student, rhs: Student) -> Bool { !(lhs &lt; rhs) } } var stu3 = Student(score: 100, age: 20) print(stu1 > stu2) // true print(stu1 >= stu2) // true print(stu1 >= stu3) // true print(stu1 &lt;= stu3) // true print(stu2 &lt; stu1) // true print(stu2 &lt;= stu1) // true 自定义运算符（Custom Operator）可以自定义新的运算符：在全局作用域使用operator进行声明. prefix operator 前缀运算符 postfix operator后缀运算符 infix operator 中缀运算符 : 优先级组 precedencegroup 优先级组 { associativity: 结合性(left\right\none) higherThan: 比谁的优先级高 lowerThan: 比谁的优先级低 assignment: true 代表在可选链操作中拥有跟赋值运算符一样的优先级 } prefix operator +++ infix operator +- : PlusMinusPrecedence precedencegroup PlusMinusPrecedence { associativity: none higherThan: AdditionPrecedence lowerThan: MultiplicationPrecedence assignment: true } Apple文档参考：Operator Declarations-官方文档Operator Declaration-Swift文档说明 自定义运算符示例struct Point { var x: Int, y: Int static prefix func +++ (point: inout Point) -> Point { point = Point(x: point.x + point.x, y: point.y + point.y) return point } static func +- (left: Point, right: Point) -> Point { return Point(x: left.x + right.x, y: left.y - right.y) } static func +- (left: Point?, right: Point) -> Point { print("+-") return Point(x: left?.x ?? 0 + right.x, y: left?.y ?? 0 - right.y) } } struct Person { var point: Point } var person: Person? = nil person?.point +- Point(x: 10, y: 20)]]></content>
      <categories>
        <category>iOS笔记</category>
      </categories>
      <tags>
        <tag>Swift5.1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Swift5.1] 16-泛型]]></title>
    <url>%2F2020%2F06%2F05%2FSwift5-1-16-%E6%B3%9B%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[泛型（Generics） 泛型函数泛型可以将类型参数化，提高代码复用率，减少代码量 T代表 不确定类型参数 func swapValues&lt;T>(_ a: inout T, _ b: inout T) { (a, b) = (b, a) } var i1 = 10 var i2 = 20 swapValues(&amp;i1, &amp;i2) var d1 = 10.0 var d2 = 20.0 swapValues(&amp;d1, &amp;d2) struct Date { var year = 0, month = 0, day = 0 } var dd1 = Date(year: 2011, month: 9, day: 10) var dd2 = Date(year: 2012, month: 10, day: 11) swapValues(&amp;dd1, &amp;dd2) 泛型函数赋值给变量 func test&lt;T1, T2>(_ t1: T1, _ t2: T2) {} var fn: (Int, Double) -> () = test 泛型类型class Stack&lt;E> { var elements = [E]() func push(_ element: E) { elements.append(element) } func pop() -> E { elements.removeLast() } func top() -> E { elements.last! } func size() -> Int { elements.count } } var stack = Stack&lt;Int>() stack.push(11) stack.push(22) stack.push(33) print(stack.top()) // 33 print(stack.pop()) // 33 print(stack.pop()) // 22 print(stack.pop()) // 11 print(stack.size()) // 0 class SubStack&lt;E> : Stack&lt;E> {} 注意: 修改结构体数组元素, 需要添加mutating struct Stack&lt;E> { var elements = [E]() mutating func push(_ element: E) { elements.append(element) } mutating func pop() -> E { elements.removeLast() } func top() -> E { elements.last! } func size() -> Int { elements.count } } enum Score&lt;T&gt; { case point(T) case grade(String) } let score0 = Score&lt;Int&gt;.point(100) let score1 = Score.point(99) let score2 = Score.point(99.5) let score3 = Score&lt;Int&gt;.grade(&quot;A&quot;) 关联类型（Associated Type） 关联类型的作用：给协议中用到的类型定义一个占位名称. 协议中可以拥有多个关联类型.(协议中使用泛型 只能用关联类型) protocol Stackable { associatedtype Element // 关联类型 mutating func push(_ element: Element) mutating func pop() -> Element func top() -> Element func size() -> Int } 类遵守协议, 给关联类型设定真实类型 class StringStack : Stackable { // 给关联类型设定真实类型, 也可以省略 // typealias Element = String var elements = [String]() func push(_ element: String) { elements.append(element) } func pop() -> String { elements.removeLast() } func top() -> String { elements.last! } func size() -> Int { elements.count } } var ss = StringStack() ss.push("Jack") ss.push("Rose") 类中泛型赋值给协议关联类型 class Stack&lt;E> : Stackable { // typealias Element = E var elements = [E]() func push(_ element: E) { elements.append(element) } func pop() -> E { elements.removeLast() } func top() -> E { elements.last! } func size() -> Int { elements.count } } 类型约束下面类型约束: 要求泛型必须是Person子类型和遵守Runnable协议 protocol Runnable { } class Person { } func swapValues&lt;T : Person &amp; Runnable>(_ a: inout T, _ b: inout T) { (a, b) = (b, a) } 协议中关联类型也可以类型约束 protocol Stackable { associatedtype Element: Equatable } class Stack&lt;E : Equatable> : Stackable { typealias Element = E } func equal&lt;S1: Stackable, S2: Stackable>(_ s1: S1, _ s2: S2) -> Bool where S1.Element == S2.Element, S1.Element : Hashable { return false } var stack1 = Stack&lt;Int>() var stack2 = Stack&lt;String>() // error: requires the types 'Int' and 'String' be equivalent equal(stack1, stack2) 协议类型的注意点protocol Runnable {} class Person : Runnable {} class Car : Runnable {} func get(_ type: Int) -> Runnable { if type == 0 { return Person() } return Car() } var r1 = get(0) var r2 = get(1) 如果协议中有associatedtype, 以下写法会报错. protocol Runnable { associatedtype Speed var speed: Speed { get } } class Person : Runnable { var speed: Double { 0.0 } } class Car : Runnable { var speed: Int { 0 } } func get(_ type: Int) -> Runnable { if type == 0 { return Person() } return Car() } var r1 = get(0) var r2 = get(1) 因为编译后, 不确定关联类型是什么类型. 1)泛型解决解决方案①：使用泛型 func get&lt;T : Runnable>(_ type: Int) -> T { if type == 0 { return Person() as! T } return Car() as! T } var r1: Person = get(0) var r2: Car = get(1) 2)不透明类型（Opaque Type）解决方案②：使用some关键字声明一个不透明类型 func get(_ type: Int) -> some Runnable { Car() } var r1 = get(0) var r2 = get(1) some限制只能返回一种类型 some应用: 想返回遵守某个协议对象, 不希望外部知道对象类型, 外部使用对象时只想暴露协议接口调用, 可以用不透明类型. some除了用在返回值类型上，一般还可以用在属性类型上 protocol Runnable { associatedtype Speed } class Dog : Runnable { typealias Speed = Double } class Person { var pet: some Runnable { return Dog() } } 可选项的本质 可选项的本质是enum类型 1)可选项在.h中定义 public enum Optional&lt;Wrapped> : ExpressibleByNilLiteral { case none case some(Wrapped) public init(_ some: Wrapped) } 2)以下可选项赋值等效 var age: Int? = 10 var age0: Optional&lt;Int> = Optional&lt;Int>.some(10) var age1: Optional = .some(10) var age2 = Optional.some(10) var age3 = Optional(10) age = nil age3 = .none var age: Int? = nil var age0 = Optional&lt;Int>.none var age1: Optional&lt;Int> = .none 3)可选项混写 var age: Int? = .none age = 10 age = .some age = nil 4)可选类型可用于swich switch age { case let v?: //如果可选类型age 有值, 会解包赋值给v print("some", v) case nil: //如果可选类型age为 nil print("none") } switch age { case let .some(v): print("some", v) case .none: print("none") } 等价于 if let v = age { print(&quot;some&quot;, v) } else { print(&quot;none&quot;) } 多重可选项的本质var age_: Int? = 10 var age: Int?? = age_ age = nil 等价于 var age0 = Optional.some(Optional.some(10)) age0 = .none var age1: Optional&lt;Optional> = .some(.some(10)) age1 = .none var age: Int?? = 10 var age0: Optional&lt;Optional> = 10]]></content>
      <categories>
        <category>iOS笔记</category>
      </categories>
      <tags>
        <tag>Swift5.1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Swift5.1] 15-错误处理]]></title>
    <url>%2F2020%2F06%2F05%2FSwift5-1-15-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[错误处理也就是异常处理 错误类型开发过程常见的错误 语法错误（编译报错） 逻辑错误 运行时错误（可能会导致闪退，一般也叫做异常）…… 自定义错误1)Swift中可以通过Error协议自定义运行时的错误信息 enum SomeError : Error { case illegalArg(String) case outOfBounds(Int, Int) case outOfMemory } 2)函数内部通过throw抛出自定义Error，可能会抛出Error的函数必须加上throws声明 func divide(_ num1: Int, _ num2: Int) throws -> Int { if num2 == 0 { throw SomeError.illegalArg("0不能作为除数") } return num1 / num2 } 3)需要使用try调用可能会抛出Error的函数 var result = try divide(20, 10) do-catch可以使用do-catch捕捉Error func test() { print("1") do { print("2") print(try divide(20, 0)) print("3") } catch let SomeError.illegalArg(msg) { print("参数异常:", msg) } catch let SomeError.outOfBounds(size, index) { print("下标越界:", "size=\(size)", "index=\(index)") } catch SomeError.outOfMemory { print("内存溢出") } catch { print("其他错误") } print("4") } test() // 1 // 2 // 参数异常: 0不能作为除数 // 4 do { try divide(20, 0) } catch let error { switch error { case let SomeError.illegalArg(msg): print("参数错误：", msg) default: print("其他错误") } } 抛出Error后，try下一句直到作用域结束的代码都将停止运行 处理Error处理Error的2种方式:① 通过do-catch捕捉Error② 不捕捉Error，在当前函数增加throws声明，Error将自动抛给上层函数 如果最顶层函数（main函数）依然没有捕捉Error，那么程序将终止 1)Error将自动抛给上层函数: func test() throws { print("1") print(try divide(20, 0)) print("2") } try test() // 1 // Fatal error: Error raised at top level 2)error 转化为SomeError, 通过do-catch捕捉 func test() throws { print("1") do { print("2") print(try divide(20, 0)) print("3") } catch let error as SomeError { print(error) } print("4") } try test() // 1 // 2 // illegalArg("0不能作为除数") // 4 3)只要是SomeError就捕捉 do { print(try divide(20, 0)) } catch is SomeError { print("SomeError") } try?、try!可以使用try?、try!调用可能会抛出Error的函数，这样就不用去处理Error func test() { print("1") var result1 = try? divide(20, 10) // Optional(2),Int? var result2 = try? divide(20, 0) // nil var result3 = try! divide(20, 10) // 2, Int print("2") } test() a、b是等价的 var a = try? divide(20, 0) var b: Int? do { b = try divide(20, 0) } catch { b = nil } rethrowsrethrows表明：函数本身不会抛出错误，但调用闭包参数抛出错误，那么它会将错误向上抛 func exec(_ fn: (Int, Int) throws -> Int, _ num1: Int, _ num2: Int) rethrows { print(try fn(num1, num2)) } // Fatal error: Error raised at top level try exec(divide, 20, 0) deferdefer语句：用来定义以任何方式（抛错误、return等）离开代码块前必须要执行的代码 defer语句将延迟至当前作用域结束之前执行 func open (_ filename: String) -> Int { print("open") return 0 } func close(_ file: Int){ print("close") } func processFile(_ filename: String) throw { let file = open(filename) defer { close(file) } // 使用file // ... try divide(20, 0) //close 将会在这里调用 } try processFile("test.txt") // open // close // Fatal error: Error raised at top level defer语句的执行顺序与定义顺序相反 func fn1() { print("fn1") } func fn2() { print("fn2") } func test() { defer { fn1() } defer { fn2() } } test() // fn2 // fn1 assert（断言） 很多编程语言都有断言机制：不符合指定条件就抛出运行时错误，常用于调试（Debug）阶段的条件判断. 默认情况下，Swift的断言只会在Debug模式下生效，Release模式下会忽略 func divide(_ v1: Int, _ v2: Int) -> Int { assert(v2 != 0, "除数不能为0") //条件成立 继续往下走. 不成立抛出运行时错误 return v1 / v2 } print(divide(20, 0)) 增加Swift Flags修改断言的默认行为 -assert-config Release：强制关闭断言 -assert-config Debug：强制开启断言 fatalError 如果遇到严重问题，希望结束程序运行时，可以直接使用fatalError函数抛出错误（这是无法通过do-catch捕捉的错误） 使用了fatalError函数，就不需要再写return func test(_ num: Int) -> Int { if num >= 0 { return 1 } fatalError("num不能小于0") } 在某些不得不实现、但不希望别人调用的方法，可以考虑内部使用fatalError函数 class Person { required init() {} } class Student : Person { required init() { fatalError("don't call Student.init") } init(score: Int) {} } var stu1 = Student(score: 98) var stu2 = Student() 局部作用域可以使用 do 实现局部作用域 do { let dog1 = Dog() dog1.age = 10 dog1.run() } do { let dog2 = Dog() dog2.age = 10 dog2.run() }]]></content>
      <categories>
        <category>iOS笔记</category>
      </categories>
      <tags>
        <tag>Swift5.1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Swift5.1] 14-协议]]></title>
    <url>%2F2020%2F06%2F04%2FSwift5-1-14-%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[协议（Protocol）1)协议可以用来定义方法、属性、下标的声明，协议可以被枚举、结构体、类遵守（多个协议之间用逗号隔开） protocol Drawable { func draw() var x: Int { get set } var y: Int { get } subscript(index: Int) -> Int { get set } } protocol Test1 {} protocol Test2 {} protocol Test3 {} class TestClass : Test1, Test2, Test3 {} 2)协议中定义方法时不能有默认参数值默认情况下，协议中定义的内容必须全部都实现也有办法办到只实现部分内容，以后会讲到 协议中的属性protocol Drawable { func draw() var x : Int { get set } var y : Int { get } subscript(index: Int) -> Int { get set } } class Person : Drawable { var x: Int = 0 let y: Int = 0 func draw() { print("Person draw") } subscript(index: Int) -> Int { set {} get { index } } } class Person : Drawable { var x: Int { get { 0 } set {} } var y: Int { 0 } func draw() { print("Person draw") } subscript(index: Int) -> Int { set {} get { index } } } 协议中定义属性时必须用var关键字. 实现协议时的属性权限要不小于协议中定义的属性权限.协议定义get、set，用var存储属性或get、set计算属性去实现协议定义get，用任何属性都可以实现 static、class为了保证通用，协议中必须用static定义类型方法、类型属性、类型下标 protocol Drawable { static func draw() } class Person1 : Drawable { class func draw() { print("Person1 draw") } } class Person2 : Drawable { static func draw() { print("Person2 draw") } } mutating只有将协议中的实例方法标记为mutating 才允许结构体、枚举的具体实现修改自身内存 类在实现方法时不用加mutating，枚举、结构体才需要加mutating protocol Drawable { mutating func draw() } class Size : Drawable { var width: Int = 0 func draw() { width = 10 } } struct Point : Drawable { var x: Int = 0 mutating func draw() { x = 10 } } init 协议中还可以定义初始化器init 非final类实现时必须加上required protocol Drawable { init(x: Int, y: Int) } class Point : Drawable { required init(x: Int, y: Int) {} } final class Size : Drawable { init(x: Int, y: Int) {} } 如果从协议实现的初始化器，刚好是重写了父类的指定初始化器 那么这个初始化必须同时加required、override protocol Livable { init(age: Int) } class Person { init(age: Int) {} } class Student : Person, Livable { required override init(age: Int) { super.init(age: age) } } init、init?、init! 协议中定义的init?、init!，可以用init、init?、init!去实现 协议中定义的init，可以用init、init!去实现 protocol Livable { init() init?(age: Int) init!(no: Int) } class Person : Livable { required init() {} // required init!() {} required init?(age: Int) {} // required init!(age: Int) {} // required init(age: Int) {} required init!(no: Int) {} // required init?(no: Int) {} // required init(no: Int) {} } 协议的继承一个协议可以继承其他协议 protocol Runnable { func run() } protocol Livable : Runnable { func breath() } class Person : Livable { func breath() {} func run() {} } 协议组合协议组合，可以包含1个类类型（最多1个） protocol Livable {} protocol Runnable {} class Person {} // 接收Person或者其子类的实例 func fn0(obj: Person) {} // 接收遵守Livable协议的实例 func fn1(obj: Livable) {} // 接收同时遵守Livable、Runnable协议的实例 func fn2(obj: Livable &amp; Runnable) {} // 接收同时遵守Livable、Runnable协议、并且是Person或者其子类的实例 func fn3(obj: Person &amp; Livable &amp; Runnable) {} typealias RealPerson = Person &amp; Livable &amp; Runnable // 接收同时遵守Livable、Runnable协议、并且是Person或者其子类的实例 func fn4(obj: RealPerson) {} CaseIterable协议让枚举遵守CaseIterable协议，可以实现遍历枚举值 enum Season : CaseIterable { case spring, summer, autumn, winter } let seasons = Season.allCases print(seasons.count) // 4 for season in seasons { print(season) } // spring summer autumn winter CustomStringConvertible协议遵守CustomStringConvertible、 CustomDebugStringConvertible协议，都可以自定义实例的打印字符串 class Person : CustomStringConvertible, CustomDebugStringConvertible { var age = 0 var description: String { "person_\(age)" } var debugDescription: String { "debug_person_\(age)" } } var person = Person() print(person) // person_0 debugPrint(person) // debug_person_0 print调用的是CustomStringConvertible协议的description debugPrint 、po调用的是CustomDebugStringConvertible协议的debugDescription Any、AnyObjectSwift提供了2种特殊的类型：Any、AnyObject Any：可以代表任意类型（枚举、结构体、类，也包括函数类型） AnyObject：可以代表任意类类型（在协议后面写上: AnyObject代表只有类能遵守这个协议） 在协议后面写上: class也代表只有类能遵守这个协议 var stu: Any = 10 stu = "Jack" stu = Student() // 创建1个能存放任意类型的数组 // var data = Array&lt;Any>() 也等价于下面写法 var data = [Any]() data.append(1) data.append(3.14) data.append(Student()) data.append("Jack") data.append({ 10 }) is、as?、as!、asis用来判断是否为某种类型，as用来做强制类型转换 protocol Runnable { func run() } class Person {} class Student : Person, Runnable { func run() { print("Student run") } func study() { print("Student study") } } var stu: Any = 10 print(stu is Int) // true stu = "Jack" print(stu is String) // true stu = Student() print(stu is Person) // true print(stu is Student) // true print(stu is Runnable) // true var stu: Any = 10 (stu as? Student)?.study() // 没有调用study stu = Student() (stu as? Student)?.study() // Student study (stu as! Student).study() // Student study (stu as? Runnable)?.run() // Student run var data = [Any]() data.append(Int("123") as Any) var d = 10 as Double print(d) // 10.0 X.self、X.Type、AnyClassX代指类 X.self是一个元类型（metadata）的指针，metadata存放着类型相关信息 X.self属于X.Type类型 class Person {} class Student : Person {} var perType: Person.Type = Person.self var stuType: Student.Type = Student.self perType = Student.self var anyType: AnyObject.Type = Person.self anyType = Student.self public typealias AnyClass = AnyObject.Type var anyType2: AnyClass = Person.self anyType2 = Student.self var per = Person() var perType = type(of: per) // Person.self print(Person.self == type(of: per)) // true 以下四种初始化效果一样: class Person { static var age : Int = 0 static func run() {} } Person.age = 11 Person.run() Person.self.age = 22 Person.self.run() // 四种初始化效果一样: var p0 = Person() // init() var p1 = Person.self() // init() var p2 = Person.init() // init() var p3 = Person.self.init() // init() var pType = Person.self //var pType2 = Person //❌编译错误 如果想访问类属性,或者类方法, 可以通过类名(Person), 或者Person.self访问. 如果想要获取元类型,只能通过类名.self(Person.self)方式获取 AnyClass 实质就是 AnyObject.Type, 如果要求传入AnyClass, 就是传入任何类的元类类型(Person.self) func test(_ cls:AnyClass) { } test(Person.self) 元类型的应用class Animal { required init() {} } class Cat : Animal {} class Dog : Animal {} class Pig : Animal {} func create(_ clses: [Animal.Type]) -> [Animal] { var arr = [Animal]() for cls in clses { arr.append(cls.init()) } return arr } print(create([Cat.self, Dog.self, Pig.self])) import Foundation class Person { var age: Int = 0 } class Student : Person { var no: Int = 0 } print(class_getInstanceSize(Student.self)) // 32 print(class_getSuperclass(Student.self)!) // Person print(class_getSuperclass(Person.self)!) // Swift._SwiftObject 从结果可以看得出来，Swift还有个隐藏的基类：Swift._SwiftObject可以参考Swift源码 34行 Self Self代表当前类型, self代表当前实例对象 class Person { var age = 1 static var count = 2 func run() { print(self.age) // 1 print(Self.count) // 2 } } Self一般用作返回值类型，限定返回值跟方法调用者必须是同一类型（也可以作为参数类型） protocol Runnable { func test() -> Self } class Person : Runnable { required init() {} func test() -> Self { type(of: self).init() } } class Student : Person {} var p = Person() // Person print(p.test()) var stu = Student() // Student print(stu.test())]]></content>
      <categories>
        <category>iOS笔记</category>
      </categories>
      <tags>
        <tag>Swift5.1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Swift5.1] 13-可选链]]></title>
    <url>%2F2020%2F06%2F04%2FSwift5-1-13-%E5%8F%AF%E9%80%89%E9%93%BE%2F</url>
    <content type="text"><![CDATA[可选链（Optional Chaining） 可选项包装class Car { var price = 0 } class Dog { var weight = 0 } class Person { var name: String = "" var dog: Dog = Dog() var car: Car? = Car() func age() -> Int { 18 } func eat() { print("Person eat") } subscript(index: Int) -> Int { index } } var person: Person? = Person() var age1 = person!.age() // Int var age2 = person?.age() // Int? var name = person?.name // String? var index = person?[6] // Int? func getName() -> String { "jack" } // 如果person是nil，不会调用getName() person?.name = getName() 如果可选项为nil，调用方法、下标、属性失败，结果为nil 如果可选项不为nil，调用方法、下标、属性成功，结果会被包装成可选项 如果结果本来就是可选项，不会进行再次包装 if let _ = person?.eat() { // ()? print(&quot;eat调用成功&quot;) } else { print(&quot;eat调用失败&quot;) } var dog = person?.dog // Dog? var weight = person?.dog.weight // Int? var price = person?.car?.price // Int? 总结:多个?可以链接在一起如果链中任何一个节点是nil，那么整个链就会调用失败 可选链var scores = [&quot;Jack&quot;: [86, 82, 84], &quot;Rose&quot;: [79, 94, 81]] scores[&quot;Jack&quot;]?[0] = 100 scores[&quot;Rose&quot;]?[2] += 10 scores[&quot;Kate&quot;]?[0] = 88 var num1: Int? = 5 num1? = 10 // Optional(10) var num2: Int? = nil num2? = 10 // nil var dict: [String : (Int, Int) -&gt; Int] = [ &quot;sum&quot; : (+), &quot;difference&quot; : (-) ] var result = dict[&quot;sum&quot;]?(10, 20) // Optional(30), Int?]]></content>
      <categories>
        <category>iOS笔记</category>
      </categories>
      <tags>
        <tag>Swift5.1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Swift5.1] 12-初始化]]></title>
    <url>%2F2020%2F06%2F04%2FSwift5-1-12-%E5%88%9D%E5%A7%8B%E5%8C%96%2F</url>
    <content type="text"><![CDATA[初始化器1)类、结构体、枚举都可以定义初始化器 类有2种初始化器：指定初始化器（designated initializer）、便捷初始化器（convenience initializer） // 指定初始化器 init(parameters) { statements } // 便捷初始化器 convenience init(parameters) { statements } 每个类至少有一个指定初始化器，指定初始化器是类的主要初始化器 默认初始化器总是类的指定初始化器 类偏向于少量指定初始化器，一个类通常只有一个指定初始化器 2)初始化器的相互调用规则 指定初始化器 必须从它的直系父类调用指定初始化器 便捷初始化器 必须从相同的类里调用另一个初始化器 便捷初始化器 最终必须调用一个指定初始化器 初始化器的相互调用Superclass: 父类Subclass: 子类Convenience : 便捷初始化器Designated: 指定初始化器 这一套规则保证了: 使用任意初始化器，都可以完整地初始化实例 两段式初始化Swift在编码安全方面是煞费苦心，为了保证初始化过程的安全，设定了两段式初始化、安全检查 两段式初始化: 第1阶段：初始化所有存储属性① 外层调用指定\便捷初始化器② 分配内存给实例，但未初始化③ 指定初始化器确保当前类定义的存储属性都初始化④ 指定初始化器调用父类的初始化器，不断向上调用，形成初始化器链 第2阶段：设置新的存储属性值① 从顶部初始化器往下，链中的每一个指定初始化器都有机会进一步定制实例② 初始化器现在能够使用self（访问、修改它的属性，调用它的实例方法等等）③ 最终，链中任何便捷初始化器都有机会定制实例以及使用self 安全检查 指定初始化器必须保证在调用父类初始化器之前，其所在类定义的所有存储属性都要初始化完成 指定初始化器必须先调用父类初始化器，然后才能为继承的属性设置新值 便捷初始化器必须先调用同类中的其它初始化器，然后再为任意属性设置新值 初始化器在第1阶段初始化完成之前，不能调用任何实例方法、不能读取任何实例属性的值，也不能引用self 直到第1阶段结束，实例才算完全合法 重写 当重写父类的指定初始化器时，必须加上override（即使子类的实现是便捷初始化器） 如果子类写了一个匹配父类便捷初始化器的初始化器，不用加上override.因为父类的便捷初始化器永远不会通过子类直接调用，因此，严格来说，子类无法重写父类的便捷初始化器. 自动继承 ① 如果子类没有自定义任何指定初始化器，它会自动继承父类所有的指定初始化器 ② 如果子类提供了父类所有指定初始化器的实现（要么通过方式①继承，要么重写）.子类自动继承所有的父类便捷初始化器 ③ 就算子类添加了更多的便捷初始化器，这些规则仍然适用 ④ 子类以便捷初始化器的形式重写父类的指定初始化器，也可以作为满足规则②的一部分 required 用required修饰指定初始化器，表明其所有子类都必须实现该初始化器（通过继承或者重写实现） 如果子类重写了required初始化器，也必须加上required，不用加override class Person { required init() { } init(age: Int) { } } class Student : Person { required init() { super.init() } } 属性观察器 父类的属性在它自己的初始化器中赋值不会触发属性观察器，但在子类的初始化器中赋值会触发属性观察器 class Person { var age: Int { willSet { print("willSet", newValue) } didSet { print("didSet", oldValue, age) } } init() { self.age = 0 } } class Student : Person { override init() { super.init() self.age = 1 } } // willSet 1 // didSet 0 1 var stu = Student() 可失败初始化器 类、结构体、枚举都可以使用init?定义可失败初始化器 class Person { var name: String init?(name: String) { if name.isEmpty { return nil } self.name = name } } 之前接触过的可失败初始化器 var num = Int("123") public init?(_ description: String) enum Answer : Int { case wrong, right } var an = Answer(rawValue: 1) 不允许同时定义参数标签、参数个数、参数类型相同的可失败初始化器和非可失败初始化器 可以用init!定义隐式解包的可失败初始化器 可失败初始化器可以调用非可失败初始化器，非可失败初始化器调用可失败初始化器需要进行解包 如果初始化器调用一个可失败初始化器导致初始化失败，那么整个初始化过程都失败，并且之后的代码都停止执行 可以用一个非可失败初始化器重写一个可失败初始化器，但反过来是不行的 反初始化器（deinit） deinit叫做反初始化器，类似于C++的析构函数、OC中的dealloc方法当类的实例对象被释放内存时，就会调用实例对象的deinit方法 class Person { deinit { print("Person对象销毁了") } } deinit不接受任何参数，不能写小括号，不能自行调用 父类的deinit能被子类继承 子类的deinit实现执行完毕后会调用父类的deinit]]></content>
      <categories>
        <category>iOS笔记</category>
      </categories>
      <tags>
        <tag>Swift5.1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Swift5.1] 11-继承]]></title>
    <url>%2F2020%2F06%2F03%2FSwift5-1-11-%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[继承（Inheritance） 值类型（枚举、结构体）不支持继承，只有类支持继承 没有父类的类，称为：基类Swift并没有像OC、Java那样的规定：任何类最终都要继承自某个基类 子类可以重写父类的下标、方法、属性，重写必须加上override关键字 内存结构class Animal { var age = 0 } class Dog : Animal { var weight = 0 } class ErHa : Dog { var iq = 0 } let a = Animal() a.age = 10 //32 print(Mems.size(ofRef: a)) /* 0x00000001000073e0 0x0000000000000002 0x000000000000000a 0x0000000000000000 */ print(Mems.memStr(ofRef: a)) let d = Dog() d.age = 10 d.weight = 20 //32 print(Mems.size(ofRef: d)) /* 0x0000000100007490 0x0000000000000002 0x000000000000000a 0x0000000000000014 */ print(Mems.memStr(ofRef: d)) let e = ErHa() e.age = 10 e.weight = 20 e.iq = 30 //48 print(Mems.size(ofRef: e)) /* 0x0000000100007560 0x0000000000000002 0x000000000000000a 0x0000000000000014 0x000000000000001e 0x0000000000000000 */ print(Mems.memStr(ofRef: e)) 重写实例方法、下标在实例方法、下标前加关键字override，可以重写父类实例方法、下标 class Animal { func speak() { print("Animal speak") } subscript(index: Int) -> Int { return index } } var anim: Animal anim = Animal() // Animal speak anim.speak() // 6 print(anim[6]) class Cat : Animal { override func speak() { super.speak() print("Cat speak") } override subscript(index: Int) -> Int { return super[index] + 1 } } anim = Cat() // Animal speak // Cat speak anim.speak() // 7 print(anim[6]) 重写类型方法、下标 被class修饰的类型方法、下标，允许被子类重写 被static修饰的类型方法、下标，不允许被子类重写 class Animal { class func speak() { print("Animal speak") } class subscript(index: Int) -> Int { return index } } // Animal speak Animal.speak() // 6 print(Animal[6]) class Cat : Animal { override class func speak() { super.speak() print("Cat speak") } override class subscript(index: Int) -> Int { return super[index] + 1 } } // Animal speak // Cat speak Cat.speak() // 7 print(Cat[6]) 重写属性 子类可以将父类的属性（存储、计算）重写为计算属性 子类不可以将父类属性重写为存储属性 只能重写var属性，不能重写let属性 重写时，属性名、类型要一致 子类重写后的属性权限 不能小于 父类属性的权限. 如果父类属性是只读的，那么子类重写后的属性可以是只读的、也可以是可读写的. 如果父类属性是可读写的，那么子类重写后的属性也必须是可读写的. 重写实例属性class Circle { var radius: Int = 0 var diameter: Int { set { print("Circle setDiameter") radius = newValue / 2 } get { print("Circle getDiameter") return radius * 2 } } } var circle: Circle circle = Circle() circle.radius = 6 print(circle.diameter) // Circle getDiameter // 12 circle.diameter = 20 // Circle setDiameter print(circle.radius) // 10 class SubCircle : Circle { override var radius: Int { set { print("SubCircle setRadius") super.radius = newValue > 0 ? newValue : 0 } get { print("SubCircle getRadius") return super.radius } } override var diameter: Int { set { print("SubCircle setDiameter") super.diameter = newValue > 0 ? newValue : 0 } get { print("SubCircle getDiameter") return super.diameter } } } circle = SubCircle() // SubCircle setRadius circle.radius = 6 // SubCircle getDiameter // Circle getDiameter // SubCircle getRadius // 12 print(circle.diameter) // SubCircle setDiameter // Circle setDiameter // SubCircle setRadius circle.diameter = 20 // SubCircle getRadius // 10 print(circle.radius) 重写类型属性 被class修饰的计算类型属性，可以被子类重写. class修饰的存储属性不可以被重写. 被static修饰的类型属性（存储、计算），不可以被子类重写 class Circle { static var radius: Int = 0 class var diameter: Int { set { print("Circle setDiameter") radius = newValue / 2 } get { print("Circle getDiameter") return radius * 2 } } } class SubCircle : Circle { override static var diameter: Int { set { print("SubCircle setDiameter") super.diameter = newValue > 0 ? newValue : 0 } get { print("SubCircle getDiameter") return super.diameter } } } 属性观察器 可以在子类中为父类属性（除了只读计算属性、let属性）增加属性观察器. 1)子类给父类存储属性增加属性观察器 class Circle { var radius: Int = 1 } class SubCircle : Circle { override var radius: Int { willSet { print("SubCircle willSetRadius", newValue) } didSet { print("SubCircle didSetRadius", oldValue, radius) } } } var circle = SubCircle() // SubCircle willSetRadius 10 // SubCircle didSetRadius 1 10 circle.radius = 10 2)父类的存储属性有属性观察器的, 子类为父类增加属性观察器 class Circle { var radius: Int = 1 { willSet { print("Circle willSetRadius", newValue) } didSet { print("Circle didSetRadius", oldValue, radius) } } } class SubCircle : Circle { override var radius: Int { willSet { print("SubCircle willSetRadius", newValue) } didSet { print("SubCircle didSetRadius", oldValue, radius) } } } var circle = SubCircle() // SubCircle willSetRadius 10 // Circle willSetRadius 10 // Circle didSetRadius 1 10 // SubCircle didSetRadius 1 10 circle.radius = 10 3)父类有计算属性, 子类为父类计算属性增加属性观察器 class Circle { var radius: Int { set { print("Circle setRadius", newValue) } get { print("Circle getRadius") return 20 } } } class SubCircle : Circle { override var radius: Int { willSet { print("SubCircle willSetRadius", newValue) } didSet { print("SubCircle didSetRadius", oldValue, radius) } } } var circle = SubCircle() // Circle getRadius // SubCircle willSetRadius 10 // Circle setRadius 10 // Circle getRadius // SubCircle didSetRadius 20 20 circle.radius = 10 4)无论父类是类计算属性还是实例计算属性, 子类都可以为父类增加属性观察器 class Circle { class var radius: Int { set { print(&quot;Circle setRadius&quot;, newValue) } get { print(&quot;Circle getRadius&quot;) return 20 } } } class SubCircle : Circle { override static var radius: Int { willSet { print(&quot;SubCircle willSetRadius&quot;, newValue) } didSet { print(&quot;SubCircle didSetRadius&quot;, oldValue, radius) } } } // Circle getRadius // SubCircle willSetRadius 10 // Circle setRadius 10 // Circle getRadius // SubCircle didSetRadius 20 20 SubCircle.radius = 10 final 被final修饰的方法、下标、属性，禁止被重写 被final修饰的类，禁止被继承 多态实现原理1&gt;OC: Runtime2&gt;C++: 虚表(虚函数表)3&gt;Swift中 多态的实现原理 类似C++ 虚表]]></content>
      <categories>
        <category>iOS笔记</category>
      </categories>
      <tags>
        <tag>Swift5.1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Swift5.1] 10-下标]]></title>
    <url>%2F2020%2F06%2F03%2FSwift5-1-10-%E4%B8%8B%E6%A0%87%2F</url>
    <content type="text"><![CDATA[下标（subscript） 使用subscript可以给任意类型（枚举、结构体、类）增加下标功能，有些地方也翻译为：下标脚本 subscript的语法类似于实例方法、计算属性，本质就是方法（函数） class Point { var x = 0.0, y = 0.0 subscript(index: Int) -> Double { set { if index == 0 { x = newValue } else if index == 1 { y = newValue } } get { if index == 0 { return x } else if index == 1 { return y } return 0 } } } var p = Point() p[0] = 11.1 p[1] = 22.2 print(p.x) // 11.1 print(p.y) // 22.2 print(p[0]) // 11.1 print(p[1]) // 22.2 subscript中定义的返回值类型决定了 get方法的返回值类型 set方法中newValue的类型 subscript可以接受多个参数，并且类型任意 下标的细节 subscript可以没有set方法，但必须要有get方法 class Point { var x = 0.0, y = 0.0 subscript(index: Int) -> Double { get { if index == 0 { return x } else if index == 1 { return y } return 0 } } } 如果只有get方法，可以省略get class Point { var x = 0.0, y = 0.0 subscript(index: Int) -> Double { if index == 0 { return x } else if index == 1 { return y } return 0 } } 可以设置参数标签如果添加参数标签,使用时一定要带参数标签. class Point { var x = 0.0, y = 0.0 subscript(index i: Int) -> Double { if i == 0 { return x } else if i == 1 { return y } return 0 } } var p = Point() p.y = 22.2 print(p[index: 1]) // 22.2 下标可以是类型方法 class Sum { static subscript(v1: Int, v2: Int) -> Int { return v1 + v2 } } print(Sum[10, 20]) // 30 结构体、类作为返回值对比class Point { var x = 0, y = 0 } class PointManager { var point = Point() subscript(index: Int) -> Point { get { point } } } struct Point { var x = 0, y = 0 } class PointManager { var point = Point() subscript(index: Int) -> Point { set { point = newValue } get { point } } } var pm = PointManager() pm[0].x = 11 //本质: pm[0] = Point(x: 11, y:pm[0].y) pm[0].y = 22 //本质: pm[0] = Point(x: pm[0].x , y:22) // Point(x: 11, y: 22) print(pm[0]) // Point(x: 11, y: 22) print(pm.point) 当结构体类型作为下标返回值, 如果下标返回实例想访问成员.需要有set方法. 当类类型作为下标返回值, 如果下标返回实例想访问成员.不需要加set方法, 一样可以访问成员变量. 接收多个参数的下标class Grid { var data = [ [0, 1, 2], [3, 4, 5], [6, 7, 8] ] subscript(row: Int, column: Int) -> Int { set { guard row >= 0 &amp;&amp; row &lt; 3 &amp;&amp; column >= 0 &amp;&amp; column &lt; 3 else{ return } data[row][column] = newValue } get { guard row >= 0 &amp;&amp; row &lt; 3 &amp;&amp; column >= 0 &amp;&amp; column &lt; 3 else{ return 0 } return data[row][column] } } } var grid = Grid() grid[0, 1] = 77 grid[1, 2] = 88 grid[2, 0] = 99 print(grid.data) // [[0, 77, 2], [3, 4, 88], [99, 7, 8]]]]></content>
      <categories>
        <category>iOS笔记</category>
      </categories>
      <tags>
        <tag>Swift5.1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Swift5.1] 9-方法]]></title>
    <url>%2F2020%2F06%2F03%2FSwift5-1-9-%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[方法（Method）枚举、结构体、类都可以定义实例方法、类型方法 实例方法（Instance Method）：通过实例对象调用 类型方法（Type Method）：通过类型调用，用static或者class关键字定义 class Car { static var cout = 0 init() { Car.cout += 1 } static func getCount() -> Int { cout } } let c0 = Car() let c1 = Car() let c2 = Car() print(Car.getCount()) // 3 self 在实例方法中代表实例对象 在类型方法中代表类型 在类型方法static func getCount中 cout等价于self.cout、Car.self.cout、Car.cout mutating 结构体和枚举是值类型，默认情况下，值类型的属性不能被自身的实例方法修改 在func关键字前加mutating可以允许这种修改行为 struct Point { var x = 0.0, y = 0.0 mutating func moveBy(deltaX: Double, deltaY: Double) { x += deltaX y += deltaY // self = Point(x: x + deltaX, y: y + deltaY) } } enum StateSwitch { case low, middle, high mutating func next() { switch self { case .low: self = .middle case .middle: self = .high case .high: self = .low } } } @discardableResult在func前面加个@discardableResult，可以消除：函数调用后返回值未被使用的警告⚠ struct Point { var x = 0.0, y = 0.0 @discardableResult mutating func moveX(deltaX: Double) -> Double { x += deltaX return x } } var p = Point() p.moveX(deltaX: 10) @discardableResult func get() -&gt; Int { return 10 } get()]]></content>
      <categories>
        <category>iOS笔记</category>
      </categories>
      <tags>
        <tag>Swift5.1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Swift5.1] 8-属性]]></title>
    <url>%2F2020%2F06%2F02%2FSwift5-1-8-%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[属性Swift中跟实例相关的属性可以分为2大类 存储属性（Stored Property） 类似于成员变量这个概念 存储在实例的内存中 结构体、类可以定义存储属性 枚举不可以定义存储属性 计算属性（Computed Property） 本质就是方法（函数） 不占用实例的内存 枚举、结构体、类都可以定义计算属性 struct Circle { // 存储属性 var radius: Double // 计算属性 var diameter: Double { set { radius = newValue / 2 } get { radius * 2 } } } var circle = Circle(radius: 5) print(circle.radius) // 5.0 print(circle.diameter) // 10.0 circle.diameter = 12 print(circle.radius) // 6.0 print(circle.diameter) // 12.0 print(MemoryLayout&lt;Circle>.stride) // 8 存储属性关于存储属性，Swift有个明确的规定: 在创建类 或 结构体的实例时，必须为所有的存储属性设置一个合适的初始值 可以在初始化器里为存储属性设置一个初始值 可以分配一个默认的属性值作为属性定义的一部分 计算属性 set传入的新值默认叫做newValue，也可以自定义 struct Circle { var radius: Double var diameter: Double { set(newDiameter) { radius = newDiameter / 2 } get { radius * 2 } } } 只读计算属性：只有get，没有set struct Circle { var radius: Double var diameter: Double { get { radius * 2 } } } struct Circle { var radius: Double var diameter: Double { radius * 2 } } 定义计算属性只能用var，不能用let let代表常量：值是一成不变的 计算属性的值是可能发生变化的（即使是只读计算属性） 枚举rawValue原理枚举原始值rawValue的本质是：只读计算属性 enum TestEnum : Int { case test1 = 1, test2 = 2, test3 = 3 var rawValue: Int { switch self { case .test1: return 10 case .test2: return 11 case .test3: return 12 } } } print(TestEnum.test3.rawValue) // 12 延迟存储属性（Lazy Stored Property）使用lazy可以定义一个延迟存储属性，在第一次用到属性的时候才会进行初始化 class Car{ init() { print("Car init!") } func run() { print("Car is running!") } } class Person{ lazy var car = Car() init() { print("Person init!") } func goOut() { car.run() } } let p = Person() print("------") p.goOut() 输出: Person init! ------ Car init! Car is running! class PhotoView { lazy var image: Image = { let url = "https://www.baidu.com/xx.png" let data = Data(url: url) return Image(data: data) }() } lazy属性必须是var，不能是let let必须在实例的初始化方法完成之前就拥有值 如果多条线程同时第一次访问lazy属性 无法保证属性只被初始化1次, 不是线程安全的. 延迟存储属性注意点: 当结构体包含一个延迟存储属性时，只有var才能访问延迟存储属性 因为延迟属性初始化时需要改变结构体的内存 属性观察器（Property Observer）可以为非lazy的var存储属性设置属性观察器 struct Circle { var radius: Double { willSet { print("willSet", newValue) } didSet { print("didSet", oldValue, radius) } } init() { self.radius = 1.0 print("Circle init!") } } // Circle init! var circle = Circle() // willSet 10.5 // didSet 1.0 10.5 circle.radius = 10.5 // 10.5 print(circle.radius) willSet会传递新值，默认叫newValue didSet会传递旧值，默认叫oldValue 在初始化器中设置属性值不会触发willSet和didSet 在属性定义时设置初始值也不会触发willSet和didSet 全局变量、局部变量属性观察器、计算属性的功能，同样可以应用在全局变量、局部变量身上 var num: Int { get { return 10 } set { print("setNum", newValue) } } num = 11 // setNum 11 print(num) // 10 func test() { var age = 10 { willSet { print("willSet", newValue) } didSet { print("didSet", oldValue, age) } } age = 11 // willSet 11 // didSet 10 11 } test() inout的再次研究struct Shape { var width: Int var side: Int { willSet { print("willSetSide", newValue) } didSet { print("didSetSide", oldValue, side) } } var girth: Int { set { width = newValue / side print("setGirth", newValue) } get { print("getGirth") return width * side } } func show() { print("width=\(width), side=\(side), girth=\(girth)") } } func test(_ num: inout Int) { num = 20 } var s = Shape(width: 10, side: 4) test(&amp;s.width) s.show() print("----------") test(&amp;s.side) s.show() print("----------") test(&amp;s.girth) s.show() 打印: getGirth width=20, side=4, girth=80 ---------- willSetSide 20 didSetSide 4 20 getGirth width=20, side=20, girth=400 ---------- getGirth setGirth 20 getGirth width=1, side=20, girth=20 inout的本质总结1)如果实参有物理内存地址，且没有设置属性观察器直接将实参的内存地址传入函数（实参进行引用传递） 2)如果实参是计算属性 或者 设置了属性观察器采取了Copy In Copy Out的做法 调用该函数时，先复制实参的值，产生副本【get】 将副本的内存地址传入函数（副本进行引用传递），在函数内部可以修改副本的值 函数返回后，再将副本的值覆盖实参的值【set】 总结： inout的本质就是引用传递（地址传递） 类型属性（Type Property）严格来说，属性可以分为:1)实例属性（Instance Property）：只能通过实例去访问 存储实例属性（Stored Instance Property）：存储在实例的内存中，每个实例都有1份 计算实例属性（Computed Instance Property） 2)类型属性（Type Property）：只能通过类型去访问 存储类型属性（Stored Type Property）：整个程序运行过程中，就只有1份内存（类似于全局变量） 计算类型属性（Computed Type Property） 可以通过static定义类型属性 如果是类，也可以用关键字 class struct Car { static var count: Int = 0 init() { Car.count += 1 } } let c1 = Car() let c2 = Car() let c3 = Car() print(Car.count) // 3 类型属性细节 不同于存储实例属性，你必须给存储类型属性设定初始值 因为类型没有像实例那样的init初始化器来初始化存储属性 存储类型属性默认就是lazy，会在第一次使用的时候才初始化就算被多个线程同时访问，保证只会初始化一次 存储类型属性可以是let 枚举类型也可以定义类型属性（存储类型属性、计算类型属性） 单例模式public class FileManager { public static let shared = FileManager() private init() { } } public class FileManager { public static let shared = { // .... // .... return FileManager() }() private init() { } }]]></content>
      <categories>
        <category>iOS笔记</category>
      </categories>
      <tags>
        <tag>Swift5.1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Swift5.1] 7-闭包]]></title>
    <url>%2F2020%2F06%2F02%2FSwift5-1-7-%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[闭包表达式（Closure Expression）在Swift中，可以通过func定义一个函数，也可以通过闭包表达式定义一个函数 func sum(_ v1: Int, _ v2: Int) -> Int { v1 + v2 } var fn = { (v1: Int, v2: Int) -> Int in return v1 + v2 } fn(10, 20) { (v1: Int, v2: Int) -> Int in return v1 + v2 }(10, 20) 闭包格式: { (参数列表) -> 返回值类型 in 函数体代码 } 注意:闭包调用传值,不用写标签. 比如上面的v1, v2 闭包表达式的简写func exec(v1: Int, v2: Int, fn: (Int, Int) -> Int) { print(fn(v1, v2)) } 闭包调用: exec(v1: 10, v2: 20, fn: { (v1: Int, v2: Int) -> Int in return v1 + v2 }) 1)闭包可以省略参数类型 exec(v1: 10, v2: 20, fn: { v1, v2 in return v1 + v2 }) 2)闭包还可以省略return exec(v1: 10, v2: 20, fn: { v1, v2 in v1 + v2 }) 3)闭包还可以省略in$0代表最前边的参数, $1代表第二个参数 exec(v1: 10, v2: 20, fn: { $0 + $1 }) 4)闭包还可以直接用加号,代表两个参数相加 exec(v1: 10, v2: 20, fn: +) 尾随闭包 如果将一个很长的闭包表达式作为函数的最后一个实参，使用尾随闭包可以增强函数的可读性. 尾随闭包是一个被书写在函数调用括号外面（后面）的闭包表达式 func exec(v1: Int, v2: Int, fn: (Int, Int) -> Int) { print(fn(v1, v2)) } exec(v1: 10, v2: 20) { $0 + $1 } 如果闭包表达式是函数的唯一实参，而且使用了尾随闭包的语法，那就不需要在函数名后边写圆括号 func exec(fn: (Int, Int) -> Int) { print(fn(1, 2)) } exec(fn: { $0 + $1 }) exec() { $0 + $1 } exec { $0 + $1 } 示例 – 数组的排序func sort(by areInIncreasingOrder: (Element, Element) -> Bool) /// 返回true: i1排在i2前面 /// 返回false: i1排在i2后面 func cmp(i1: Int, i2: Int) -> Bool { // 大的排在前面 return i1 > i2 } var nums = [11, 2, 18, 6, 5, 68, 45] nums.sort(by: cmp) // [68, 45, 18, 11, 6, 5, 2] nums.sort(by: { (i1: Int, i2: Int) -> Bool in return i1 &lt; i2 }) nums.sort(by: { i1, i2 in return i1 &lt; i2 }) nums.sort(by: { i1, i2 in i1 &lt; i2 }) nums.sort(by: { $0 &lt; $1 }) nums.sort(by: &lt;) nums.sort() { $0 &lt; $1 } nums.sort { $0 &lt; $1 } // [2, 5, 6, 11, 18, 45, 68] 忽略参数func exec(fn: (Int, Int) -> Int) { print(fn(1, 2)) } exec { _,_ in 10 } // 10 闭包（Closure）网上有各种关于闭包的定义，个人觉得比较严谨的定义是: 一个函数和它所捕获的变量\常量环境组合起来，称为 闭包 一般指定义在函数内部的函数 一般它捕获的是外层函数的局部变量\常量 typealias Fn = (Int) -&gt; Int func getFn() -&gt; Fn { var num = 0 func plus(_ i: Int) -&gt; Int { num += i return num } return plus } // 返回的plus和num形成了闭包 func getFn() -&gt; Fn { var num = 0 return { num += $0 return num } } var fn1 = getFn() var fn2 = getFn() fn1(1) // 1 fn2(2) // 2 fn1(3) // 4 fn2(4) // 6 fn1(5) // 9 fn2(6) // 12 思考：如果num是全局变量呢？ 可以把闭包想象成是一个类的实例对象 内存在堆空间 捕获的局部变量\常量就是对象的成员（存储属性） 组成闭包的函数就是类内部定义的方法 class Closure { var num = 0 func plus(_ i: Int) -> Int { num += i return num } } var cs1 = Closure() var cs2 = Closure() cs1.plus(1) // 1 cs2.plus(2) // 2 cs1.plus(3) // 4 cs2.plus(4) // 6 cs1.plus(5) // 9 cs2.plus(6) // 12 练习 闭包捕获变量num1 num2, 共享堆内存空间 typealias Fn = (Int) -> (Int, Int) func getFns() -> (Fn, Fn) { var num1 = 0 var num2 = 0 func plus(_ i: Int) -> (Int, Int) { num1 += i num2 += i &lt;&lt; 1 return (num1, num2) } func minus(_ i: Int) -> (Int, Int) { num1 -= i num2 -= i &lt;&lt; 1 return (num1, num2) } return (plus, minus) } let (p, m) = getFns() p(5) // (5, 10) m(4) // (1, 2) p(3) // (4, 8) m(2) // (2, 4) class Closure { var num1 = 0 var num2 = 0 func plus(_ i: Int) -> (Int, Int) { num1 += i num2 += i &lt;&lt; 1 return (num1, num2) } func minus(_ i: Int) -> (Int, Int) { num1 -= i num2 -= i &lt;&lt; 1 return (num1, num2) } } var cs = Closure() cs.plus(5) // (5, 10) cs.minus(4) // (1, 2) cs.plus(3) // (4, 8) cs.minus(2) // (2, 4) 练习2var functions: [() -> Int] = [] for i in 1...3 { functions.append { i } } for f in functions { print(f()) } // 1 // 2 // 3 class Closure { var i: Int init(_ i: Int) { self.i = i } func get() -> Int { return i } } var clses: [Closure] = [] for i in 1...3 { clses.append(Closure(i)) } for cls in clses { print(cls.get()) } 注意如果返回值是函数类型，那么参数的修饰要保持统一 func add(_ num: Int) -> (inout Int) -> Void { func plus(v: inout Int) { v += num } return plus } var num = 5 add(20)(&amp;num) print(num) 自动闭包// 如果第1个数大于0，返回第一个数。否则返回第2个数 func getFirstPositive(_ v1: Int, _ v2: Int) -> Int { return v1 > 0 ? v1 : v2 } getFirstPositive(10, 20) // 10 getFirstPositive(-2, 20) // 20 getFirstPositive(0, -4) // -4 // 改成函数类型的参数，可以让v2延迟加载 func getFirstPositive(_ v1: Int, _ v2: () -> Int) -> Int? { return v1 > 0 ? v1 : v2() } getFirstPositive(-4) { 20 } func getFirstPositive(_ v1: Int, _ v2: @autoclosure () -> Int) -> Int? { return v1 > 0 ? v1 : v2() } getFirstPositive(-4, 20) @autoclosure 会自动将 20 封装成闭包 { 20 } @autoclosure 只支持 () -&gt; T 格式的参数 @autoclosure 并非只支持最后1个参数 空合并运算符 ?? 使用了 @autoclosure 技术 有@autoclosure、无@autoclosure，构成了函数重载 为了避免与期望冲突，使用了@autoclosure的地方最好明确注释清楚：这个值会被推迟执行]]></content>
      <categories>
        <category>iOS笔记</category>
      </categories>
      <tags>
        <tag>Swift5.1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Swift5.1] 6-结构体和类]]></title>
    <url>%2F2020%2F06%2F01%2FSwift5-1-6-%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[结构体在 Swift 标准库中，绝大多数的公开类型都是结构体，而枚举和类只占很小一部分比如Bool、Int、Double、 String、Array、Dictionary等常见类型都是结构体 struct Date { var year: Int var month: Int var day: Int } var date = Date(year: 2019, month: 6, day: 23) 所有的结构体都有一个编译器自动生成的初始化器（initializer，初始化方法、构造器、构造方法） 最后一行调用的，可以传入所有成员值，用以初始化所有成员（存储属性，Stored Property） 结构体的初始化器编译器会根据情况，可能会为结构体生成多个初始化器，宗旨是：保证所有成员都有初始值 思考：下面代码能编译通过么？ struct Point { var x: Int? var y: Int? } var p1 = Point(x:10, y:10) var p2 = Point(y:10) var p3 = Point(x:10) var p4 = Point() 可选项都有个默认值nil, 因此可以编译通过 自定义初始化器一旦在定义结构体时自定义了初始化器，编译器就不会再帮它自动生成其他初始化器 窥探初始化器的本质struct Point { var x: Int = 0 var y: Int = 0 } var p = Point() 等效于: struct Point { var x: Int var y: Int init() { x = 0 y = 0 } } var p = Point() 结构体内存结构struct Point { var x: Int = 0 var y: Int = 0 var origin: Bool = false } print(MemoryLayout&lt;Point>.size) // 17 print(MemoryLayout&lt;Point>.stride) // 24 print(MemoryLayout&lt;Point>.alignment) // 8 类类的定义和结构体类似，但编译器并没有为类自动生成可以传入成员值的初始化器. 和结构体比较: struct Point { var x: Int = 0 var y: Int = 0 } let p1 = Point() let p2 = Point(x:10, y: 20) let p3 = Point(x:10) let p4 = Point(y:20) 如果定义类没有给成员初始化值, 编译器不会生成无参的初始化器. 类的初始化器 如果类的所有成员都在定义的时候指定了初始值，编译器会为类生成无参的初始化器 成员的初始化是在这个初始化器中完成的 class Point { var x : Int = 10 var y : Int = 20 } let p1 = Point() 上面代码等价于下面: class Point { var x : Int var y : Int init() { x = 10 y = 10 } } let p1 = Point() 结构体与类的本质区别 结构体是值类型（枚举也是值类型），类是引用类型（指针类型） class Size { var width = 1 var height = 2 } struct Point { var x = 3 var y = 4 } func test() { var size = Size() var point = Point() } 值类型 值类型赋值给var、let或者给函数传参，是直接将所有内容拷贝一份 类似于对文件进行copy、paste操作，产生了全新的文件副本。属于深拷贝（deep copy） struct Point { var x: Int var y: Int } func test() { var p1 = Point(x: 10, y: 20) var p2 = p1 } p2.x = 11 p2.y = 22 请问p1.x和p1.y是多少？ 10 20 值类型的赋值操作var s1 = "Jack" var s2 = s1 s2.append("_Rose") print(s1) // Jack print(s2) // Jack_Rose var a1 = [1, 2, 3] var a2 = a1 a2.append(4) a1[0] = 2 print(a1) //[2,2,3] print(a2) //[1,2,3,4] var d1 = ["max" : 10, "min" : 2] var d2 = d1 d1["other"] = 7 d2["max"] = 12 print(d1) // ["other": 7, "max": 10, "min": 2] print(d2) // ["max": 12, "min": 2] 在Swift标准库中，为了提升性能，String、Array、Dictionary、Set采取了Copy On Write的技术 比如仅当有“写”操作时，才会真正执行拷贝操作 对于标准库值类型的赋值操作，Swift 能确保最佳性能，所有没必要为了保证最佳性能来避免赋值 建议：不需要修改的，尽量定义成let struct Point { var x: Int var y: Int } var p1 = Point(x: 10, y: 20) p1 = Point(x: 11, y: 22) 引用类型 引用赋值给var、let或者给函数传参，是将内存地址拷贝一份 类似于制作一个文件的替身（快捷方式、链接），指向的是同一个文件。属于浅拷贝（shallow copy） class Size { var width: Int var height: Int init(width: Int, height: Int) { self.width = width self.height = height } } func test() { var s1 = Size(width: 10, height: 20) var s2 = s1 } s2.width = 11 s2.height = 22 请问s1.width和s1.height是多少？ 对象的堆空间申请过程在Swift中，创建类的实例对象，要向堆空间申请内存，大概流程如下: Class.allocating_init() libswiftCore.dylib：_swift_allocObject_ libswiftCore.dylib：swift_slowAlloc libsystem_malloc.dylib：malloc 在Mac、iOS中的malloc函数分配的内存大小总是16的倍数 通过class_getInstanceSize可以得知：类的对象至少需要占用多少内存 class Point { var x = 11 var test = true var y = 22 } var p = Point() class_getInstanceSize(type(of: p)) // 40 class_getInstanceSize(Point.self) // 40 引用类型的赋值操作class Size { var width: Int var height: Int init(width: Int, height: Int) { self.width = width self.height = height } } var s1 = Size(width: 10, height: 20) s1 = Size(width: 11, height: 22) 值类型、引用类型的letstruct Point { var x: Int var y: Int } class Size { var width: Int var height: Int init(width: Int, height: Int) { self.width = width self.height = height } } 理解: let修饰的p, p内存16个字节不能修改 let修饰的s, s内存8个字节不能修改,指向内存地址不变. s.width和s.height修改的是堆里边内存 总结:值类型和引用类型为常量时, 值类型和引用类型内存地址不能修改,不能指向其他内存.但引用类型可以修改其堆内存存储的成员变量值. 理解:let声明值类型的字符串str, 说明常量str的内存是不能修改的,所以后边不能拼接字符串.let声明值数组arr, 说明常量arr的内存是不能修改的,所以后边不能拼接,也不能修改某个元素的值. 嵌套类型struct Poker { enum Suit : Character { case spades = "♠", hearts = "♥", diamonds = "♦", clubs = "♣" } enum Rank : Int { case two = 2, three, four, five, six, seven, eight, nine, ten case jack, queen, king, ace } } print(Poker.Suit.hearts.rawValue) var suit = Poker.Suit.spades suit = .diamonds var rank = Poker.Rank.five rank = .king 枚举、结构体、类都可以定义方法一般把定义在枚举、结构体、类内部的函数，叫做方法 class Size { var width = 10 var height = 10 func show() { print("width=\(width), height=\(height)") } } let s = Size() s.show() // width=10, height=10 struct Point { var x = 10 var y = 10 func show() { print("x=\(x), y=\(y)") } } let p = Point() p.show() // x=10, y=10 enum PokerFace : Character { case spades = "♠", hearts = "♥", diamonds = "♦", clubs = "♣" func show() { print("face is \(rawValue)") } } let pf = PokerFace.hearts pf.show() // face is ♥ 方法占用对象的内存么？ 不占用 方法的本质就是函数 方法、函数都存放在代码段 作业思考以下结构体、类对象的内存结构是怎样的？ struct Point { var x: Int var b1: Bool var b2: Bool var y: Int } var p = Point(x: 10, b1: true, b2: true, y: 20) class Size { var width: Int var b1: Bool var b2: Bool var height: Int init(width: Int, b1: Bool, b2: Bool, height: Int) { self.width = width self.b1 = b1 self.b2 = b2 self.height = height } } var s = Size(width: 10, b1: true, b2: true, height: 20)]]></content>
      <categories>
        <category>iOS笔记</category>
      </categories>
      <tags>
        <tag>Swift5.1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Swift5.1] 5-可选项]]></title>
    <url>%2F2020%2F06%2F01%2FSwift5-1-5-%E5%8F%AF%E9%80%89%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[可选项（Optional） 可选项，一般也叫可选类型，它允许将值设置为nil 在类型名称后面加个问号 ? 来定义一个可选项 var name: String? = "Jack" name = nil var age: Int? //默认就是nil age = 10 age = nil var array = [1, 15, 40, 29] func get(_ index: Int) -> Int? { if index &lt; 0 || index >= array.count { return nil } return array[index] } print(get(1)) // Optional(15) print(get(-1)) // nil print(get(4)) // nil 强制解包（Forced Unwrapping）可选项本质: 可选项是对其他类型的一层包装，可以将它理解为一个盒子 如果为nil，那么它是个空盒子 如果不为nil，那么盒子里装的是：被包装类型的数据 var age: Int? // 默认就是nil age = 10 age = nil 如果要从可选项中取出被包装的数据（将盒子里装的东西取出来），需要使用感叹号 ! 进行强制解包 var age: Int? = 10 let ageInt: Int = age! ageInt += 10 如果对值为nil的可选项（空盒子）进行强制解包，将会产生运行时错误 var age: Int? age! //Fatal error: Unexpectedly found nil while unwrapping an Optional value 判断可选项是否包含值let number = Int("123") if number != nil { print("字符串转换整数成功：\(number!)") } else { print("字符串转换整数失败") } // 字符串转换整数成功：123 可选项绑定（Optional Binding） 可以使用可选项绑定来判断可选项是否包含值 如果包含就自动解包，把值赋给一个临时的常量(let)或者变量(var)，并返回true，否则返回false if let number = Int("123") { print("字符串转换整数成功：\(number)") // number是强制解包之后的Int值 // number作用域仅限于这个大括号 } else { print("字符串转换整数失败") } // 字符串转换整数成功：123 enum Season : Int { case spring = 1, summer, autumn, winter } if let season = Season(rawValue: 6) { switch season { case .spring: print("the season is spring") default: print("the season is other") } } else { print("no such season") } // no such season 等价写法if let first = Int("4") { if let second = Int("42") { if first &lt; second &amp;&amp; second &lt; 100 { print("\(first) &lt; \(second) &lt; 100") } } } // 4 &lt; 42 &lt; 100 注意: 同一个if中, 可选项绑定要和其他语句以逗号隔开 if let first = Int("4"), let second = Int("42"), first &lt; second &amp;&amp; second &lt; 100 { print("\(second) &lt; \(second) &lt; 100") } // 4 &lt; 42 &lt; 100 while循环中使用可选项绑定 遍历数组，将遇到的正数都加起来，如果遇到负数或者非数字，停止遍历 var strs = ["10", "20", "abc", "-20", "30"] var index = 0 var sum = 0 while let num = Int(strs[index]), num > 0 { sum += num index += 1 } print(sum) 空合并运算符 ??（Nil-Coalescing Operator）public func ?? &lt;T&gt;(optional: T?, defaultValue: @autoclosure () throws -&gt; T?) rethrows -&gt; T? public func ?? &lt;T&gt;(optional: T?, defaultValue: @autoclosure () throws -&gt; T) rethrows -&gt; T a ?? b a 是可选项 b 是可选项 或者 不是可选项 b 跟 a 的存储类型必须相同 如果 a 不为nil，就返回 a 如果 a 为nil，就返回 b 如果 b 不是可选项，返回 a 时会自动解包 let a: Int? = 1 let b: Int? = 2 let c = a ?? b //c是Int? , Optional(1) let a: Int? = nil let b: Int? = 2 let c = a ?? b //c是Int? , Optional(2) let a: Int? = nil let b: Int? = nil let c = a ?? b //c是Int? , nil let a: Int? = 1 let b: Int = 2 let c = a ?? b //c是Int , 1 let a: Int? = nil let b: Int = 2 let c = a ?? b //c是Int , 2 上段代码等价于下面代码: let a: Int? = nil let b: Int = 2 //如果不使用??运算符 let c : Int if let tmp = a { c = tmp } else{ c = b } 多个 ?? 一起使用let a: Int? = 1 let b: Int? = 2 let c = a ?? b ?? 3 //c是Int , 1 let a: Int? = nil let b: Int? = 2 let c = a ?? b ?? 3 //c是Int , 2 let a: Int? = nil let b: Int? = nil let c = a ?? b ?? 3 //c是Int , 3 ??跟if let配合使用 下面类似于if a != nil || b != nil let a: Int? = nil let b: Int? = 2 if let c = a ?? b { print(c) } 下面类似于if a != nil &amp;&amp; b != nil if let c = a, let d = b { print(c) print(d) } if语句实现登陆func login(_ info: [String : String]) { let username: String if let tmp = info["username"] { username = tmp } else { print("请输入用户名") return } let password: String if let tmp = info["password"] { password = tmp } else { print("请输入密码") return } // if username .... // if password .... print("用户名：\(username)", "密码：\(password)", "登陆ing") } login(["username" : "jack", "password" : "123456"]) // 用户名：jack 密码：123456 登陆ing login(["password" : "123456"]) // 请输入密码 login(["username" : "jack"]) // 请输入用户名 guard语句guard 条 件 else { // do something.... 退出当前作用域 // return、break、continue、throw error } guard语句用法:1)当guard语句的条件为false时，就会执行大括号里面的代码2)当guard语句的条件为true时，就会跳过guard语句3)guard语句特别适合用来“提前退出” 当使用guard语句进行可选项绑定时，绑定的常量(let)、变量(var)也能在外层作用域中使用 func login(_ info: [String : String]) { guard let username = info["username"] else { print("请输入用户名") return } guard let password = info["password"] else { print("请输入密码") return } // if username .... // if password .... print("用户名：\(username)", "密码：\(password)", "登陆ing") } 隐式解包（Implicitly Unwrapped Optional） 在某些情况下，可选项一旦被设定值之后，就会一直拥有值 在这种情况下，可以去掉检查，也不必每次访问的时候都进行解包，因为它能确定每次访问的时候都有值 可以在类型后面加个感叹号 ! 定义一个隐式解包的可选项 let num1: Int! = 10 let num2: Int = num1 if num1 != nil { print(num1 + 6) // 16 } if let num3 = num1 { print(num3) } 注意:如果可选项空值, 隐式解包会报错! let num1: Int! = nil // Fatal error: Unexpectedly found nil while implicitly unwrapping an Optional value let num2: Int = num1 隐式绑定场景: 希望给当前变量传入具体值,开发中尽量不要用! 字符串插值可选项在字符串插值或者直接打印时，编译器会发出警告 var age: Int? = 10 print("My age is \(age)") // My age is Optional(10) 至少有3种方法消除警告 print("My age is \(age!)") // My age is 10 print("My age is \(String(describing: age))") // My age is Optional(10) print("My age is \(age ?? 0)") // My age is 10 多重可选项实例1:var num1: Int? = 10 //包装Int类型的可选类型 var num2: Int?? = num1 // 包装一个可选类型的可选类型 var num3: Int?? = 10 print(num2 == num3) // true 可以使用lldb指令 frame variable –R 或者 fr v –R 查看区别 实例2:var num1: Int? = nil var num2: Int?? = num1 var num3: Int?? = nil print(num2 == num3) // false //num2 和num3类型相同, 值不同 print(num1 == num3) // false // num1和num3类型不同 (num2 ?? 1) ?? 2 // 2 (num3 ?? 1) ?? 2 // 1]]></content>
      <categories>
        <category>iOS笔记</category>
      </categories>
      <tags>
        <tag>Swift5.1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Swift5.1] 4-枚举]]></title>
    <url>%2F2020%2F05%2F31%2FSwift5-1-4-%E6%9E%9A%E4%B8%BE%2F</url>
    <content type="text"><![CDATA[枚举的基本用法enum Direction { case north case south case east case west } 等价于上边代码 enum Direction { case north, south, east, west } var dir = Direction.west dir = Direction.east dir = .north print(dir) // north switch dir { case .north: print("north") case .south: print("south") case .east: print("east") case .west: print("west") } 关联值（Associated Values） 有时将枚举的成员值跟其他类型的值关联存储在一起，会非常有用 enum Score { case points(Int) case grade(Character) } var score = Score.points(96) score = .grade("A") switch score { case let .points(i): print(i, "points") case let .grade(i): print("grade", i) } // grade A 必要时let也可以改为var enum Date { case digit(year: Int, month: Int, day: Int) case string(String) } var date = Date.digit(year: 2011, month: 9, day: 10) date = .string("2011-09-10") switch date { case .digit(let year, let month, let day): print(year, month, day) case let .string(value): print(value) } // 2011-09-10 关联值举例 enum Password { case number(Int, Int, Int, Int) case gesture(String) } var pwd = Password.number(3, 5, 7, 8) pwd = .gesture("12369") switch pwd { case let .number(n1, n2, n3, n4): print("number is ", n1, n2, n3, n4) case let .gesture(str): print("gesture is", str) } // gesture is 12369 原始值（Raw Values） 枚举成员可以使用相同类型的默认值预先对应，这个默认值叫做：原始值 enum PokerSuit : Character { case spade = "♠" case heart = "♥" case diamond = "♦" case club = "♣" } var suit = PokerSuit.spade print(suit) // spade print(suit.rawValue) // ♠ print(PokerSuit.club.rawValue) // ♣ enum Grade : String { case perfect = "A" case great = "B" case good = "C" case bad = "D" } print(Grade.perfect.rawValue) // A print(Grade.great.rawValue) // B print(Grade.good.rawValue) // C print(Grade.bad.rawValue) // D 注意：原始值不占用枚举变量的内存 关联值与原始值区别:如果枚举变量是关联值,可以传入具体值进行关联, 传入的值会放在枚举变量内存里面 . 如果枚举类型后有冒号这种叫原始值, 原始值每个成员一开始就绑定死关联好的, 原始值不占用枚举变量的内存. 隐式原始值（Implicitly Assigned Raw Values） 如果枚举的原始值类型是Int、String，Swift会自动分配原始值 enum Direction : String { case north = "north" case south = "south" case east = "east" case west = "west" } 等价于 enum Direction : String { case north, south, east, west } print(Direction.north) // north print(Direction.north.rawValue) // north enum Season : Int { case spring, summer, autumn, winter } print(Season.spring.rawValue) //0 print(Season.summer.rawValue) //1 print(Season.autumn.rawValue) //2 print(Season.winter.rawValue) //3 enum Season : Int { case spring = 1, summer, autumn = 4, winter } print(Season.spring.rawValue) // 1 print(Season.summer.rawValue) // 2 print(Season.autumn.rawValue) // 4 print(Season.winter.rawValue) // 5 递归枚举（Recursive Enumeration）递归枚举前需要加关键字indirect indirect enum ArithExpr { case number(Int) case sum(ArithExpr, ArithExpr) case difference(ArithExpr, ArithExpr) } enum ArithExpr { case number(Int) indirect case sum(ArithExpr, ArithExpr) indirect case difference(ArithExpr, ArithExpr) } let five = ArithExpr.number(5) let four = ArithExpr.number(4) let two = ArithExpr.number(2) let sum = ArithExpr.sum(five, four) let difference = ArithExpr.difference(sum, two) func calculate(_ expr: ArithExpr) -> Int { switch expr { case let .number(value): return value case let .sum(left, right): return calculate(left) + calculate(right) case let .difference(left, right): return calculate(left) - calculate(right) } } calculate(difference) //7 MemoryLayout可以使用MemoryLayout获取数据类型占用的内存大小 enum Password { case number(Int, Int, Int, Int) case other } MemoryLayout&lt;Password>.stride // 40, 分配占用的空间大小 MemoryLayout&lt;Password>.size // 33, 实际用到的空间大小 MemoryLayout&lt;Password>.alignment // 8, 对齐参数 var pwd = Password.number(9, 8, 6, 4) pwd = .other MemoryLayout.stride(ofValue: pwd) // 40 MemoryLayout.size(ofValue: pwd) // 33 MemoryLayout.alignment(ofValue: pwd) // 8 思考下面枚举变量的内存布局?enum TestEnum { case test1, test2, test3 } var t = TestEnum.test1 t = .test2 t = .test3 enum TestEnum : Int { case test1 = 1, test2 = 2, test3 = 3 } var t = TestEnum.test1 t = .test2 t = .test3 enum TestEnum { case test } var t = TestEnum.test enum TestEnum { case test(Int) } var t = TestEnum.test(10) enum TestEnum { case test1(Int, Int, Int) case test2(Int, Int) case test3(Int) case test4(Bool) case test5 } var e = TestEnum.test1(1, 2, 3) e = .test2(4, 5) e = .test3(6) e = .test4(true) e = .test5 它们的switch语句底层又是如何实现的？ 进一步观察下面枚举的内存布局enum TestEnum { case test0 case test1 case test2 case test4(Int) case test5(Int, Int) case test6(Int, Int, Int, Bool) } enum TestEnum { case test0 case test1 case test2 case test4(Int) case test5(Int, Int) case test6(Int, Bool, Int) } enum TestEnum { case test0 case test1 case test2 case test4(Int) case test5(Int, Int) case test6(Int, Int, Bool, Int) }]]></content>
      <categories>
        <category>iOS笔记</category>
      </categories>
      <tags>
        <tag>Swift5.1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Swift5.1] 3-函数]]></title>
    <url>%2F2020%2F05%2F31%2FSwift5-1-3-%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[函数定义 形参默认是let，也只能是let func pi() -> Double { return 3.14 } func sum(v1: Int, v2: Int) -> Int { return v1 + v2 } sum(v1: 10, v2: 20) 无返回值 func sayHello() -> Void { print("Hello") } func sayHello() -> () { print("Hello") } func sayHello() { print("Hello") } 返回值（）实质是空元组 隐式返回（Implicit Return） 如果整个函数体是一个单一表达式，那么函数会隐式返回这个表达式，可以省略return func sum(v1: Int, v2: Int) -> Int { v1 + v2 } sum(v1: 10, v2: 20) // 30 返回元组：实现多返回值func calculate(v1:Int, v2: Int) -> (sum: Int, difference: Int, average: Int) { let sum = v1 + v2 return (sum, v1 - v2, sum >> 1) } let result = calculate(v1: 20, v2: 10) result.sum // 30 result.difference // 10 result.average // 15 函数的文档注释//函数的文档注释 /// 求和【概述】 /// /// 将2个整数相加【更详细的描述】 /// /// - Parameter v1: 第1个整数 /// - Parameter v2: 第2个整数 /// - Returns: 2个整数的和 /// /// - Note:传入2个整数即可【批注】 /// func sum(v1: Int, v2: Int) -> Int { v1 + v2 } 参考: https://swift.org/documentation/api-design-guidelines/ 参数标签（Argument Label） 可以修改参数标签 //time 用在函数体中， at用在函数调用 func goToWork(at time: String) { print("this time is \(time)") } goToWork(at: "08:00") // this time is 08:00 可以使用下划线 _ 省略参数标签 func sum(_ v1:Int, _ v2:Int) -> Int { v1 + v2 } sum(10, 20) 默认参数值（Default Parameter Value） 参数可以有默认值 func check(name: String = "nobody", age: Int, job: String = "none") { print("name=\(name), age=\(age), job=\(job)") } check(name: "Jack", age: 20, job: "Doctor") // name=Jack, age=20, job=Doctor check(name: "Rose", age: 18) // name=Rose, age=18, job=none check(age: 10, job: "Batman") // name=nobody, age=10, job=Batman check(age: 15) // name=nobody, age=15, job=none C++的默认参数值有个限制：必须从右往左设置。由于Swift拥有参数标签，因此并没有此类限制 但是在省略参数标签时，需要特别注意，避免出错 这里的middle不可以省略参数标签 func test(_ first: Int = 10, middle: Int, _ last: Int = 30) { } test(middle: 20) 可变参数（Variadic Parameter）func sum(_ numbers: Int...) -> Int { var total = 0 for number in numbers { total += number } return total } sum(10, 20, 30, 40) // 100 一个函数最多只能有1个可变参数 紧跟在可变参数后面的参数不能省略参数标签 // 参数string不能省略标签 func test(_ numbers: Int..., string: String, _ other: String) { } test(10, 20, 30, string: "Jack", "Rose") Swift自带的print函数/// - Parameters: /// - items: Zero or more items to print. /// - separator: A string to print between each item. The default is a single /// space (`" "`). /// - terminator: The string to print after all items have been printed. The /// default is a newline (`"\n"`). public func print(_ items: Any..., separator: String = " ", terminator: String = "\n") print(1, 2, 3, 4, 5) //1 2 3 4 5 print(1, 2, 3, 4, 5, separator: "_") //1_2_3_4_5 print("My name is Jake.", terminator: "") print("My age is 18.") // My name is Jake.My age is 18. 输入输出参数（In-Out Parameter） 可以用inout定义一个输入输出参数：可以在函数内部修改外部实参的值 func swapValues(_ v1: inout Int, _ v2: inout Int) { let tmp = v1 v1 = v2 v2 = tmp } var num1 = 10 var num2 = 20 swapValues(&amp;num1, &amp;num2) func swapValues(_ v1: inout Int, _ v2 : inout Int) { (v1, v2) = (v2, v1) } 可变参数不能标记为inout inout参数不能有默认值 inout参数只能传入可以被多次赋值的 上边所示代码中inout参数的本质是地址传递（引用传递） 如果传递给inout参数是计算属性, 有监听器的属性等内容, 其本质并非引用传递,在[属性]章节在做详细讲解 函数重载（Function Overload）规则: 函数名相同 参数个数不同 || 参数类型不同 || 参数标签不同 func sum(v1: Int, v2: Int) -> Int { v1 + v2 } func sum(v1: Int, v2: Int, v3: Int) -> Int { v1 + v2 + v3 } // 参数个数不同 func sum(v1: Int, v2: Double) -> Double { Double(v1) + v2 } // 参数类型不同 func sum(v1: Double, v2: Int) -> Double { v1 + Double(v2) } // 参数类型不同 func sum(_ v1: Int, _ v2: Int) -> Int { v1 + v2 } // 参数标签不同 func sum(a: Int, b: Int) -> Int { a + b } // 参数标签不同 sum(v1: 10, v2: 20) // 30 sum(v1: 10, v2: 20, v3: 30) // 60 sum(v1: 10, v2: 20.0) // 30.0 sum(v1: 10.0, v2: 20) // 30.0 sum(10, 20) // 30 sum(a: 10, b: 20) // 30 函数重载注意点 返回值类型与函数重载无关 默认参数值和函数重载一起使用产生二义性时，编译器并不会报错（在C++中会报错） func sum(v1: Int, v2: Int) -> Int { v1 + v2 } func sum(v1: Int, v2: Int, v3: Int = 10) -> Int { v1 + v2 + v3 } // 会调用sum(v1: Int, v2: Int) sum(v1: 10, v2: 20) 可变参数、省略参数标签、函数重载一起使用产生二义性时，编译器有可能会报错 func sum(v1: Int, v2: Int) -> Int { v1 + v2 } func sum(_ v1: Int, _ v2: Int) -> Int { v1 + v2 } func sum(_ numbers: Int...) -> Int { var total = 0 for number in numbers { total += number } return total } // error: ambiguous use of 'sum' sum(10, 20) 内联函数（Inline Function）如果开启了编译器优化（Release模式默认会开启优化），编译器会自动将某些函数变成内联函数 将函数调用展开成函数体 哪些函数不会被自动内联？ 函数体比较长 包含递归调用 包含动态派发 @inline 永远不会被内联（即使开启了编译器优化） @inline(never) func test() { print("test") } 开启编译器优化后，即使代码很长，也会被内联（递归调用函数、动态派发的函数除外） @inline( always) func test() { print("test") } 在Release模式下，编译器已经开启优化，会自动决定哪些函数需要内联，因此没必要使用@inline 函数类型（Function Type）每一个函数都是有类型的，函数类型由形式参数类型、返回值类型组成 func test() { } // () -> Void 或者 () -> () func sum(a:Int, b:Int) -> Int{ a + b } //(Int, Int) -> Int // 定义变量 var fn: (Int, Int) -> Int = sum fn(2, 3) // 5，调用时不需要参数标签 函数类型作为函数参数func sum(v1: Int, v2: Int) -> Int { v1 + v2 } func difference(v1: Int, v2: Int) -> Int { v1 - v2 } func printResult(_ mathFn: (Int, Int) -> Int, _ a: Int, _ b: Int) { print("Result: \(mathFn(a, b))") } printResult(sum, 5, 2) // Result: 7 printResult(difference, 5, 2) // Result: 3 函数类型作为函数返回值 返回值是函数类型的函数，叫做高阶函数（Higher-Order Function） func next(_ input: Int) -> Int { input + 1 } func previous(_ input: Int) -> Int { input - 1 } func forward(_ forward: Bool) -> (Int) -> Int { forward ? next : previous } forward(true)(3) // 4 forward(false)(3) // 2 typealias typealias用来给类型起别名 typealias Byte = Int8 typealias Short = Int16 typealias Long = Int64 给元组起别名 typealias Date = (year: Int, month: Int, day: Int) func test(_ date: Date) { print(date.0) print(date.year) } test((2011, 9, 10)) 给函数类型起别名 typealias IntFn = (Int, Int) -> Int func difference(v1: Int, v2: Int) -> Int { v1 - v2 } let fn: IntFn = difference fn(20, 10) // 10 func setFn(_ fn: IntFn) {} setFn(difference) func getFn() -> IntFn { difference } 按照Swift标准库的定义，Void就是空元组() public typealias Void = () 嵌套函数（Nested Function） 将函数定义在函数内部 func forward(_ forward: Bool) -> (Int) -> Int { func next(_ input: Int) -> Int { input + 1 } func previous(_ input: Int) -> Int { input - 1 } return forward ? next : previous } forward(true)(3) // 4 forward(false)(3) // 2]]></content>
      <categories>
        <category>iOS笔记</category>
      </categories>
      <tags>
        <tag>Swift5.1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Swift5.1] 2-流程控制]]></title>
    <url>%2F2020%2F05%2F30%2FSwift5-1-2-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[一、if-else 语句let age = 4 if age >= 22 { print("Get married") } else if age >= 18 { print("Being a adult") } else if age >= 7 { print("Go to school") } else { print("Just a child") } if后面的条件可以省略小括号 条件后面的大括号不可以省略 if后面的条件只能是Bool类型 二、while循环语句var num = 5 while num > 0 { print("num is \(num)") num -= 1 } // 打印5次 var num = -1 repeat { print("num is \(num)") }while num > 0 //打印1次 // num is -1 repeat-while 相当于C语言中的do-while 这里不用num– ,因为从swift3开始,去除自增(++) 、 自减(–) 运算符 三、for循环语句1)区间运算符: a…b 代表 a &lt;= 取值 &lt;= blet name = ["Anna", "Alex", "Brian", "Jack"] for i in 0...3 { print(names[i]) } //Anna Alex Brian Jack 常量存储遍历范围 let name = ["Anna", "Alex", "Brian", "Jack"] let range = 1...3 //CloseRang&lt;Int> for i in range { print(names[i]) } //Alex Brian Jack 常量和变量定义取值范围 let a = 1 var b = 2 for i in a...b { print(names[i]) } // Alex Brian for i in a...3 { print(names[i]) } // Alex Brian Jack i 默认就是let , 有需要时可以声明为var for var i in 1...3 { i += 5 print(i) } // 6 7 8 循环中用不到 i 可以用_省略 for _ in 1...3 { print("for") } //打印3次 2)半开区间运算符: a…b , a &lt;= 取值 &lt; bfor i in 1..&lt;5 { print(i) } // 1 2 3 4 3) for -区间运算符用在数组上let names = ["Anna", "Alex", "Brian", "Jack"] for name in names[0...3] { print(name) } //Anna Alex Brian Jack 单侧区间: 让区间朝同一个方向尽可能的远 for name in names[2...] { print(name) } // Brian Jack for name in names[2...] { print(name) } // Brian Jack for name in names[...2] { print(name) } // Anna Alex Brian for name in names[..&lt;2] { print(name) } // Anna Alex let range = ...5 range.contains(7) //false range.contains(4) //ture range.contains(-2) //ture 4) 区间类型 闭区间类型 ClosedRange&lt;Int&gt; 半开半闭区间类型 Range&lt;Int&gt; 单侧区间类型 PartialRangeThrough&lt;Int&gt; let range1 : ClosedRange&lt;Int> = 1...3 let range2 : Range&lt;Int> = 1..&lt;3 let range3 : PartialRangeThrough&lt;Int> = ...5 字符、字符串也能使用区间运算符, 但默认不能用在for-in中 let stringRange1 = "cc"..."ff" // ClosedRange&lt;String> stringRange1.contains("cb") //false stringRange1.contains("dz") //true stringRange1.contains("fg") //false let stringRange2 = "a"..."f" stringRange2.contains("d") //true stringRange2.contains("h") //false \0到~囊过了所有可能要用到的ASCII字符 let characterRange:ClosedRange&lt;Character> = "\0"..."~" characterRange.contains("G") //true 5) 带间隔的区间值let hours = 11 let hourInterval = 2 //tickMark 的取值: 从4开始, 累加2, 不超过11 for tickMark in stride(from: 4, to: hours, by: hourInterval) { print(tickMark) } // 4 6 8 10 四、Switch语句1)常规用法 case、default后面不能写大括号 var number = 1 switch number { case 1: print(" ") break case 2: print("number is 2") break default: print("number is other") break } // number is 1 默认可以不写break,并不会贯穿到后面的条件 switch number { case 1: print(" ") case 2: print("number is 2") default: print("number is other") } // number is 1 2) fallthrough 使用fallthrough可以实现贯穿效果 var number = 1 switch number { case 1: print("number is 1") fallthrough case 2: print("number is 2") default: print("number is other") } // number is 1 // number is 2 3) switch注意点 switch 必须要保证能处理所有情况 case 、default要后面至少要有一条语句 如果不想做任何事, 加个break即可 var number = 1 switch number { case 1: print("number is 1") fallthrough case 2: print("number is 2") default: break } 如果能保证已处理所有情况, 也可以不必使用default enum Answer {case right, wrong} let answer = Answer.right switch answer { case Answer.right: print("right") default: print("wrong") } 由于已确定answer是Answer类型, 因此可以省略Answer enum Answer {case right, wrong} let answer = Answer.right switch answer { case .right: print("right") case .wrong: print("wrong") } 4)复合条件switch也支持Character String 类型 let string = "Jack" switch string { case "Jack": fallthrough case "Rose": print("Right person") default: break } //Right person switch string { case "Jack", "Rose": print("Right person") default: break } //Right person let character : Character = "a" switch character { case "a", "A": print("The letter A") default: print("Not the letter a") } //The letter A 5) 区间匹配 元组匹配let count = 62 switch count { case 0: print("none") case 1..&lt;5: print("a few") case 5..&lt;12: print("several") case 12..&lt;100: print("dozens of") case 100..&lt;1000: print("hundreds of") default: print("many") } // dozens of 可以使用下划线或略某个值 关于case匹配问题, 属于模式匹配(Pattern Matching)的范畴, 以后会再次详细展开讲解 let point = (1, 1) switch point { case (0, 0): print("the origin") case (_, 0): print("on the x-axis") case (0, _): print("on the y-axis") case (-2...2 , -2...2): print("inside the box") default: print("outside of the box") } //inside the box 6) 值绑定 必要时let 也可以改为var let point = (2, 0) switch point { case (let x , 0): print("on the x-axis with an x value of \(x)") case (0 , let y): print("on the y-axis with an y value of \(y)") case let(x , y): print("somewhere else at (\(x), \(y))") } // on the x-axis with an x value of 2 五、where语句let point = (1, -1) switch point { case let (x, y) where x == y: print("on the line x == y") case let (x, y) where x == -y: print("on the line x == -y") case let (x, y): print("(\(x), \(y)) is just some arbitrary point") } // on the line x == -y 将所有正数加起来 var numbers = [10, 20, -10, -20, 30, -30] var sum = 0 for num in numbers where num > 0 { //使用where过滤num sum += num } print(sum) //60 六、标签语句outer: for i in 1...4 { for k in 1...4 { if k == 3 { continue outer } if i == 3 { break outer } print("i == \(i), k == \(k)") } }]]></content>
      <categories>
        <category>iOS笔记</category>
      </categories>
      <tags>
        <tag>Swift5.1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Swift5.1] 1-基本数据类型]]></title>
    <url>%2F2020%2F05%2F30%2FSwift5-1-1-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[Swift开源库 print 函数 不用编写main函数, Swift将全局范围内的首句可执行代码作为程序入口. 一句代码尾部可以省略分号 , 多句代码写到同一行时必须用分号( ; )隔开 用var定义变量, let定义常量, 编译器能自动推断出变量\常量的类型 let a = 1 let b = 2 let c = a + b c + = 3 拼接打印 var a = 10 print("Hello World! - \(a)") //打印 Hello World! - 10 Playground 快捷键 Playground可以快速预览代码效果, 是学习语法的好帮手 Command + Shift + Enter: 运行整个Playground Shift + Enter 运行截止到某一行代码 注释// 单行注释 /* 多行注释 */ /* a /* 多行注释嵌套 */ b */ 注释支持markup语法, 类似markload 开启markup渲染效果: Editor -&gt; Show Rendered Markup 注意: Markup 只在Playground 常量 常量只能赋值一次 常量的值不要求在编译时期确定, 但使用之前必须赋值1次 let age = 10 let age2 : Int age2 = 20 func getAge() -> Int{ return 30; } let age3 = getAge() 常量, 变量在初始化前, 都不能使用 let age : Int var height : Int print(age) //错误提示: Constant 'age' used before being initialized print(height) //错误提示: Variable 'height' used before being initialized 定义常量时，需要明确类型 let age age = 18 //错误提示 Found an unexpected second identifier in constant declaration; is there an accidental break? 标识符 标识符(比如常量名、变量名、 函数名)几乎可以使用任何字符 标识符不能以数字开头, 不能包含空白字符、 制表符、 箭头灯特殊字符 func 🐱🍉() { print("888") } 🐱🍉() let 🥛 = "milk" var 🍺 = "bear" 数据类型 整数类型: Int8、Int16、Int32、Int64、UInt8、UInt16、UInt32、UInt64 在32bit平台，Int等价于Int32; 在64bit平台，Int等价于Int64 整数的最值：UInt8.max、Int16.min 一般情况下，都是直接使用Int即可 浮点类型：Float, 32位，精度只有6位； Double, 64位，精度至少15位 字面量 布尔 let bool = true //取反是false 字符串 let string = "你好" 字符(可存储ASCII字符、Unicode字符) let character: Character = "🍎" 整数 let intDecimal = 18 //十进制 let intBinary = 0b10001 //二进制 let intOctal = 0o33 //八进制 let intHexadecimal = 0x13 //十六进制 整数和浮点数可以添加额外的零或者添加下划线来增强可读性 100_1000、1_000_000.000_000_1、000123.456 浮点数 let doubleDecimal = 123.0 //十进制，等价于1.23e2, 0.0123等价于1.23e-2 let doubleHexadecimal1 = 0xFp2 //十六进制，意味着15*2^2, 相当于十进制60.0 let doubleHexadecimal2 = 0xFp-2 //十六进制，意味着15*2^-2, 相当于十进制3.75 以下表示12.3456十进制：12.3456 1.23456e1十六进制：0xC.3p0 数组 let array = [1, 3, 5, 7, 9] 字典 let dictionary = ["age" : 18, "height" : 177, "weight": 130] 类型转换 整数转换 let int1: UInt16 = 2_000 let int2: UInt8 = 1 let int3 = int1 + UInt16(int2) //2001 整数 浮点数转换 let int = 3 let double = 0.14157 let pi = Double(int) + double //3.14157 let intPi = Int(pi) //3 字面量可以直接相加, 以为数字字面量本身没有明确的类型 let result = 3 + 0.14159 //3.14159 元组//通过下标访问元组元素 let http404Error = (404, "Not Found") print("The status code is \(http40Error.0)") //The status code is 404 //将http404Error中元素, 一一对应给新元组元素 let (statusCode, statusMessage) = http404Error print("The status code is \(statusCode)") // The status code is 404 // _代表第二个参数不接收 let (justTheStatusCode, _) = http404Error //以标签形式初始化元组, 可以通过标签访问元素 let http200Status = (statusCode:200, description:"OK") print("The status code is \(http200Status.statusCode)") //The status code is 200]]></content>
      <categories>
        <category>iOS笔记</category>
      </categories>
      <tags>
        <tag>Swift5.1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[iOS面试]第12章 第三方框架相关面试问题]]></title>
    <url>%2F2020%2F05%2F29%2FiOS%E9%9D%A2%E8%AF%95-%E7%AC%AC12%E7%AB%A0-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[注意：本文主讲第三方框架相关面试问题，包括AFNetworking、SDWebImageView、Reactive Cocoa、AsyncDisplayKit。 一、AFNetworking1、AFN框架图问题:AFNetworking整体框架是怎样的? 会话层:NSURLSession 网络监听模块:监听网络变化 进行逻辑处理 网络安全模块: 请求序列化 响应序列化 UIKit集成模块 2、AFN主要类关系图 AFURLSessionManager 功能 创建和管理NSURLSession、NSURLSessionTask 实现NSURLSessionDelegate等协议的代理方法 .用来处理网络请求过程中重定向, 核心的网络响应数据处理. 引入AFSecurityPolicy保证请求安全.比如发送https请求时, 会涉及证书校验, 公钥验证等 引入AFNetworkReachabilityManager监控网络状态 发送一个GET方式的HTTP请求 二、SDWebImageView 异步下载图片并且支持缓存的框架 框架简图 UIImageView+ WebCache : SDWebImageManager : 核心工作类 SDImageCache : 图片缓存: 磁盘缓存处理 + 内存缓存处理 SDWebImageDownloader: 图片下载器 加载图片流程1.首先根据相应图片请求URL所对应的key, 查找内存缓存, 如果找到返回给调用方2.如果没有查找到,查找磁盘缓存,如果找到返回给调用方3.如果磁盘缓存没有查找到,就进行相应的网络下载 三、Reactive Cocoa函数响应式编程框架 概念RAC首先是一个函数响应式编程的第三方库 1)信号RAC中的核心类RACSignal ,RACSignal继承自RACStreamRACSignal主要有4个子类: RACDynamicSignal: RACReturnSignal: RACEmptySignal RACErrorSignal 信号代表一连串的状态,这么一个类的封装. 在状态改变是,对应的订阅者RACSubScriber就会收到通知执行相应的命令 RAC使用类簇模式, 抽象工厂模式. 返回的对象都是同一个对象, 实际上通过不同方法创建出来的具体对象也不同. 2)订阅RACSubScriber问题:怎样实现订阅? 问题:订阅内部执行原理? 产生RACSubScriber类后, 内部持有一个block类型的成员变量didSubscribe, 调用RACSubScriber 的sendNext方法时实际调用内部保存的block { [RACSignal return:@3]; [RACSignal subScribedNext:^(id x){ NSLog(@&quot;%@&quot;, x); }] } 四、AsyncDisplayKit 提升iOS界面渲染性能的一个框架 1、ASDK处理问题问题: AsyncDisplayKit主要处理什么问题? 主要通过减轻主线程压力, 将更多的事情尽量挪到子线程去做.主要分3方面:1&gt; Layout 解决布局的耗时运算: 文本宽高计算和视图布局计算.实际上将文本计算和布局计算由主线程迁移到子线程,来减少主线程的工作消耗, 腾挪出更多时间响应用户交互.2&gt; Rendering 渲染: 文本渲染 , 图片解码和图形绘制.3&gt; UIKit Objects: 对象创建 对象调整 对象销毁 2、ASDK基本原理 基本原理: 针对ASNode的修改和提交, 会对其进行封装并提交到一个全局容器中 ASDK也在RunLoop中注册一个Observer 当RunLoop进入休眠前, ASDK执行该loop内提交的所有任务 第三方框架面试总结:问题:AFNetworking的整体结构是怎样的? 问题:SDWebImage是怎样加载图片的?(图片加载流程) 问题:RAC的信号订阅是什么意思?答:信号一连串状态的抽象, 订阅信号通过RACSubScriber实现, RACSubScriber内部持有一个block类型的成员变量didSubscribe, 调用RACSubScriber 的sendNext方法时实际调用内部保存的block, 问题:ASDK实现原理是怎样的?答: 封装ASNode节点, 对于视图属性设置都转化为ASNode的设置,这部分可以放在后台线程中执行,RunLoop将要休眠前,接收一个通知提前全局容器对应的ASNode,一次性设置给UIView. 课程总结1.系统的UI事件传递机制是怎样的? 2.KVO的实现原理是怎样的? 3.简答说说消息传递机制的消息转发流出 4.当一个obj废弃的时候, 指向它的weak指针为何会自动置为nil? 5.请你简单讲下iOS是怎样进行内存管理的? 6.Block实质是怎样的?使用Block为何容易产生循环引用? 7.简单说说怎样利用GCD实现高效的多读单写逻辑? 8.RunLoop为何能左右有事做事,没事休息? 9.怎样解决DNS劫持? 10.分别说说什么是桥接模式, 责任链模式? 11.怎样设计一个图片缓存框架?网络框架? 12.请编写查找一个字符串中, 第一个只出现一次的字符的算法 13.AFNetworking大致是怎样实现的?]]></content>
      <categories>
        <category>iOS笔记</category>
      </categories>
      <tags>
        <tag>iOS面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[iOS面试]第11章 算法相关面试问题]]></title>
    <url>%2F2020%2F05%2F29%2FiOS%E9%9D%A2%E8%AF%95-%E7%AC%AC11%E7%AB%A0-%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[注意：本文主讲算法相关面试问题，包括字符串反转、链表反转、有序数组合并、Hash算法、查找两个子视图的共同父视图、求无序数组当中的中位数。 一、字符串反转问题:给定字符串”hello, world”, 实现将其反转.输出结果: dlrow,oleh 答: void char_reverse(char* cha) { // 指向第一个字符 char* begin = cha; // 指向最后一个字符 char* end = cha + strlen(cha) - 1; while (begin &lt; end) { // 交换前后两个字符,同时移动指针 char temp = *begin; *(begin++) = *end; *(end--) = temp; } } //1.字符串反转 char ch[] = &quot;hello,world&quot;; char_reverse(ch); printf(&quot;reverse result is %s \n&quot;, ch); //打印 reverse result is dlrow,olleh 二、链表反转链表头插法思想 ReverseList.h //ReverseList.h // 定义一个链表 struct Node { int data; struct Node *next; }; @interface ReverseList : NSObject // 链表反转 struct Node* reverseList(struct Node *head); // 构造一个链表 struct Node* constructList(void); // 打印链表中的数据 void printList(struct Node *head); @end ReverseList.m //ReverseList.m @implementation ReverseList struct Node* reverseList(struct Node *head) { // 定义遍历指针，初始化为头结点 struct Node *p = head; // 反转后的链表头部 struct Node *newH = NULL; // 遍历链表 while (p != NULL) { // 记录下一个结点 struct Node *temp = p-&gt;next; // 当前结点的next指向新链表头部 p-&gt;next = newH; // 更改新链表头部为当前结点 newH = p; // 移动p指针 p = temp; } // 返回反转后的链表头结点 return newH; } struct Node* constructList(void) { // 头结点定义 struct Node *head = NULL; // 记录当前尾结点 struct Node *cur = NULL; for (int i = 1; i &lt; 5; i++) { struct Node *node = malloc(sizeof(struct Node)); node-&gt;data = i; // 头结点为空，新结点即为头结点 if (head == NULL) { head = node; } // 当前结点的next为新结点 else{ cur-&gt;next = node; } // 设置当前结点为新结点 cur = node; } return head; } void printList(struct Node *head){ struct Node* temp = head; while (temp != NULL) { printf(&quot;node is %d \n&quot;, temp-&gt;data); temp = temp-&gt;next; } } @end 执行调用 //单链表反转 struct Node* head = constructList(); printList(head); printf(&quot;-----------\n&quot;); struct Node* newHead = reverseList(head); printList(newHead); 三、有序数组合并 // 将有序数组a和b的值合并到一个数组result当中，且仍然保持有序 void mergeList(int a[], int aLen, int b[], int bLen, int result[]) { int p = 0; // 遍历数组a的指针 int q = 0; // 遍历数组b的指针 int i = 0; // 记录当前存储位置 // 任一数组没有到达边界则进行遍历 while (p &lt; aLen &amp;&amp; q &lt; bLen) { // 如果a数组对应位置的值小于b数组对应位置的值 if (a[p] &lt;= b[q]) { // 存储a数组的值 result[i] = a[p]; // 移动a数组的遍历指针 p++; }else{ // 存储b数组的值 result[i] = b[q]; // 移动b数组的遍历指针 q++; } // 指向合并结果的下一个存储位置 i++; } // 如果a数组有剩余 while (p &lt; aLen) { // 将a数组剩余部分拼接到合并结果的后面 result[i] = a[p++]; i++; } // 如果b数组有剩余 while (q &lt; bLen) { // 将b数组剩余部分拼接到合并结果的后面 result[i] = b[q++]; i++; } } 执行调用 int a[5] = {1,4,6,7,9}; int b[8] = {2,3,5,6,8,10,11,12}; //用于存储归并结果 int result[13]; //归并操作 mergeList(a, 5, b, 8, result); //打印归并结果 printf(&quot;merge result is &quot;); for (int i = 0; i &lt; 13; i++) { printf(&quot;%d &quot;, result[i]); } //输出 merge result is 1 2 3 4 5 6 6 7 8 9 10 11 12 四、Hash算法问题:在一个字符串中找到第一个只出现一次的字符如:输入”abaccdeff” , 则输出b 算法思想: 字符(char)是一个长度为8的数据类型,因此总共有可能256中可能. 每个字母根据其ASCII码值作为数组的下标对应数组的一个数字. 数组中存储的是每个字符出现的次数. 哈希表例: 给定值是字母a, 对应ASCII值是97, 数组索引下标为97.哈希函数: 建立字母或字符到它所存储位置index的一个映射关系. f(key)存储和查找都通过该函数, 有效提高查找效率.f(char) =&gt; index //查找第一个只出现一次的字符 char findFirstChar(char* cha) { char result = &#39;\0&#39;; // 定义一个数组 用来存储各个字母出现次数 int array[256]; // 对数组进行初始化操作 for (int i=0; i&lt;256; i++) { array[i] =0; } // 定义一个指针 指向当前字符串头部 char* p = cha; // 遍历每个字符 while (*p != &#39;\0&#39;) { // 在字母对应存储位置 进行出现次数+1操作 array[*(p++)]++; } // 将P指针重新指向字符串头部 p = cha; // 遍历每个字母的出现次数 while (*p != &#39;\0&#39;) { // 遇到第一个出现次数为1的字符，打印结果 if (array[*p] == 1) { result = *p; break; } // 反之继续向后遍历 p++; } return result; } 执行结果 char cha[] = &quot;abaccdeff&quot;; char fc = findFirstChar(cha); printf(&quot;this char is %c \n&quot;, fc); //输出this char is b 五、查找两个子视图的共同父视图倒序比较找到第一个不一样的 - (NSArray &lt;UIView *&gt; *)findCommonSuperView:(UIView *)viewOne other:(UIView *)viewOther { NSMutableArray *result = [NSMutableArray array]; // 查找第一个视图的所有父视图 NSArray *arrayOne = [self findSuperViews:viewOne]; // 查找第二个视图的所有父视图 NSArray *arrayOther = [self findSuperViews:viewOther]; int i = 0; // 越界限制条件 while (i &lt; MIN((int)arrayOne.count, (int)arrayOther.count)) { // 倒序方式获取各个视图的父视图 UIView *superOne = [arrayOne objectAtIndex:arrayOne.count - i - 1]; UIView *superOther = [arrayOther objectAtIndex:arrayOther.count - i - 1]; // 比较如果相等 则为共同父视图 if (superOne == superOther) { [result addObject:superOne]; i++; } // 如果不相等，则结束遍历 else{ break; } } return result; } - (NSArray &lt;UIView *&gt; *)findSuperViews:(UIView *)view { // 初始化为第一父视图 UIView *temp = view.superview; // 保存结果的数组 NSMutableArray *result = [NSMutableArray array]; while (temp) { [result addObject:temp]; // 顺着superview指针一直向上查找 temp = temp.superview; } return result; } 六、求无序数组当中的中位数方案: 1&gt;排序算法+中位数 2&gt;利用快排思想(分治思想) 排序算法+中位数 排序算法: 冒泡排序, 快速排序, 堆排序… 中位数:当n为奇数时, (n+1)/2 ;当n为偶数时, (n/2 + (n/2 + 1)) / 2 ; 快排思想 快排思想: 选取关键字, 高低交替扫描 任意挑一个元素, 以该元素为支点, 划分集合为两部分.如果左侧集合长度恰为 (n- 1)/2, 那么支点恰为中位数.如果左侧长度恰 &lt; (n- 1)/2, 那么中位点在右侧; 反之, 中位数在左侧.进入相应的一侧继续寻找中位点 int findMedian(int a[], int aLen) { int low = 0; int high = aLen - 1; int mid = (aLen - 1) / 2; int div = PartSort(a, low, high); while (div != mid){ if (mid &lt; div){ //左半区间找 div = PartSort(a, low, div - 1); } else{ //右半区间找 div = PartSort(a, div + 1, high); } } //找到了 return a[mid]; } int PartSort(int a[], int start, int end) { int low = start; int high = end; //选取关键字 int key = a[end]; while (low &lt; high) { //左边找比key大的值 while (low &lt; high &amp;&amp; a[low] &lt;= key){ ++low; } //右边找比key小的值 while (low &lt; high &amp;&amp; a[high] &gt;= key){ --high; } if (low &lt; high){ //找到之后交换左右的值 int temp = a[low]; a[low] = a[high]; a[high] = temp; } } int temp = a[high]; a[high] = a[end]; a[end] = temp; return low; } 执行调用 int list[9] = {12,3,10,8,6,7,11,13,9}; // 3 6 7 8 9 10 11 12 13 // ^ int median = findMedian(list, 9); printf(&quot;the median is %d \n&quot;, median); // the median is 9]]></content>
      <categories>
        <category>iOS笔记</category>
      </categories>
      <tags>
        <tag>iOS面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[iOS面试]第10章 架构框架相关面试问题]]></title>
    <url>%2F2020%2F05%2F26%2FiOS%E9%9D%A2%E8%AF%95-%E7%AC%AC10%E7%AB%A0-%E6%9E%B6%E6%9E%84%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[注意：本文主讲架构框架相关面试问题，包括图片缓存、阅读时长统计、复杂页面结构、客户端整体架构。 问题: 架构框架解决什么问题?答: 引入架构框架为了实现模块化, 将各功能按模块进行划分 分层 解耦 降低代码重合度 一、图片缓存1、图片缓存问题:怎样设计一个图片缓存框架? 首先有Manager模块, 用以协调和调度框架内部各个模块 内存管理模块. 比如: 涉及图片缓存 就需要模拟计算机组成原理涉及到的多级缓存思想运用 图片磁盘缓存处理模块. 网络模块. 本地没有图片支持通过网络下载图片以上构成基本图片框架,如果图片压缩, 保存图片需要解压缩的话,需要以下模块 codeManager 解码相关管理者. 图片解码模块. 图片压缩/解压缩模块. 2、图片读写问题:图片通过什么方式进行读写,过程是怎样的?答: 以图片URL的单向Hash值作为Key, 存储到图片对应框架中 图片读取按照多级缓存读取图片,提交查找效率 3、内存设计问题:内存的设计上需要考虑哪些问题?答: 存储的Size. (内存存储空间大小) 淘汰策略. (有size限制, 后边再有新图片,需要有淘汰策略) 存储Size需要考虑图片大小本身,以及不同图片大小的使用频率高低问题.通过队列方式存取图片. 淘汰策略:考虑两种方案 以队列先进先出的方式淘汰 模拟计算机中LRU(Least Recently Used 最近最少使用)算法. (如30分钟之内是否使用过) 具体淘汰策略:1&gt;定时检查.2&gt;提高检查触发频率: 每次进行读写时 前后台切换时.注意开销问题 补充: LRU算法是核心思想是：如果一个数据在最近一段时间都没有被用到，那么它在将来被使用到的可能性也很小。故当缓存空间已满的情况下，我们需要淘汰掉最久没有被访问到的数据。理想的LRU算法读写是时间复杂度应该都为O(1)。 4、磁盘设计问题:磁盘设计需要考虑哪些问题? 存储方式 大小限制(如100MB) 淘汰策略(如某一图片存储时间距今已超过7天) 5、网络设计问题:网络部分的设计需要考虑哪些问题? 图片请求最大并发量 (比如同一时间最大请求数量,限定在10张或者20张) 请求超时策略 (比如超时,可以采取重试机制再去请求图片, 2次再失败先不请求这张图片) 请求优先级 (比如下载或者缓存的图片是否当前用户最紧急使用, 如果是请求优先级高些) 6、图片解码问题:对于不同格式图片,解码采用什么方式来做? 应用策略模式对不同图片格式进行解码 问题:在哪个阶段做图片解码处理? 磁盘读取后 (从磁盘读取是未解码,放到内存中最好解码完成, 因为系统在显示图片前会在主线程进行图片解码操作,减少主线程压力) 网络请求返回后 7、线程处理 二、阅读时长统计1、框架设计问题:怎样设计一个时长统计框架? 1)记录器: 对每一条时长统计数据进行记录 页面式记录器 :常见场景:记录用户读取或者访问页面时长,一般从页面push开始作为阅读时长开始节点, pop后代表记录结束) 流式页面记录器 :比如浏览微博flow流以及腾讯新闻, 头条新闻,这种新闻的阅读记录, 每条定义为流式记录器 自定义式记录器 :比如实际业务开发,有不同业务场景,微博, 腾讯新闻横滑式新闻条目的播放,由业务方控制具体控制开始结束的逻辑 2)记录管理者: 管理通过记录器记录的时长统计数据 记录缓存 : 磁盘存储 : 用来维护和处理异常场景,可能到时内存缓存丢失问题 上传器 : 用来将本地所记录下来的时长数据上传给server端 2、记录的缓存&amp;存储1)问题: 为何要有不同类型记录器,你的考虑是什么?答: 基于不同分类场景提供的关于记录的封装, 适配 2)问题:记录的数据会由于某种原因丢失, 你是怎样处理的?(考察降低丢失率, 不是每条都不丢失) 定时写磁盘比如每满50条,进行磁盘写入 限定内存缓存条数(如10条), 超过该条数, 即写磁盘 3、记录上传器问题: 关于延时上传的具体场景有哪些? 前后台切换 从无网到有网的变化 通用的轻量接口捎带如果以企业级实践方式落地, 建议使用前两种是最优的, 最后有耦合在里边. 问题: 长传时机是怎样把控的?答: 立刻上传 延时上传 定时上传 三、复杂页面结构 MVVM框架思想 ReactNative的数据流思想 系统UIView更新机制的思想 FaceBook的开源框架AsyncDisplayKit关于预排版的设计思想 1、MVVM 2、ReactNative的数据流思想 任何一个子孙节点是没有权利做自己的变化更新的, 它必须要把自己变化更新的消息传递给根节点, 由根节点自顶向下方式询问哪些需要更新.由主动行为变为被动行为. 四、客户端整体架构问题:你所在公司客户端整体架构是怎样的?如果让你设计,怎样设计客户端的整体架构? 独立App的通用层比如通用层中可以有时长统计框架, 崩溃统计, 网络的第三方库. 这一层架构放到任何一个App中都可以起到底层支撑作用, 独立于APP 通用业务层:针对当前公司有某些通用的基础组件, 比如自定义布景控件, 特殊UIImageView的封装. 这些是和当前公司业务有关的, 对于整体App来说各个业务线对于通用控件都有需求,把这些内容沉降到通用业务层. 中间层: 协调解耦作用为了实现业务A 业务B 业务C 业务D的解耦 各个业务代码 问题:业务之间的解耦通信方式 OpenURL 依赖注入 中间层做业务A和业务C解耦, 业务C通过注入方式将自己注入到中间层, 业务A去中间层获取所依赖的方法或者成员变量.例如: 中间层实现策略: 某一个业务方通过一个protocal注册到对应中间层中, 同时实现中间层代理方法返回给中间层一个具体实例对象. 业务A使用时, 可以通过事先和业务C商量的协议,从中间层中根据某一方法获取遵从某一协议的实例, 然后在业务A中把实例当做完全遵从协议透明对象来使用. 五、架构框架面试总结]]></content>
      <categories>
        <category>iOS笔记</category>
      </categories>
      <tags>
        <tag>iOS面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[iOS面试]第9章 设计模式相关面试问题]]></title>
    <url>%2F2020%2F05%2F26%2FiOS%E9%9D%A2%E8%AF%95-%E7%AC%AC9%E7%AB%A0-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[注意：本文主讲设计模式相关面试问题，包括 常用六大设计原则、责任链、桥接、适配器、单例、命令。 一、六大设计原则 单一职责原则 依赖倒置原则 开闭原则 里氏替换原则 接口隔离原则 迪米特法则 1)单一职责原则 一个类只做一件事 比如: UIView 和 CALayer关系, UIView只负责事件传递和事件响应,CALayer专门负责动画以及视图的展示 2)依赖倒置原则 抽象接口不依赖于具体实现, 具体实现可以依赖于抽象接口 比如定义一些处理数据访问,增删改查接口方法时,所有上层的业务调用都应该依赖于定义的抽象接口. 至于接口内部具体实现是用数据库,还是用文件,以及用plist, userdefault, 对上层业务来说是感知不到的, 这就体现了通过抽象接口反转依赖.对于上层业务只依赖于接口定义,比如增删改查,对于内部采用哪种存储方案,上层业务是不关注的.也没必要把具体存储方案暴露给使用方. 3)开闭原则 对修改关闭, 对扩展开放 比如:定义一个类考虑后期扩展性和灵活性. 前期针对一个需求,要考虑多个版本的迭代需求. 对类的成员变量定义尽量谨慎,避免后面频繁修改这个类.类的数据结构定义后,后面就是根据需求提供接口问题, 包括子类继承. 4)里氏替换原则 父类可以被子类无缝替换, 且原有功能不受任何影响 比如: KVO机制 5)接口隔离原则 使用多个专门的协议,而不是一个庞大臃肿的协议 协议中方法应当尽量少 比如: UITableViewDelegate专门处理TableView回调代理事件UITableViewDateSource专门用于获取TableView数据源 6)迪米特法则 一个对象对其他对象有尽可能少的了解 高内聚,低耦合 因为模块和模块之间, 要想解除耦合,体现出编码规范让对象尽量少的知道其他对象都有什么,包括成员变量,属性以及它的方法. 二、责任链责任链模式可以解决任务的依赖关系问题. 举例:一个对象中有一个属性叫nextResponder, 该属性与当前对象属于同一个类, 当当前对象不能执行某个方法时, 就调用他的nextResponder来执行同样的方法, 将任务传递下去.使用这种方式时, 当任务的依赖顺序发生改变时, 只需要调整其nextResponder的指向即可调整他的响应链顺序.我们还可以根据后端给出的响应来动态调整响应链顺序, 系统中使用责任链的设计模式处理了UI事件的传递机制 三、桥接 使用者持有抽象的基类ClassA, ClassA持有抽象的基类B, 调用时, 根据需要将A1/A2/A3赋值给调用者原先持有的属性, 在将B1/B2/B3根据需求赋值给ClassA, 这样我们可以自由组合调用者和其内部的实际调用, 而作为桥梁的ClassA与ClassB本身不关心他们的实际调用. 问题:怎样理解桥接设计模式?(简单语言描述桥接模式是什么?)桥接模式可以解决 列表和多套数据耦合的问题. 四、适配器一个现有类需要适应变化的问题适配器分为: 对象适配器 类适配器. 当我们有个一个年代久远的基类, 我们不便对其添加对象和方法时, 我们就可以为其添加适配器, 使一个类持有该基类, 在调用这个基类的前后我们可以插入自己的代码, 来适配新的需求. 这也就是做了一次简单的封装. - (void)request{ //适配逻辑 [被适配对象 某方法] //适配逻辑 } 五、单例模式 在单例方法中创建实例使用 [[super allocWithZone:Null] init]; 重写自身的allocWithZone方法在其内部调用单例方法保证创建永远是一个单例 遵守Copy协议, 重写copyWithZone方法, 返回self, 令其不能被copy 六、命令模式问题:命令模式主要表达的是什么?我们一般用命令模式干什么? 命令模式用来做 行为参数化 命令模式用来 减低代码重合度 我们可以将一些事件拆分开来, 事件的执行及其回调上下文等封装成commend对象, 调用commend的管理者封装为Manager单例对象, 以此来减少代码的分散, 调用时被转换成, 生成命令, 中央管理器执行命令的命令模式. 这和NSUrlSession使用的task模式类似, 创建task, 执行task的感觉 设计模式面试总结： 你都知道哪些设计原则, 请谈谈你的理解?答: 单一职责原则, 依赖倒置原则, 开闭原则, 里氏替换原则, 接口隔离原则, 迪米特法则. 能否用一幅图简单的表示桥接模式的主体结构? UI事件的传递机制是怎样实现的?你对其中运用到的设计模式是怎样理解的?答:UI视图角度回答设计模式角度回答 -&gt; 责任链模式. 手写单例实现重写allcoWithZone/copyWithZone方法, 使用[super allocWithZone:]创建单例 + (id)sharedInstance { // 静态局部变量 static Mooc *instance = nil; // 通过dispatch_once方式 确保instance在多线程环境下只被创建一次 static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ // 创建实例 instance = [[super allocWithZone:NULL] init]; }); return instance; } // 重写方法【必不可少】 + (id)allocWithZone:(struct _NSZone *)zone{ return [self sharedInstance]; } // 重写方法【必不可少】 - (id)copyWithZone:(nullable NSZone *)zone{ return self; }]]></content>
      <categories>
        <category>iOS笔记</category>
      </categories>
      <tags>
        <tag>iOS面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[iOS面试]第8章 网络相关面试问题]]></title>
    <url>%2F2020%2F05%2F25%2FiOS%E9%9D%A2%E8%AF%95-%E7%AC%AC8%E7%AB%A0-%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[注意：本文主讲网络相关面试问题，包括HTTP协议、HTTPS协议与网络安全、TCP/UDP区别、DNS解析。 一、HTTP协议（超文本传输协议）HTTP协议主要包含内容:请求/响应报文、连接建立流程、HTTP特点。 1、请求/响应报文 请求报文格式:请求方法 +请求URL +协议版本+请求首子段键值对 +报文主体（一般在请求中是没有报文主体的） 响应报文格式:协议版本 +状态吗 +响应首字段 +响应报文主体 1)、http的请求方式都有哪些？GET、POST、HEAD、PUT、DELETE、OPTIONS (2)、GET和POST方式的区别?初级工程师回答1&gt;、GET请求参数以？分割拼接到URL后面，POST请求参数在Body里面。2&gt;、GET参数长度限制2048个字符，POST一般没有该限制。3&gt;、GET请求不安全，POST请求比较安全。 高级工程师回答，从语义的角度回答（标准答案）(语义:指的协议的定义规范. 语法:具体实现手段或者路径) GET：获取资源。安全的、幂等的、可缓存的。 POST：处理资源。非安全的、非幂等的、不可缓存的。 安全性：不应该引起Server端的任何状态变化。常见安全性的请求方式 ：get、head、options 幂等性：同一个请求方法执行多次和执行一次的效果完全相同。常见幂等性的请求方式 ：get、put、delete 可缓存性：请求是否可以被缓存。（代理服务器可以做缓存，多次请求时可能是获取的缓存）。常见可缓存性的请求方式：get、head (3)、你都了解哪些状态码，他们的含义是什么？1xx：2xx：响应成功（200）3xx：网络重定向（301、302）4xx：客户端发起请求出错，服务器没有相应（401、404）5xx：服务器出错(502 503) 2、连接建立流程 三次握手、四次挥手 3、HTTP的特点：无连接、无状态。(1)、无连接: 指的是http的连接有建立和释放连接的过程。解决方案：HTTP的持久连接。 1&gt;、持久连接头部字段：Connection：keep-alive (允许持久连接)time：20 （持久连接连接时长）max:10 （该http连接最多可以发生多少次请求） 2&gt;、怎样判断一个请求是否结束？Content-length ：1024 （响应头）chunked，最后会有一个空的chunked，server会给客户端返回多次响应，根据判断响应报文的头部字段chunked是否为空，为空则表示没有后续了。 (2)、无状态: 多次发送http请求,如果是同一个用户对于server端是不知道是同一个用户的。解决方案：cookie、session。 问题: Charles抓包原理是咋样的？利用HTTP中间人攻击漏洞实现的。 二、HTTPS协议与网络安全1、HTTPS和HTTP有怎样的区别？HTTPS = HTTP+SSL/TLS。HTTPS是安全版的HTTP， 是由一个SSL/TLS，插在传输层之上，应用层之下的协议来保证的。 2、HTTPS连接建立流程： HTTPS连接过程大致可分为八步: 1、客户端访问HTTPS连接。 客户端会把安全协议版本号、客户端支持的加密算法列表、随机数C发给服务端。 2、服务端发送证书给客户端 服务端接收密钥算法配件后，会和自己支持的加密算法列表进行比对，如果不符合，则断开连接。否则，服务端会在该算法列表中，选择一种对称算法（如AES）、一种公钥算法（如具有特定秘钥长度的RSA）和一种MAC算法发给客户端。 服务器端有一个密钥对，即公钥和私钥，是用来进行非对称加密使用的，服务器端保存着私钥，不能将其泄露，公钥可以发送给任何人。在发送加密算法的同时还会把数字证书和随机数S发送给客户端 3、客户端验证server证书 会对server公钥进行检查，验证其合法性，如果发现发现公钥有问题，那么HTTPS传输就无法继续。 4、客户端组装会话秘钥 如果公钥合格，那么客户端会用服务器公钥来生成一个前主秘钥(Pre-Master Secret，PMS)，并通过该前主秘钥和随机数C、S来组装成会话秘钥 5、客户端将前主秘钥加密发送给服务端 是通过服务端的公钥来对前主秘钥进行非对称加密，发送给服务端 6、服务端通过私钥解密得到前主秘钥 服务端接收到加密信息后，用私钥解密得到主秘钥。 7、服务端组装会话秘钥 服务端通过前主秘钥和随机数C、S来组装会话秘钥。至此，服务端和客户端都已经知道了用于此次会话的主秘钥。 8、数据传输 客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。 同理，服务端收到客户端发送来的密文，用服务端密钥对其进行对称解密，得到客户端发送的数据。 (1)、会话秘钥：会话秘钥 = random S + random C + 预主秘钥 (2)、https都使用了哪些加密手段？为什么?1&gt;、连接建立过程使用非对称加密，非对称加密很耗时的。2&gt;、后续通讯过程使用对称加密。 (3)、对称加密(AES)： (4)、非对称加密(RSA)： 三、TCP/UDP区别1、UDP(用户数据报协议)特点：无连接；尽最大努力交付（不保证可靠传输）；面向报文（既不合并，也不拆分）。 功能：复用、分用；差错检测。 2、TCP(传输控制协议)特点：面向连接；可靠传输；面向字节流；流量控制；拥塞控制。 (1)、面向连接数据传输开始之前, 需要建立连接。三次握手数据传输结束之后, 需要释放连接。四次挥手 问题:TCP三次握手为什么不是两次?为什么要进行三次握手答:三次握手原因（不是两次握手原因）：当客户端发送连接报文时，当出现网络超时时，会启动超时重发策略，服务端同时也会返回超时重发的报文，当客户端收到的报文是超时重发的，会取消和服务端创建连接，只保证会创建一个TCP连接。 (2)、可靠传输如何保证可靠传输：保证我们的报文 -&gt;无差错、不丢失、不重复、按序到达如何实现可靠传输：通过停止等待协议实现。停止等待协议四方面: 无差错情况、超时重发、确认丢失、确认迟到。 (3)、面向字节流 每次发送多少个字节是由TCP控制的 不管发送方一次性提交给TCP的缓冲是多大的数据, 对于TCP本身来说它会根据实际情况来划分, 并不是发送方发送了10个字节,就把10个字节一次性发给接收方,可能会把10字节拆分成3个字节和7个字节分两次发送给接收方,这个就是面向字节流概念. 可以和UDP面向报文特点比较 (4)、流量控制 滑动窗口协议: 发送方定义为客户端, 接收方为server端. 当发送数据, 如果接收方接收缓存没那么大,接收窗口很小,此时发送方窗口很大,会以更快速率往接收方发送数据,需要由接收窗口通过TCP报文首部字段中更改窗口值,调整发送方发送速率. (5)、拥塞控制慢开始、拥塞避免(策略)；快恢复、快重传(策略)。 横轴:交互次数或者轮询次数 纵轴:窗口值大小 问题:请简单描述TCP慢启动特点?答:考察TCP慢开始、拥塞避免策略 问题:什么是TCP? TCP的理解是怎样?答:根据TCP五大特点回答. 四、DNS解析1、了解DNS解析问题:是否了解DND解析?DNS解析是怎样的过程? DNS解析: 域名到IP地址的映射，DNS解析请求采用UDP数据报，且明文解析。 2、DNS解析查询方式(1)、递归查询 (2)、迭代查询 3、DNS解析存在哪些常见的问题？ DNS劫持问题 DNS解析转发问题 (1)、DNS劫持问题 问题: DNS劫持与HTTP的关系是咋样的？答: 没有关系。(1)、DNS解析发生在HTTP建立连接之前；(2)、DNS解析请求使用UDP数据报，端口号53。 (2)、DNS解析转发问题 问题: 怎样解决DNS劫持？答: 两种解决方案: httpDNS 和长连接 1&gt;、httpDNSDNS解析实质上 ,使用DNS协议向DNS服务器53端口进行请求 –&gt;使用httpDNS ,实质上使用HTTP协议向DNS服务器80端口进行请求,不产生正常的DNS解析了,也就不涉及到DNS劫持问题. 2&gt;、长连接 长连server理解为代理服务器. 客户端和长连server可以建立TCP的长连通道.(客户端发送http请求,可以通过长连通道把http请求传给长连server.) 长连server通过内网专线进行内网的DNS的解析,这样就规避了公网DNS解析问题. 五、Session/Cookie Session/Cookie 是对HTTP协议无状态特点的补偿. 1&gt;、Cookie问题:什么是Cookie?Cookie主要用来记录用户状态, 区分用户; 状态保存在客户端. 1、怎样设置Cookie？(1)、 客户端发送的Cookie在http请求报文的Cookie首部字段中；(2)、 服务器端设置http响应报文的Set-Cookie首部字段, 向客户端传递Cookie内容。 2、怎样修改Cookie？(1)、新Cookie覆盖旧Cookie。(2)、覆盖规则：请求头部字段 name、path、domain等需要与原Cookie一致。 3、怎样删除Cookie？(1)、新Cookie覆盖旧Cookie。(2)、覆盖规则：name、path、domain等需要与原Cookie一致。(3)、设置Cookie的expires=过去的一个时间点，或者maxAge=0。 4、怎样保证Cookie的安全？(1)、对Cookie进行加密处理。(会有脚本攻击获取Cookie)(2)、只在HTTPS上携带Cookie。(3)、设置Cookie为httpOnly，防止跨站脚本攻击。 2&gt;、SessionSession也是用来记录用户状态，区分用户的；状态存放在服务器端。Session和Cookie的关系是怎样的？Session需要依赖于Cookie机制。 六、网络相关面试问题总结：1、HTTP中的get和post方式有什么区别？答: 见上文 2、HTTPS连接建立的流程是咋样的？答: 3、TCP和UDP有什么区别？答:(可以从特点和功能回答)TCP：面向连接；可靠传输；面向字节流；流量控制；拥塞控制。UDP：复用、分用；差错检测 基本的传输功能。 无连接；尽最大努力交付（不保证可靠传输）；面向报文（既不合并，也不拆分）。 4、请简述TCP的慢开始过程？答: TCP慢开始、拥塞避免策略回答 5、客户端怎样避免DNS劫持？答: 两种解决方案: httpDNS 和长连接]]></content>
      <categories>
        <category>iOS笔记</category>
      </categories>
      <tags>
        <tag>iOS面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[iOS面试]第7章 RunLoop相关面试问题]]></title>
    <url>%2F2020%2F05%2F25%2FiOS%E9%9D%A2%E8%AF%95-%E7%AC%AC7%E7%AB%A0-RunLoop%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[本文主讲RunLoop相关面试问题，包括RunLoop概念、数据结构、事件循环机制、RunLoop与NSTimer、RunLoop与多线程。 一、RunLoop概念1、 问题:什么是RunLoop?答:RunLoop是通过内部维护的事件循环来对事件/消息进行管理的一个对象。1、没有消息需要处理时，休眠以避免资源占有。2、有消息需要处理时，立刻被唤醒。 2、EventLoop没有消息需要被处理时, 系统会将当前线程所有权转化为内核态, 当有消息需要处理时, 系统会将当前线程的状态切换回用户态.所以RunLoop的循环并不是一个单纯的死循环, 而是通过状态切换, 达到没有消息时休眠, 有消息时唤醒的这样一个事件循环机制. 在没有消息处理时，休眠以避免资源占用，它的状态切换是怎么样的? 没有消息处理 是从用户态通过系统调用进入内核态.也就是当没有消息要处理时，进程或者说线程会进入一个休眠状态，而休眠状态的一个过渡相当于是把当前线程的控制权转移给了内核态 当有消息需要处理时就会被立刻唤醒实际上就是由内核态到用户态的一个状态切换 用户态和内核态的介绍： 应用程序一般都是运行在用户态上面，也就是用户进程包括开发所使用的绝大多数的 API 都是针对于用户层面的. 而当发生了系统调用，需要使用一些关于操作系统，以及一些底层内核相关的一些指令或者 API 的话，就触发了系统调用，而有些系统调用就会发生状态空间的切换，这种切换空间或者说之所以区分用户态和内核态实际上是对·计算机的一些资源调度·，包括资源管理进行一个统一或者说一致性的操作，这样的话就可以合理的安排资源调度，包括可以避免一些特殊的异常 比如说在内核态往往有一些线性指令，中断，包括一些开机关机的一些操作，如果说每一个用户进程可以假想是一个 app，每一个 app 都可以促使当前用户手机关机或者说中断，这种场景是无法想象的，所以要有一个用户态到内核态上面的一个区分，同时内核态里面的一些内容可以对用户态当中的一些线程进行调度和管理包括进程间的一些通信 问题:main函数为什么能保证一直运行状态不退出?答: 在main函数中调用UIApplicationMain()函数, 这个函数内部会启动一个主线程的RunLoop RunLoop是对事件循环的维护机制, 可以不断的接收消息，比如说点击屏幕的事件，滑动列表，及处理网络请求的返回，那么接收消息之后对这个事件进行处理，处理完之后就会再进行等待, 通过用户态到内核态的切换, 从而避免资源占用, 让当前线程处于休眠状态. 注意:等待 != 死循环 ，RunLoop的循环通过状态切换, 达到没有消息时休眠,用户态切换到内核态,有消息时唤醒,内核态切换到用户态的这样一个事件循环机制 什么是事件循环，事件循环的机制是怎样的？ 维护的事件循环可以用来不断的处理消息或者说事件，对他们进行管理 同时当没有消息需要管理时用从用户态切换到内核态，由此可以用来进行当前线程的休眠，然后避免资源占用 同时当有消息需要处理时，会发生从内核态到用户态的切换，然后当前的用户线程会被唤醒 所以状态的切换才是 RunLoop 的关键点 二、RunLoop的数据结构RunLoop开源代码地址在 OC 中实际提供了两个 RunLoop 的。一个是 NSRunLoop，一个是 CFRunLoop。NSRunLoop 是对 CFRunLoop 的封装，提供了一些面向对象的 API。NSRunLoop 是位于 Foundation 当中的，CFRunLoop 位于 CoreFoundation 当中的。 RunLoop 的数据结构主要有三个： CFRunLoop CFRunLoopMode Source/Timer/Observer ####1、CFRunLoop CFRunLoop数据结构 由五部分组成: pthread 、currentMode、modes、commonModes、commonModeItems //源码 struct __CFRunLoop { CFMutableSetRef _commonModes; // Set CFMutableSetRef _commonModeItems; // Set CFRunLoopModeRef _currentMode; // Current Runloop Mode CFMutableSetRef _modes; // Set ... }; (1)、pthread：一一对应(RunLoop和线程的关系) (2)、currentMode：CFRunLoopMode (3)、modes：NSMutableSet&lt;CFRunLoopMode*&gt; (4)、commonModes：NSMutableSet&lt;NSString*&gt;1&gt;、commonMode不是实际存在的一种Mode。 2&gt;、是同步Source/Timer/Observer到多个Mode中的一种技术方案。 (5)、commonModeItems：包含Observer、Timer、Source 2、CFRunLoopMode数据结构 //源码 struct __CFRunLoopMode { CFStringRef _name; // Mode Name, 例如 @&quot;kCFRunLoopDefaultMode&quot; CFMutableSetRef _sources0; // Set CFMutableSetRef _sources1; // Set CFMutableArrayRef _observers; // Array CFMutableArrayRef _timers; // Array ... }; name: 对应某一个runloopMode名称(如 NSDefaultRunLoopMode) sources0: MutableSet 集合类型数据结构 sources1: MutableSet 集合类型数据结构 observers: MutableArray timers: MutableArray 3、Source/Timer/Observer 在 CF 框架当中官方名称叫 CFRunLoopSource ，有两种 source0 和 source1唤醒线程就是从内核态切换到用户态1&gt;、CFRunLoopSourcesource0：需要手动唤醒线程。source1：具备唤醒线程的能力。 source0: 非系统事件.只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。 source1 ： 系统事件包含了一个 mach_port和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程 2&gt;、CFRunLoopTimer基于事件的定时器，和NSTimer是toll-free bridged的。和平时所使用的 NSTimer 是具备免费桥转换的 3&gt;、CFRunLoopObserver某个observer可以监听runloop的状态变化，并作出一定反应。 观测时间点 KCFRunLoopEntry (RunLoop入口时机) KCFRunLoopBeforeTimers (通知观察者RunLoop将要对timer一些相关事件进行处理) KCFRunLoopBeforeSources (将要对处理一些sources事件) KCFRunLoopBeforeWaiting (通知观察者RunLoop将要进入休眠状态, 即将要发用户态到内核态切换) KCFRunLoopAfterWaiting (内核态到用户态切换不久) KCFRunLoopExit (RunLoop退出通知) 可以通过注册一些 Observer 来实现对 RunLoop 的一些相关时间点的监测或者观察。 4、各个数据结构之间关系问题:RunLoop 和Mode以及 Mode和其对应的 Source ,Timer , Observer 有什么关系?答: 一个runLoop可以有多个mode, 一对多关系 mode 和Source, Timer, Observer 是一对多的关系可以看到, 一个RunLoop可以有多个Mode, 而每个Mode中又可以存放多个不同的事件, 我们在切换Mode时, 其他Mode的事件将不会被响应. 5、RunLoop的Mode Runloop Mode 实际上是 Source，Timer 和 Observer 的集合，不同的 Mode 把不同组的 Source，Timer 和 Observer 隔绝开来。Runloop 在某个时刻只能跑在一个 Mode 下，处理这一个 Mode 当中的 Source，Timer 和 Observer。 苹果文档中提到的 Mode 有五个，分别是： NSDefaultRunLoopMode：默认的mode，正常情况下都是在这个mode NSConnectionReplyMode NSModalPanelRunLoopMode NSEventTrackingRunLoopMode：使用这个Mode去跟踪来自用户交互的事件（比如UITableView上下滑动） NSRunLoopCommonModes iOS 中公开暴露出来的只有 NSDefaultRunLoopMode 和 NSRunLoopCommonModes。 NSRunLoopCommonModes 实际上是一个 Mode 的集合，默认包括 NSDefaultRunLoopMode 和 NSEventTrackingRunLoopMode。 问题:RunLoop为什么会有多个mode?答： 6、CommonModes的特殊性NSRunLoopCommonModes(问题:CommonModes是否使用过, 你对CommonModes事怎样理解?) CommonModes不是实际存在的一种Mode 是同步Source/Timer/Observer到多个Mode中的一种技术方案 在 OC 当中经常会通过 NSRunLoopCommonModes 字符串常量来表达 CommonMode。 CommonModes实现：一个 Mode 可以将自己标记为”Common”属性（通过将其 ModeName 添加到 RunLoop 的 “commonModes” 中）。每当 RunLoop 的内容发生变化时，RunLoop 都会自动将 _commonModeItems 里的 Source/Observer/Timer 同步到具有 “Common” 标记的所有Mode里。 三、RunLoop事件循环机制的实现在开发过程中调用的 NSRunLoop 的 run 系列的相关方法以及 CFRunLoop 的相关的 run 方法最终都会调用到 CFRunLoopRun() 函数 1 事件循环的整体逻辑：1）在 RunLoop 启动之后首先会发出一条通知来告诉观察者当前 RunLoop 即将启动2）之后 RunLoop 将要处理 Timer/Sources0 事件，发出通知3）进入正式 Sources0 的处理4）如果有 Sources1 需要处理，这个时候会用过一条 goto 语句来进行代码逻辑的跳转，来处理唤醒时收到的消息5）如果没有 Source1要处理，此时线程将要休眠，同时也会发送通知给 Observe，然后就发生了用户带到内核态的切换6）线程正式进入休眠，等待唤醒7）之后线程被唤醒，也要发送一个通知，通知观察着说当前线程被唤醒了，然后处理唤醒时受到的消息，之后又会回到第二步 2 当处于休眠的runloop，可以通过哪些方式唤醒?答: 通过 Sources1 进行当前 RunLoop 的唤醒 Timer 事件的回调 外部手动的唤醒 3 App 从启动到退出，这个过程当中系统都发生了什么？答： 调用了 main 函数之后，在 main 函数中会调用 UIApplicationMain 函数，在这个函数内部会启动一个主线程的 RunLoop，然后经过一系列的处理最终主线程的 RunLoop 处于休眠状态， 如果说此时点击一个屏幕，会产生一个 Responder ，然后基于 Responder 最终会转成 Sources1，可以把主线程唤醒，运行然后处理， 之后当把程序杀死的时候 RunLoop 就会退出，这个时候就会发出一个通知即将退出 RunLoop ，RunLoop 退出之后线程也就销毁掉了。 4 RunLoop的核心main 函数经过一系列的处理之后，内部最终会调用一个系统函数 mach_msg() ,于是就发生了一个系统调用，经过系统调用当前用户线程就把控制权转交核心态，然后 mach_msg() 在一定条件下会返回给调用方，触发返回的逻辑就是唤醒线程的逻辑，比如收到了一个 Sources1 或者 Timer 事件的回调，包括外部手动唤醒，就可以触发核心态到用户态的切换，那么当前app的主线程循环就会被唤醒，这就是 RunLoop 的核心 四、RunLoop与NSTimer问题:滑动TableView的时候，我们的定时器还会生效吗？答: Runloop Mode 实际上是 Source，Timer 和 Observer 的集合，不同的 Mode 把不同组的 Source，Timer 和 Observer 隔绝开来。Runloop 在某个时刻只能跑在一个 Mode 下，处理这一个 Mode 当中的 Source，Timer 和 Observer。 滑动TableView的时候Mode发生切换，从KCFRunLoopDefaultMode切换到UITrackingRunLoopMode. (当把Source/Timer/Observer 添加到某个Mode上, 如果当前runloop运行在另一个mode上, 对应Source/Timer/Observer是没有办法进行后续处理和回调.) 解决: 通过函数CFRunLoopAddTimer() 将timer添加到commonMode上. CommonMode不是实际存在的一种Mode, 只是将一些mode打上common标记, 然后可以把某个事件源(如Timer)同步到多个mode中.void CFRunLoopAddTimer(runloop, timer, commonMode) ` 五、RunLoop与多线程1、怎样实现一个常驻线程?(1)、为当前线程开启一个RunLoop。(2)、向该RunLoop中添加一个Port/Source等维持RunLoop的事件循环。(3)、启动该RunLoop。 实现一个常驻线程的基本步骤： 1)为当前线程开启一个 RunLoop ：NSRunLoop *runLoop = [NSRunLoop currentRunLoop];，因为获取当前 RunLoop 这个方法本身会查找如果当前线程没有 RunLoop 的话，会在系统的内部创建 2)如果线程没有资源或者事件源要处理的话，默认情况下是不能维持事件循环的就会直接退出了，所以需要给他添加一个 Port/Source 来维持他的时间循环机制 3)然后再调用 RunLoop 的 run 方法就可以实现一个常驻线程 2、RunLoop和线程关系(1)、runloop与线程是一一对应的，一个runloop对应一个核心的线程，为什么说是核心的，是因为runloop是可以嵌套的，但是核心的只能有一个，他们的关系保存在一个全局的字典里。(2)、runloop是来管理线程的，当线程的runloop被开启后，线程会在执行完任务后进入休眠状态，有了任务就会被唤醒去执行任务。(3)、runloop在第一次获取时被创建，在线程结束时被销毁。(4)、对于主线程来说，runloop在程序一启动就默认创建好了。(5)、对于子线程来说，runloop是懒加载的，只有当我们使用的时候才会创建。 dispatch_queue_t queue = dispatch_queue_create(&quot;com.codeTao.testQueue&quot;, DISPATCH_QUEUE_SERIAL); dispatch_async(queue, ^{ [self performSelector:@selector(timerAction) withObject:nil afterDelay:1]; [[NSRunLoop currentRunLoop] run]; }); (6)、子线程中使用定时器，需将定时器添加至RunLoop中，确保子线程的runloop被创建，不然定时器不会回调。 dispatch_queue_t queue = dispatch_queue_create(&quot;com.codeTao.testQueue&quot;, DISPATCH_QUEUE_SERIAL); dispatch_async(queue, ^{ //此种方式创建的timer已经添加到NSRunloop中了 NSTimer *timer1 =[NSTimer scheduledTimerWithTimeInterval:0 target:self selector:@selector(timerAction) userInfo:nil repeats:YES]; [[NSRunLoop currentRunLoop] run]; //此种方式创建的timer没有添加至runloop中 NSTimer *timer2 = [NSTimer timerWithTimeInterval:1.0f target:self selector:@selector(timerAction) userInfo:nil repeats:YES]; [[NSRunLoop currentRunLoop] addTimer:timer2 forMode:NSDefaultRunLoopMode]; [[NSRunLoop currentRunLoop] run]; }); 六 RunLoop面试总结问题:什么是RunLoop? 它是怎样做到有事做事,没事休息?答: RunLoop是通过内部维护的事件循环来对事件/消息进行管理的一个对象。调用 [CFRunLoop run] 相关方法后, 会调用系统函数mach_msg, 同时发生了用户态向核心态的切换,当前线程处于休眠状态.所有做到有事做事,没事休息 问题:RunLoop与线程是怎样的关系?答: runloop与线程是一一对应的 一个线程默认是没有runloop的, 需要手动创建 问题:如何实现一个常驻线程?答:三个步骤:(1)、创建一个线程对应的RunLoop。(2)、向该RunLoop中添加一个Port/Source/Timer/Observer等维持RunLoop的事件循环。(3)、启动该RunLoop 。调用CFRunLoop run方法注意:运行的模式和添加模式必须是同一个,否则外部使用while循环会导致死循环 问题:怎样保证子线程数据回来更新UI的时候不打断用户的滑动操作?答: 用户进行滑动过程中,当前RunLoop运行在UITrackingRunLoopMode下 我们一般在子线程中进行网络请求, 所以可以将子线程抛给主线程数据并进行UI更新的逻辑封装起来提交到主线程的NSDefaultRunLoopMode下. 这样抛回来的任务,当用户滑动时处于UITrackingRunLoopMode下就不会执行任务. 当手停止滑动操作后, 当前线程mode切换到NSDefaultRunLoopMode下,再处理子线程上抛给主线程的任务,这样就不会打断用户滑动操作. 问题：我们可以监听 RunLoop 哪些时间点？答： KCFRunLoopEntryRunLoop 的入口时机，当 RunLoop 准备启动的时候系统会给我们一个回调通知，这个通知掉 CFRunLoopEntry KCFRunLoopBeforeTimers代表的含义：通知观察者 RunLoop 将要对 Timer 一些相关事件进行处理了 KCFRunLoopBeforeSources代表将要处理一些 Source 事件 KCFRunLoopBeforeWaiting通知对应观察者，当前 RunLoop 将要进入休眠状态，这个通知或者说观测点是非常重要的一个观测点，在 RunLoop 发送这个通知的时候，即将要发生用户态到内核态的切换 KCFRunLoopAfterWaiting这也是一个重要的观测点，这个通知发出的时机恰好是从内核态切换到用户态之后的不久之间 KCFRunLoopExit代表 RunLoop 退出的通知 问题:什么时候使用Runloop?当需要和该线程进行交互的时候才会使用Runloop 问题: Runloop和线程是什么关系？答: 每条线程都有唯一的一个与之对应的RunLoop对象，其关系是保存在一个全局的 Dictionary 里； 主线程的RunLoop已经自动创建，子线程的RunLoop需要手动创建； RunLoop在第一次获取时创建，在线程结束时销毁 问题:Runloop的mode作用是什么？答:指定事件在运行循环中的优先级的，线程的运行需要不同的模式，去响应各种不同的事件，去处理不同情境模式。(比如可以优化tableview的时候可以设置UITrackingRunLoopMode下不进行一些操作，比如设置图片等。) 问题: 以+scheduledTimerWithTimeInterval:的方式触发的timer，在滑动页面上的列表时，timer会暂停回调， 为什么？答:滑动scrollView时，主线程的RunLoop会切换到UITrackingRunLoopMode这个Mode，执行的也是UITrackingRunLoopMode下的任务（Mode中的item），而timer是添加在NSDefaultRunLoopMode下的，所以timer任务并不会执行，只有当UITrackingRunLoopMode的任务执行完毕，runloop切换到NSDefaultRunLoopMode后，才会继续执行timer。 问题: 如何解决在滑动页面上的列表时，timer会暂停回调？答:将Timer放到NSRunLoopCommonModes中执行即可 [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes]; [[NSRunLoop currentRunLoop] run]; 问题: NSTimer使用时需要注意什么？答: 注意timer添加到runloop时应该设置为什么mode 注意timer在不需要时，一定要调用invalidate方法使定时器失效，否则得不到释放 问题: RunLoop 有哪些应用？答: 常驻内存、AutoreleasePool 自动释放池 问题: AutoreleasePool 和 RunLoop 有什么联系？答:iOS应用启动后会注册两个 Observer 管理和维护 AutoreleasePool。应用程序刚刚启动时默认注册了很多个Observer，其中有两个Observer的 callout 都是 _ wrapRunLoopWithAutoreleasePoolHandler，这两个是和自动释放池相关的两个监听。 第一个 Observer 会监听 RunLoop 的进入，它会回调objc_autoreleasePoolPush() 向当前的 AutoreleasePoolPage 增加一个哨兵对象标志创建自动释放池。这个 Observer 的 order 是 -2147483647 优先级最高，确保发生在所有回调操作之前。 第二个 Observer 会监听 RunLoop 的进入休眠和即将退出 RunLoop 两种状态，在即将进入休眠时会调用 objc_autoreleasePoolPop() 和 objc_autoreleasePoolPush() 根据情况从最新加入的对象一直往前清理直到遇到哨兵对象。而在即将退出 RunLoop 时会调用objc_autoreleasePoolPop() 释放自动自动释放池内对象。这个Observer 的 order 是 2147483647 ，优先级最低，确保发生在所有回调操作之后。 问题:NSRunLoop 和 CFRunLoopRef 区别?答: CFRunLoopRef 基于C 线程安全，NSRunLoop 基于 CFRunLoopRef 面向对象的API 是不安全的]]></content>
      <categories>
        <category>iOS笔记</category>
      </categories>
      <tags>
        <tag>iOS面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[iOS面试]第6章 多线程相关面试问题]]></title>
    <url>%2F2020%2F05%2F24%2FiOS%E9%9D%A2%E8%AF%95-%E7%AC%AC6%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[本文主讲多线程相关面试问题：包括GCD、NSOperation、NSThread、多线程与锁。 一、GCD 同步/异步 和串行/并发 dispatch_barrier_async 异步栅栏调用 dispatch_group 01 异步函数+并发队列：开启多条线程，并发执行任务02 异步函数+串行队列：开启一条线程，串行执行任务03 同步函数+并发队列：不开线程，串行执行任务04 同步函数+串行队列：不开线程，串行执行任务05 异步函数+主队列：不开线程，在主线程中串行执行任务06 同步函数+主队列：不开线程，串行执行任务（注意死锁发生）注意同步函数和异步函数在执行顺序上面的差异 1、同步/异步 和 串行/并发同步/异步 和 串行/并发 + 同步分配任务到串行队列 dispatch_sync(serial_queue,{//任务}); + 异步分配任务到串行队列 dispatch_async(serial_queue,{//任务}); + 同步分配任务到并发队列 dispatch_sync(concurrent_queue,{//任务}); + 异步分配任务到并发队列 dispatch_async(concurrent_queue,{//任务}); (1)、同步串行 dispatch_sync(serial_queue , ^{ //任务 });同步主线程//同步主线程 死锁 - (void)viewDidLoad { dispatch_sync(dispatch_get_main_queue(), ^{ [self doSomething]; }); } 结果：造成死锁 队列引起的循环等待.在主队列中提交了viewDidLoad，然后又提交了block。因此在执行viewDidLoad过程中，需要调用block，block完成之后，viewDidLoad才能继续往下执行，而block因为队列先进先出的性质必须要等viewDidLoad执行结果才能调用,导致相互等待情况,从而死锁. 同步串行- (void)viewDidLoad { dispatch_sync(serialQueue, ^{ [self doSomething]; }); } 结果：顺序执行 都在主线程，不开辟新线程 (2)、同步并发 dispatch_sync(concurrent_queue , ^{ //任务 });- (void)viewDidLoad { NSLog(@&quot;1&quot;); dispatch_sync(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ NSLog(@&quot;2&quot;); dispatch_sync(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ NSLog(@&quot;3&quot;); }); NSLog(@&quot;4&quot;); }); NSLog(@&quot;5&quot;); } 答案:12345 顺序执行 都在主线程 不开辟新线程ps：如果2 3 都是添加到同一串行队列 就会造成死锁 23循环等待 只要同步方式提交任务,无论串行还是并发都是在当前线程执行 dispatch_sync() 在当前主线程执行 (3)、异步串行 dispatch_async(serial_queue , ^{ //任务 });异步主队列 - (void)viewDidLoad { dispatch_async(dispatch_get_main_queue(), ^{ [self doSomething]; }); } 顺序执行，都在主线程，不开辟新线程 (4)、异步并发 dispatch_async(concurrent_queue , ^{ //任务 });//腾讯面试题: - (void)viewDidLoad { dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ NSLog(@&quot;1&quot;); [self performSelector:@selector(printLog) withObject:nil afterDelay:0]; NSLog(@&quot;3&quot;); }); } - (void)printLog{ NSLog(@&quot;2&quot;); } 输出: 13 该题涉及知识点较多：GCD、线程的Runloop、performSeletor内部实现 异步分派到全局队列中，GCD底层所分派的线程默认是不开启对应runloop的，而performSeletor：即使是延迟0秒，也是需要提交任务到runloop的逻辑，所以performSeletor方法会失效的 performSeletor:方法要想有效执行, 必须是方法调用所属线程是有runloop的,没有就会失效 2、dispatch_barrier_async()多读单写方案：dispatch_barrier_async(concurrent_queue , ^{ //写操作 }); 问题:怎么利用GCD实现多读单写？或者说想要实现多读单写，怎么去实现？答: 读者与读者并发（读操作添加到并发队列同步访问） 读者与写者、写者与写者互斥 （写操作通过dispatch_barrier_async+ 异步栅栏添加到并发队列中） @interface UserCenter(){ // 定义一个并发队列 dispatch_queue_t concurrent_queue; // 用户数据中心, 可能多个线程需要数据访问 NSMutableDictionary *userCenterDic; } @end // 多读单写模型 @implementation UserCenter - (id)init{ self = [super init]; if (self) { // 通过宏定义 DISPATCH_QUEUE_CONCURRENT 创建一个并发队列 concurrent_queue = dispatch_queue_create(&quot;read_write_queue&quot;, DISPATCH_QUEUE_CONCURRENT); // 创建数据容器 userCenterDic = [NSMutableDictionary dictionary]; } return self; } - (id)objectForKey:(NSString *)key { __block id obj; // 同步读取指定数据 dispatch_sync(concurrent_queue, ^{ obj = [userCenterDic objectForKey:key]; }); return obj; } - (void)setObject:(id)obj forKey:(NSString *)key { // 异步栅栏调用设置数据 dispatch_barrier_async(concurrent_queue, ^{ [userCenterDic setObject:obj forKey:key]; }); } @end 3、dispatch_group_async()问题:使用GCD实现：A、B、C三个任务并发，完成后执行任务D？答: 所有异步任务添加到并发队列中，然后使用dispatch_group_notify函数，来监听前面多个的任务是否完成，如果完成, 就会调用dispatch_group_notify中的block(参考代码实例) 二、NSOperation需要和NSOperationQueue配合使用来实现多线程方案。1、特点：添加任务依赖、任务执行状态监控、最大并发数。2、任务执行状态控制：isReady、isExecuting、isFinished、isCancelled。 3、状态监控 如果只重写main方法，底层控制变更任务执行完成状态，以及任务退出。 如果重写start方法，需自行控制任务状态。 4、系统是怎样移除一个isFinished=YES的NSOperation的？答:通过KVO的方式，通知对应的NSOprationQueue达到对NSOperation对象进行移除。 三、NSThread考查面试题:1&gt; 如何NSThread结合runloop实现常驻线程2&gt; NSThread 的 内部实现机制, start方法实现逻辑流程(结合 gnustep-base-1.24.9 源码分析) 问题: NSThread启动流程？答: start() ——&gt;创建pthread线程——&gt;main()——&gt;[target performSelector:selector]——&gt;exit() 问题: 如何通过runloop和NSThread实现一个常驻线程？从下一章runloop中寻找答案 问题: NSThread执行原理是怎样的?答: 实际内部创建一个pthread线程 ,当main()函数或者指定的target 的selector方法执行结束后,系统会为我们进行线程的退出管理操作. 如果需要维护一个常驻线程,需要NSThread所对应的selector方法中维护runloop事件循环。 四、多线程与锁iOS中有哪些锁？ @synchronized atomic OSSpinLock NSRecursiveLock NSLock dispatch_semaphore_t 1、 @synchronized的使用场景一般在创建单例的时候使用，保证在多线程环境下创建的对象是唯一的 2、atomic 修饰属性的关键字 对被修饰的对象进行原子操作（不负责使用，只负责赋值）@property(atomic)NSMutableArray *array; self.array = [NSMutableArray array]; //array赋值操作,能保证线程安全 [self.array addObject:obj]; // array使用, 不能保证线程安全,需要额外做线程安全保护 3、OSSpinLock自旋锁 循环等待询问，不释放当前资源 用于轻量级数据访问，简单的int值+1/-1操作 没有具体用过,但是可以通过分析runtime源码来学习系统关于OSSpinLock自旋锁的使用情况. 4、 NSLock 一般用于解决细粒度的线程同步问题, 来保证各个线程互斥,进入自己的临界区. - (void)methodA { [lock lock]; [self methodB]; [lock unlock]; } - (void)methodB { [lock lock]; //操作逻辑 [lock unlock]; } 该写法重入的原因 会导致死锁! 解决: 通过NSRecursiveLock递归所可以解决5、NSRecursiveLock 递归锁 NSRecursiveLock 递归锁特性: 可以重入` (void)methodA {[recursiveLock lock];[self methodB];[recursiveLock unlock];} (void)methodB {[recursiveLock lock];//操作逻辑[recursiveLock unlock];}` 6、dispatch_semaphore_t 信号量 dispatch_semaphore_t 信号量 也是用来实现线程同步, 包括对共享资源互斥访问的信号量机制,类似于计算机专业的记录型信号量 创建信号量 dispatch_semaphore_create(1) //dispatch_semaphore_create内部实现 实例化一个结构体 struct semaphore{ int value; // 信号量的值 List&lt;thread&gt;; // 线程的进程控制表pcd 或者一些其他线程的一个唯一标识所维护的一个线程列表 } dispatch_semaphore_wait(semaphore,DISPATCH_TIME_FOREVER)信号量-1，阻塞是一个主动行为 //dispatch_semaphore_wait() 实现逻辑 { S.value = S.value - 1; if S.value &lt; 0 then Block(S.List); //阻塞是一个主动行为 } dispatch_semaphore_signal(semaphore) 信号量+1，唤醒是一个被动行为//dispatch_semaphore_signal()实现逻辑 { S.value = S.value + 1; if S.value &lt;= 0 then wakeup(S.List); //唤醒是一个被动行为 } 五 多线程相关面试问题1、怎样用GCD实现多读单写？答: dispatch_barrier_async()的使用. 读者与读者并发（读操作添加到并发队列同步访问） 读者与写者、写者与写者互斥 （写操作通过dispatch_barrier_async+ 异步栅栏添加到并发队列中） 2、iOS系统为我们提供的几种多线程技术各自的特点是怎么样的？答案：GCD、NSOperation、NSThread。 GCD 用来实现简单的线程同步，包括子线程的分派，包括实现多读单写场景的解决 NSOperation及NSOperationQueue 比如AFNetworking、SDWebImage都会涉及到NSOpration,由于它的特点是方便我们对任务的状态进行控制，包括可以控制添加依赖、移除依赖 NSThread 一般用它来实现一个常驻线程 3、NSOperation对象在Finished之后是咋样从queue当中移除掉的？答: NSOperation对象在Finished之后, 通过KVO的方式，通知对应的NSOprationQueue达到对NSOperation对象进行移除。 4、你都用过哪些锁？结合实际谈谈你是怎样使用的？答:]]></content>
      <categories>
        <category>iOS笔记</category>
      </categories>
      <tags>
        <tag>iOS面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[iOS面试]第5章 Block相关面试问题]]></title>
    <url>%2F2020%2F05%2F24%2FiOS%E9%9D%A2%E8%AF%95-%E7%AC%AC5%E7%AB%A0-Block%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[本文主讲Block相关面试问题，包括Block介绍、截获变量、__block修饰符、Block的内存管理、Block的循环引用。 一、Block介绍定义:Block是将函数及其执行上下文封装起来的对象。 Block本质:源码解析:使用 clang -rewrite-objc file.m 查看编译之后的文件内容。 Block调用:Block调用就是函数的调用。 二、截获变量。被截获变量类型被截获变量类型: 包括局部变量(基本数据类型和对象类型)、静态局部变量、全部变量、静态全部变量。 问题:关于Block截获变量的特性，是否有理解？答: 对不同的数据类型，截获方式各有不同1.对于基本数据类型的局部变量截获其值2.对于对象类型的局部变量连同所有权修饰符一起截获3.以指针方式截获静态局部变量4.不截获全局变量、静态全局变量 源码解析:使用 clang -rewrite-objc -fobjc-arc file.m 查看编译之后的文件内容。 //面试题 int multiplier = 6; int(^Block)(int) = ^int(int num){ return num*multiplier; }; multiplier = 4; NSLog(@&quot;result is %d&quot;,Block(2)); //输出结果 --&gt;result is 12 三、__block修饰符一般情况下，对被截获变量进行赋值操作需添加__block修饰符。注意：赋值不等于使用。 笔试题的坑: NSMutableArray *array =[NSMutableArray array]; void(^Block)(void) = ^{ [array addObject:@&quot;123&quot;]; }; Block(); //该array为使用，只有赋值操作才需要__block 。 NSMutableArray *array2 =nil; void(^Block2)(void) = ^{ array2 = [NSMutableArray array]; }; Block2(); //该block为赋值，存在问题，会编译报错，需要用__block修饰被截获变量array2。 问题:在什么场景下使用__block修饰符呢？ 对截获变量进行赋值操作需要添加__block修饰符（赋值 != 使用） 对局部变量（基本数据类型和对象类型）进行赋值需要__block修饰符 对静态局部变量、全局变量、静态全局变量不需要__block修饰符 __block 面试题{ __block int multiplier = 6; int(^Block)(int) = ^int(int num){ return num*multiplier; }; multiplier = 4; NSLog(@&quot;result is %d&quot;,Block(2)); //输出结果 --&gt;result is 8 } 问题:block修饰符起到了什么作用？block的机制是什么？答: __block修饰变量变成了对象 栈上的block变量的forwarding指针是指向其自身的 四、Block的内存管理1、Block类型Block类型：NSGlobalBlock、NSStackBlock、NSMallocBlock。 impl.isa = &amp;_NSConcreteStackBlock; 2、Block的copy操作 问题: 三种类型的block进行copy有什么效果?答: 对于数据区的block进行copy操作，什么也不做 对于栈区的block进行copy操作，在堆区产生block 对于堆区的block进行copy操作，会增加引用计数 3、生命周期栈上Block的销毁 对于栈区的block，变量作用域结束，随之销毁 栈上Block的copy 问题:如果对栈上block进行copy 操作后, MRC环境下,是否会引起内存泄漏?答: 会引起内存泄漏. 栈上block在变量作用域结束后会销毁, 堆上block没有其他成员变量指向它, 这和alloc 出一个对象最后没有release效果是一样的, 会引起内存泄漏. 栈上__block变量的copy 如果对栈上的__block变量没有进行copy操作, __forwarding指针指向其自身, 同样上边一行代码,修改的是栈上的__block变量 对栈上的__block变量进行copy操作后, 实际在堆上面也会产生一个block变量,内容完全一样,但是是两块不同内存控件.` 栈上block变量的__forwarding指针指向是堆上的block变量,堆上block变量`的__forwarding指针指向其自身. 所以在对multiplier 整型值进行改变时 ,使用是转换出来的都是同一行代码 . 面试题: { __block int multiplier = 10; _blk = ^int(int num){ return num * multiplier; } multiplier = 6; [self excuteBlock]; } - (void)excuteBlock{ int result = _blk(4); NSLog(@&quot;result is %d&quot;, result); // result is 24 } 4、__forwarding存在的意义 不管在任何内存位置，都可以顺利的访问同一个__block变量 五、Block的循环引用Block循环引用（为什么会产生循环引用）在下图中，有什么问题？如何解决？ //_strBlk _array 都为当前对象的成员变量 // _array 由strong修饰, _strBlk 由copy 修饰 { _array = [NSMutableArray arrayWithObject:@&quot;block&quot;]; _strBlk = ^NSString* (NSString *num){ return [NSString stringWithFormat:@&quot;helloc_%@&quot;, _array[0]]; }; _strBlk(@&quot;hello&quot;); } //产生自循环循环引用 产生自循环引用 :因为当前对象通过copy声明block，而在当前block中又使用到了当前对象的成员变量，因为会连带属性关键字一起截获，因为array是通过strong修饰，因此block中有一个strong类型的指针指向当前对象，产生循环引用 解决方法：避免循环引用——在当前栈中用weak修饰的weakArray指针指向原对象的_array,在block中使用weakArray（因为截获的是一个weak类型） //解决 { _array = [NSMutableArray arrayWithObject:@&quot;block&quot;]; __weak NSArray *weakArray = _array; _strBlk = ^NSString* (NSString *num){ return [NSString stringWithFormat:@&quot;helloc_%@&quot;, weakArray[0]]; }; _strBlk(@&quot;hello&quot;); } 问题:block外部 为什么通过weak属性关键字修饰对象,就可以避免循环引用?答:由于block截获变量是对象类型,会连同其所有权修饰符一起截获,在block外部定义变量是weak所有权修饰符,在block所产生结构体中所持有的变量也是__weak的 问题: （__block造成的循环引用）在下代码中，有什么问题？如何解决？ { __block MCBlock *blockSelf = self; _blk = ^int(int num){ //var = 2 return num * blockSelf.var; }; _blk(3); } 答: 在MRC中，不会产生循环引用 在ARC中，产生循环引用，引起内存泄漏 解决: { __block MCBlock *blockSelf = self; _blk = ^int(int num){ //var = 2 int result = num * blockSelf.var blockSelf = nil; return result; }; _blk(3); } Block面试总结问题: 什么是block？答:Block是将函数及其执行上下文封装起来的对象。 问题: 为什么Block会产生循环引用？答:1&gt;如果当前Block对当前对象的某一成员变量进行截获, block会对成员变量有强引用, 当前对象又对当前block有一个copy强引用, 就产生自循环引用问题.可以通过声明对象的成员变量为 __weak 变量,来进行循环引用消除. (因为当前对象通过copy声明block，而在当前block中又使用到了当前对象的成员变量，因为会连带属性关键字一起截获，如果成员变量使用strong修饰，因此block中有一个strong类型的指针指向当前对象，产生自循环引用.) 2&gt;如果定义__block说明符 ,在ARC中 会产生循环引用, 在MRC中不会产生循环引用.可以在ARC中采取断环的方式解决循环引用,但是有个弊端,如果block 如果一直没有调用, 循环引用是没有办法消除的. 问题:怎样理解Block截获变量的特性？答:(被截获类型的分类回答)答: 对不同的数据类型，截获方式各有不同1.对于基本数据类型的局部变量对其值进行截获2.对于对象类型的局部变量连同所有权修饰符一起截获3.对于静态局部变量以指针方式截获4.对于全局变量、静态全局变量不截获. 问题: 你都遇见过哪些循环引用？你又是咋样解决的答:NSTimer循环引用. Block循环引用:2方面1&gt;block所捕获变量也是当前对象的成员变量, block 也是当前对象的成员变量,就会造成自循环引用. 采用避免循环引用方式, 加weak所有权修饰符,来避免循环引用.2&gt;block也会造成循环引用, 在ARC中 会产生循环引用, 在MRC中不会产生循环引用.可以在ARC中采取断环的方式解决循环引用,但是有个弊端,如果block 如果一直没有调用, 循环引用是没有办法消除的. 1、相互循环引用 typedef void(^Block)(NSString*); @interface ClassA() { int age; } @property(nonatomic,strong)Block block; @property(nonatomic,strong)NSString *temp; @end @implementation ClassA - (void)viewDidLoad { [super viewDidLoad]; self.block = ^(NSString * content) { self.temp = content; self-&gt;age = 15; }; } -(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event{ self.block(@&quot;赵四&quot;); } (1)、如上代码，self持有block，而堆上的block又会持有self，所以会导致循环引用，这个例子非常好，因为xcode都能检测出来，报出警告：[capturing self strongly in this block is likely to lead to a retain cycle]，当然大部分循环引用的情况xcode是不会报警告的。(2)、这时Block对象虽然捕获了weakSelf，延长了weakSelf这个局部变量的生命周期，但weakSelf是附有__weak修饰符的变量，它并不会持有对象，一旦它指向的对象被废弃了，它将自动被赋值为nil。在多线程情况下，可能weakSelf指向的对象会在Block执行前被废弃，这样可能顶多就是返回nil，但在有些情况下（譬如在Block中有移除KVO的观察者的逻辑，在执行到该逻辑前self就释放了）就会导致crash。这时可以在Block内部（第一句）再持有一次weakSelf指向的对象，保证在执行Block期间该对象不会被废弃，这就是所谓的 weak-strong。 解决这种循环引用的常用方式如下 typedef void(^Block)(NSString*); @interface ClassA() { int age; } @property(nonatomic,strong)Block block; @property(nonatomic,strong)NSString *temp; @end @implementation ClassA - (void)viewDidLoad { [super viewDidLoad]; __weak typeof(self) weakSelf = self; self.block = ^(NSString * content) { __strong typeof(weakSelf)strongSelf = weakSelf; strongSelf.temp = content; strongSelf-&gt;age = 15; }; } -(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event{ self.block(@&quot;赵四&quot;); } 2、多循环引用 typedef void(^Block)(NSString*); @interface ClassB : UIViewController @property(nonatomic,strong)Block block; #import &quot;ClassA.h&quot; #import &quot;ClassB.h&quot; @interface ClassA() @property(nonatomic,strong)ClassB *classB; @property(nonatomic,strong)NSString *temp; @end @implementation ClassA - (void)viewDidLoad { [super viewDidLoad]; self.classB = [[ClassB alloc]init]; self.classB.block = ^(NSString *content) { self.temp = content; }; } -(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event{ self.classB.block(@&quot;赵四&quot;); } @end 如上代码，ClassA持有ClassB，ClassB持有block，而堆上的block又会持有ClassA，所以会导致循环引用。]]></content>
      <categories>
        <category>iOS笔记</category>
      </categories>
      <tags>
        <tag>iOS面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[iOS面试]第4章 内存管理相关面试问题]]></title>
    <url>%2F2020%2F05%2F23%2FiOS%E9%9D%A2%E8%AF%95-%E7%AC%AC4%E7%AB%A0-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[本文主讲内存管理相关面试问题，包括内存布局、内存管理方案、数据结构、ARC&amp;MRC、引用计数管理、弱引用管理、自动释放池、循环引用。 一、内存布局 1、stack(栈区)：方法调用。2、heap(堆区)：通过alloc等分配的对象。3、bss：未初始化的全局变量等。4、Data：已初始化的全局变量等。5、text：程序代码。 二、内存管理方案问题:iOS操作系统是怎样对内存进行管理的?(iOS会根据不同场景会采取不同内存方案) 1、TaggedPoint(小对象)。 如NSNumber，DSData类型。2、NONPOINTER_ISA(非指针型的isa)。 在arm64位架构下使用的一种方案，这种方案主要是高效利用64位架构下isa指针的剩余内存空间。3、散列表(散列表是复杂的数据结构,其中包含引用计数表、弱引用表)。 在32位架构下使用以及64位架构下isa指针存放不下的场景下使用，也就是我们常说的信引用计数表 1.NONPOINTER_ISANONPOINTER_ISA 64个比特位分析: indexed(1位): 0 代表纯isa指针,内容代表当前对象的类对象的地址 . 1代表isa指针不仅存储类对象的地址, 还有内存管理数据也就是NONPOINTER_ISA(非指针型的isa). has_assoc(2位):表示当前对象是否有关联对象, 0 没有, 1有. has_cxx_dtor(3位): 当前对象是否有使用C++语言相关内容.当前对象是否使用ARC管理内存 shiftcls(4~37位): 共33位比特位 表示当前对象类对象的指针地址. magic(38~43位): weakly_referenced(44位): 标识当前对象是否有弱引用指针 deallocating(45位): 当前对象是否正在进行dealloc操作 has_sidetable_rc(46位): 当前isa指针中所存储引用计数达到上限, 需要外挂一个sidetable数据结构用来存储相关的引用内容,也就是散列表 extra_rc(47~64位): 额外的引用计数, 当引用计数在很小值范围就会存储在isa指针中. 2.散列表方式 SideTables()（非嵌入式系统中包含64个SideTable），实际是一个哈希表，通过对象的指针找到对应的引用计数表或弱引用表，在哪一个SideTable中 SideTable结构包含自旋锁 引用计数表 弱引用表 问题:为什么不是一个SideTable？存在效率问题，如果多个对象在对同一张表进行引用计数时，就会等待前一个对象操作结束才能操作。引用分离锁的方案，可以提高访问效率。 问题:怎样实现快速分流？（哈希查找的过程） SideTables的本质是一张Hash表。 根据对象的地址，通过一个均匀散列函数的计算就可以得到数组下标索引值。 Hash查找过程例: 给定值是对象内存地址,目标值是数组下标索引。 f(ptr) = (uintptr_t)ptr% array.count 三、散列表中数据结构1)自旋锁（Spinlock_t） 是一种忙等的锁（当前锁已被其他线程获取，当前线程就会不断的探测这个锁是否被释放,如果释放自己第一时间获取锁） 适用于轻量访问。 例如引用计数+1、-1操作 补充:信号量 如果获取不到锁,自己会等待休眠,等他其他线程释放锁时,唤醒当前线程. 2)引用计数表（RefcountMap）ptr ——&gt; DisguisedPtr(obj) ——&gt;size_t提高查找效率，插入和获取都是通过同一个哈希算法，避免了数组遍历 3)弱引用表（weal_table_t）ptr ——&gt; Hash函数——&gt;value 四、ARC&amp;MRC1、MRC：手动引用计数。alloc、retain、release、retainCount、autorelease、dealloc。2、ARC：自动引用计数。(1)、ARC是LLVM（编译器）和RunTime协作的结果。(2)、ARC中禁止手动调用retain/release/retainCount/dealloc。(3)、ARC中新增weak、strong属性关键字。 五、引用计数管理实现原理分析，包括alloc、retain、release、retainCount、dealloc。 1、alloc实现经过一系列调用，最终调用的C函数calloc，此时并没有设置引用计数为1（但是通过retainCount得知是1，在后面会讲到） 2、retain实现经过两次Hash查找，找到对应的引用计数值，然后进行+1的操作 SideTable&amp; table = SideTables()[this]; size_t&amp; refcntStorage = table.refcnts[this]; refcntStorage += SIDE_TABLE_RC_ONE; 3、release实现经过两次Hash查找，找到对应的引用计数值，然后进行-1的操作 SideTable&amp; table = SideTables()[this]; RefcountMap::iterator it = table.refcnts.find(this); it -&gt;second -= SIDE_TABLE_RC_ONE; 4、retainCount实现经过两次Hash查找，找到对应的引用计数值，然后与1相加（因此刚alloc的对象，在对应的引用计数表中实际是没有这个映射的） SideTable&amp; table = SideTables()[this]; size_t refcnt_result = 1; RefcountMap::iterator it = table.refcnts.find(this); refcnt_result += it-&gt;secont &gt;&gt; SIDE_TABLE_RC_SHIFT; 5、dealloc实现 判断对象时候可以释放的条件（五个条件缺一不可） 没有使用nonpointer_isa 没有weak指针指向 没有有关联对象 没有使用ARC或者涉及C++ 当前对象的引用计数没有通过SideTable中的引用计数表来存储的 object_dispose() 实现 objc_destructInstance()实现 clearDeallocating()实现 六、弱引用管理 问题:如何添加weak变量的?(系统是怎样把一个weak变量添加到弱引用表中?)答:对象指针在经过编译器的编译之后调用objc_initweak()，然后storeweak()方法，经过一系列的函数调用栈，最终在weak_register_no_lock()进行弱引用变量的添加，(具体添加位置是)通过hash算法位置查找，如果已经存在当前对象对应的弱引用数组，则直接加进去，如果没有则创建新个新的弱引用数组，然后把第0个位置存放新的weak指针,后面的都初始化nil或者0。 问题: 系统如何实现将废弃对象的weak指针置为nil?答:当对象被dealloc废弃之后，dealloc内部实现中会调用弱引用清除的相关函数(weak_clear_no_lock())。然后在函数实现中，根据当前对象指针，哈希查找弱引用表，把当前对象对应的弱引用都拿出来是一个数组，然后遍历这个数组中所有的弱引用指针置分别置为nil。 七、自动释放池1 自动释放池数据结构编译器会将@autoreleasepool{}改写为: void *ctx = objc_autoreleasePoolPush(); {}中的代码 objc_autoreleasePoolPop(ctx); 下面对上面的主要函数进行一个简单的说明: 1)objc_autoreleasePoolPush内部实现 2)objc_autoreleasePoolPop内部实现 实际objc_autoreleasePoolPop函数在内部做了pop操作，批量将autoreleasepool中的所有的对象都会做一次release操作. 下面对上面的主要函数进行一个简单的说明: 3)AutoreleasePool的结构 是以栈为结点通过双向链表的形式组合而成 是和线程一一对应的 问题:AutoreleasePool的实现结构是怎么样的？(什么是自动释放池?实现原理)答:AutoreleasePool是以栈为结点，通过双向链表的形式组合而成的数据结构。 AutoreleasePool是和线程一一对应的。 2 双向链表 AutoreleasePoolPage 1)AutoreleasePoolPage::push实现流程（释放池多层嵌套） 插入哨兵对象 2)AutoreleasePoolPage::pop实现流程（与push相反） 根据传入的哨兵对象找到对应的位置 给上次push操作之后添加的对象依次发送release消息 回退next指针到正确的位置 [obj autorelease]的实现（对象加入自动释放池）先判断当前next指针是否指向栈顶，如果没有指向栈顶直接将对象加入到next指针位置,结束流程；如果next已经位于栈顶，则增加一个栈结点到链表上，在新的栈添加对象,结束流程 问题: array是什么时候释放的呢? - (void)viewDidLoad { [super viewDidLoad]; NSMutableArray *arrar =[NSMutableArray array]; NSLog(@&quot;%@&quot;,arrar); } 答：在当次runloop将要结束的时候调用AutoreleasePoolPage:pop(),对array对象执行release操作 问题:AutoreleasePool为何可以嵌套使用？答: 多次插入哨兵对象，也就是对一个新的autoreleasePool的创建，如果当前栈没有满，则不需要创建新的page,如果满了，新增一个栈节点 问题: AutoreleasePool的使用场景？答: 在for循环中，alloc图片数据等内存消耗较大的场景手动插入autoreleasePool，每一次for循环都进行一次内存的释放，降低内存消耗 八、循环引用1、三种循环引用：自循环引用、相互循环引用、多循环引用。 2、如何破除循环引用？1) 避免产生循环引用 (如使用代理两个对象,一个是强引用,一个是弱引用)2) 在合适的时机手动断环 3、 常见的循环引用场景：代理（delegate）、block 、 NSTimer 、大环引用 4、具体的解决方案都有哪些？ __weak __block __unsafe_unretained(与weak等效) block破解 (**block在ARC和MRC条件下的区别?**) MRC下，__block修饰对象不会增加其引用计数，避免了循环引用 ARC下，__block修饰对象会被强引用，无法避免循环引用，需手动解环 __unsafe_unretained破解 修饰对象不会增加其引用计数，避免了循环引用。 如果被修饰对象在某一时机被释放，会产生悬空指针。 循环引用的示例？（平时开发时是否有遇到循环引用，又是怎么解决的？） Block使用示例（在后面block讲解时） NSTimer 的循环引用问题 //NSTimer+WeakTimer.h @interface NSTimer (WeakTimer) + (NSTimer *)scheduledWeakTimerWithTimeInterval:(NSTimeInterval)interval target:(id)aTarget selector:(SEL)aSelector userInfo:(id)userInfo repeats:(BOOL)repeats; @end //NSTimer+WeakTimer.m @interface TimerWeakObject : NSObject @property (nonatomic, weak) id target; @property (nonatomic, assign) SEL selector; @property (nonatomic, weak) NSTimer *timer; - (void)fire:(NSTimer *)timer; @end @implementation TimerWeakObject - (void)fire:(NSTimer *)timer { if (self.target) { if ([self.target respondsToSelector:self.selector]) { [self.target performSelector:self.selector withObject:timer.userInfo]; } }else{ [self.timer invalidate]; } } @end @implementation NSTimer (WeakTimer) + (NSTimer *)scheduledWeakTimerWithTimeInterval:(NSTimeInterval)interval target:(id)aTarget selector:(SEL)aSelector userInfo:(id)userInfo repeats:(BOOL)repeats { TimerWeakObject *object = [[TimerWeakObject alloc] init]; object.target = aTarget; object.selector = aSelector; object.timer = [NSTimer scheduledTimerWithTimeInterval:interval target:object selector:@selector(fire:) userInfo:userInfo repeats:repeats]; return object.timer; } @end 内存管理面试总结:问题:什么是ARC?答:自动引用计数。ARC是由LLVM（编译器）和RunTime共同协作来为我们实现自动引用计数的管理。 问题:为什么weak指针指向的对象在废弃之后会被自动置为nil?答:当对象被废弃之后，dealloc内部实现中会调用清除弱引用的相关函数(weak_clear_no_lock())。然后在清除弱引用函数实现中，会通过哈希算法查找被废弃对象在弱引用表中位置，来提取它所对应的弱引用指针的列表数组，然后进行for循环遍历, 把所有的弱引用指针置分别置为nil。 问题:苹果是如何实现AutoreleasePool的?答:AutoreleasePool是以栈为结点，通过双向链表的形式组合而成的数据结构。 问题:什么是循环引用?你遇到过哪些循环引用,是怎样解决的?答: NSTimer循环引用 //__weak修饰，弱应用，对象引用计数不会加1 __weak NSArray *weakArr1; __weak NSArray *weakArr2; { //arr1指向的数组对象没有被注册到autorelease pool NSArray *arr1 = [[NSArray alloc] initWithObjects:@&quot;123&quot;, nil]; weakArr1 = arr1; //arr2指向的数组对象已被注册到autorelease pool NSArray *arr2 = [NSArray arrayWithObjects:@&quot;123&quot;, nil]; weakArr2 = arr2; } //局部变量arr1和arr2的作用域结束， //此时arr1指向的对象不再被强引用，因此被回收； //而arr2指向的对象仍然在autorelease pool中 NSLog(@&quot;%@&quot;, weakArr1);//输出null NSLog(@&quot;%@&quot;, weakArr2);//输出arr2，因为此刻arr2在autorelease pool中，不会因为arr2作用域的结束而被回收 __weak NSObject *weakObj1; __weak NSObject *weakObj2; { __autoreleasing NSObject *obj1 = [[NSObject alloc] init]; //weakObj1指向的对象已被注册到autorelease pool weakObj1 = obj1; __strong NSObject *obj2 = [[NSObject alloc] init]; //weakObj2指向的对象没有被注册到autorelease pool weakObj2 = obj2; } //局部变量obj1和obj2的作用域结束， //此时weakObj2指向的对象不再被强引用，因此被回收； //而weakObj1指向的对象仍然在autorelease pool中 NSLog(@&quot;%@&quot;, weakObj1);//输出&lt;NSObject: 0x100206030&gt;，因为此刻weakObj1在autorelease pool中，不会因为obj1作用域的结束而被回收 NSLog(@&quot;%@&quot;, weakObj2);//输出null Runloop每次循环都是被一个AutoReleasePool包围着的，具体说每次Runloop循环将要结束的时候会释放当前runloop的内存占用。再创建好一个AutoReleasePool给下一次Runloop循环使用。在该方法中创建的array会加入到当次RunLoop的AutoReleasePool中，array会在当前RunLoop将要结束的时候调用AutoreleasePoolPage:pop()，得到内存释放。]]></content>
      <categories>
        <category>iOS笔记</category>
      </categories>
      <tags>
        <tag>iOS面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[iOS面试]第3章 RunTime相关面试问题]]></title>
    <url>%2F2020%2F05%2F23%2FiOS%E9%9D%A2%E8%AF%95-%E7%AC%AC3%E7%AB%A0-RunTime%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[本文主讲RunTime相关面试问题，包括数据结构、类对象与元类对象、消息传递、方法缓存、消息转发、Method-Swizzling、动态添加方法、动态方法解析。 一.类对象与元类对象1) objc_object 实际使用所有对象都是id类型, id对象代表就是objc_object结构体.id = objc_object 分为以下几部分: isa_t 关于isa操作相关(如:获取isa所指向的类对象 或者 通过类对象isa获取它元类对象一些便利方法) 弱引用相关 (如:标记一个对象是否标记过弱引用指针) 关联对象相关(如: 这个对象设置关联属性) 内存管理相关 (如:MRC retain release , ARC @autoreleasepool) 2) objc_class Class = objc_classobjc_class 继承自 objc_object, 所以Class也是一个对象 Class superClass (指向父类对象) cache_t cache (方法缓存结构, 进行消息传递会使用这个数据结构) class_data_bits_t bits (类定义的变量 属性和方法都在这个结构中) 3) isa指针 共用体 isa_t (问题:isa指针是什么含义?) 在32位或64位架构下，都是32或者64个0或者1的二进制数字 ,isa指针分为指针形isa和非指针形isa 指针型isa的值代表Class的地址 非指针型isa的值的部分代表Class的地址 4) isa指针的指向 关于对象，其指向类对象 关于类对象，其指向元类对象 元类对象的isa指针都指向根元类对象，而根元类对象对象的isa指针指向根类对象。 方法调用时,调用实例方法实际上通过isa指针到类对象中进行方法查找.如果调用类方法, 通过类对象isa这种到元类对象中进行方法查找. 5) cache_tcache_t 特点: 用于快速查找方法执行函数 (提高消息传递速度) 是可增量扩展的哈希表结构 (提高查找效率) 是局部性原理的最佳应用 cache_t 理解为一个数组实现的, 里边存储 bucket_t结构体, bucket_t有两个成员变量. key对应OC中 @selector , IMP理解为无类型函数指针. 调用方法时使用SEL, 通过方法选择器名称来寻找具体实现IMP. 6)class_data_bits_t class_data_bits_t主要是对class_rw_t的封装 class_rw_t 代表类相关的读写信息, 对class_ro_t的封装 class_ro_t代表类相关的只读信息 7) class_rw_t 为一个类添加分类中的协议 属性 方法都在protocols properties methods 这三个结构中.这三个数据结构是一个二维数组(list_array_tt) 8) class_ro_t class_ro_t 中一维数组 ivars protocols properties methodList 存储的原始类定义添加的成员变量 协议 属性和方法列表 二.runtime整体数据结构1) method_t method_t结构体封装了函数四要素，其中名称通过SEL方法选择器表示，返回值和参数则由“Type Encodings”类型的字符串表示，函数体则指代了IMP函数指针。 更多关于Type Encodings 2)runtime整体数据结构 三 实例对象、类对象、元类对象 类对象存储实例方法列表等信息 的数据结构 元类对象存储类方法列表等信息 的数据结构. 关于类对象的isa指针指向可以用下图表示： Root class 是根类,分类父类指向nil, 实际指 NSObject这个类 左侧部分指实例对象, 也就是objc_object这个数据结构,实例isa指向实例对象的类对象 右侧部分指元类对象, 任何元类对象isa指针指向根元类对象,根元类对象自身isa指针指向根元类对象.根元类对象superclass指针指向根类对象 当调用类方法从元类对象方法列表中逐级父类往上查找 , 查找到根元类对象(Root class meta)找不到时, 就会去根类(Root class class)对象中查找同名的实例方法实现. 问题:类对象和元类对象有什么区别和联系?答: 实例对象可以通过isa指针找到它的类对象 类对象存储实例方法列表等信息,类对象可以通过它的isa指针找到它的元类对象,从而可以访问类方法列表等信息. 类对象和元类对象都是objc_class数据结构,objc_class数据结构由于继承objc_object,所以类对象和元类对象才有isa指针.进而实例对象可以通过isa指针找到对应类对象,访问实例方法列表等信息, 类对象通过isa指针找到元类对象,访问类方法列表等信息. 问题:如果调用类方法没有对应的实现, 当时有同名的实例方法实现, 这个时候会不会发生崩溃?会不会产生实际调用?答: 由于根元类对象的superclass指针指向了根类对象, 当查找到根元类对象(Root class meta)类方法找不到时, 就会去根类(Root class class)对象中查找同名的实例方法实现,如果找到调用. 四 消息传递机制1) 消息传递流程可以用下图展示消息传递的流程： 注意：在消息缓存中查找是通过哈希表来快速定位函数指针，而在当前类方法列表中查找时，对于已经排序好的列表使用二分查找，而对于没有排序的列表采用一般遍历查找法。 2) 缓存查找例 ：给定值是SEL, 目标值是对应的bucket_t中的IMP. 问题:缓存查找具体的是怎样的流程和步骤?答:缓存查找实际上就是从 cache_t中 把对应bucket_t找出来.根据给定的方法选择器,通过一个函数来映射出bucket_t在数组中映射的位置, 实际上就是哈希查找. 哈希查找通过给定的值, 经过哈希函数算法算出的值, 实际为给定值在数组中的索引位置. 3)当前类中查找 对于已排序好的列表, 采用二分查找算法查找方法对应执行函数. 对于没有排序的列表, 采用一般遍历查找方法对应执行函数. 4)父类逐级查找 问题: 消息传递机制?答:1)缓存是否命中, 当前类方法列表是否命中, 逐级父类方法列表是否命中2)根据三个方面分别讲述具体情况 五 消息转发流程 resolvelnstanceMethod方法中为对象动态添加方法，已达到处理消息未被实现的问题。 当objc_msgSend方法调用找不到响应的函数名称时就会进行消息转发，主要分为3步:1、动态方法解析调用方法+(BOOL)resolveInstanceMethod:(SEL)sel(实例方法动态解析)和+ (BOOL)resolveClassMethod:(SEL)sel(类方法动态解析)。 2、备援接收者调用方法 - (id)forwardingTargetForSelector:(SEL)aSelector 3、完全转发调用方法- (void)forwardInvocation:(NSInvocation )anInvocation和- (NSMethodSignature )methodSignatureForSelector:(SEL)aSelector 六 Method-Swizzling+ (void)load{ //获取test方法 Method test = class_getInstanceMethod(self, @selector(test)); //获取otherTest方法 Method otherTest = class_getInstanceMethod(self, @selector(otherTest)); //交换两个方法 method_exchangeImplementations(test, otherTest); } - (void)test{ NSLog(@&quot;test&quot;); } - (void)otherTest{ //实际上是调用test具体实现 [self otherTest]; NSLog(@&quot;otherTest&quot;); } 七 动态添加方法问题:是否使用过performSelector: 方法?答: void testImp (void) { NSLog(@&quot;test invoke&quot;); } + (BOOL)resolveInstanceMethod:(SEL)sel { // 如果是test方法 打印日志 if (sel == @selector(test)) { NSLog(@&quot;resolveInstanceMethod:&quot;); // 动态添加test方法的实现 class_addMethod(self, @selector(test), testImp, &quot;v@:&quot;); //解决了实例方法调用 返回YES return YES; }else{ // 返回父类的默认调用 return [super resolveInstanceMethod:sel]; } } 八 动态方法解析@dynamic (问题:是否使用过@dynamic 关键字?) 动态运行时语言将函数决议推迟到运行时(当把属性标识为@dynamic时, 代表着不需要编译器在编译时为属性生成get方法和set方法的具体实现,而是在运行时具体调用get方法或者set方法时,再去添加具体实现) 编译时语言在编译期进行函数决议(在编译期就确定了方法函数体是哪个, 具体运行过程中不能修改) Runtime面试问题总结问题: [obj foo] 和 objc_msgSend()函数之间有什么关系?答: 实际上消息传递, 在编译期处理过程后, [obj foo] 就转变成了objc_magSend(obj, @selector(foo)) , 之后开始runtime消息传递过程 问题:runtime如何通过Selector找到对应的IMP地址的?答:考察消息传递机制. 首先查找当前实例所对应类对象的缓存是否有Selector对应缓存的IMP实现, 如果缓存命中了,就把命中缓存函数返回给调用方. 如果缓存没有命中,根据当前类方法列表查找Selector对应的IMP实现 如果当前类没有命中, 在根据当前类superclass指针逐级查找父类方法列表,然后查找Selector对应的IMP实现. 问题:能否向编译后的类中添加实例变量?答:(两个点 编译后的类,还是动态添加的类?)不能.由于runtime是支持在运行时动态添加类, 编译之前创建的类,已经完成了实例变量的布局, runtime数据结构中 class_ro_t 编译后没有办法修改的. 问题:能否向动态添加的类中添加实例变量?答:可以. 动态添加的类调用注册类方法前,完成实例变量的添加是可以实现的.]]></content>
      <categories>
        <category>iOS笔记</category>
      </categories>
      <tags>
        <tag>iOS面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[iOS面试]第2章 Objective-C语言特性相关面试问题]]></title>
    <url>%2F2020%2F05%2F23%2FiOS%E9%9D%A2%E8%AF%95-%E7%AC%AC2%E7%AB%A0-Objective-C%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[本文主讲Objective-C语言特性相关面试问题，包括分类、关联对象、扩展、代理、通知、KVO、 KVC、 属性关键字。 一、分类(Category)什么是分类（category）?Category是一个指向分类的结构体的指针，结构体主要包含分类定义的实例方法以及类方法 1、你用分类都做了哪些事？(1)、声明私有方法(2)、分解体积庞大的类文件(3)、把Framework的私有方法公开 2、分类特点(1)、运行时决议（运行时才会添加到宿主类）在编写分类文件之后，并不会立即把分类中添加的内容添加到宿主类中，而是通过runtime把分类中的内容添加到宿主类中(2)、可以为系统类添加分类 分类有多个的情况下，原有类以及每个分类都有同名的分类方法，最后哪个会生效？答：通过源码分析，取决于编译器，最后一个参与编译的分类会生效。分类方法在runtime分配内存时会插在数组前列，在方法查找过程中，分类添加的方法会”覆盖“宿主类的同名方法(添加在，原方法依然存在) 3、分类中都可以添加哪些内容？(1)、实例方法(2)、类方法(3)、协议(4)、属性(只会生成set、get方法，不会生成成员变量)可以写@property但并不会在分类中添加实例变量 分类结构体分析: //objc-runtime-680版本 struct category_t { const char *name; //分类名 classref_t cls; //分类所属的类名 //分类中所有给类添加的实例方法的列表 struct method_list_t *instanceMethods; //分类中所有添加的类方法的列表 struct method_list_t *classMethods; //分类实现的所有协议的列表 struct protocol_list_t *protocols; //分类中添加的所有实例属性列表 struct property_list_t *instanceProperties; // Fields below this point are not always present on disk. // struct property_list_t *_classProperties; method_list_t *methodsForMeta(bool isMeta) { if (isMeta) return classMethods; else return instanceMethods; } property_list_t *propertiesForMeta(bool isMeta) { if (isMeta) return nil; //classProperties else return instanceProperties; } }; 可以看到，分类结构体中会引用其实例对象，类对象，协议以及实例属性的列表。在加载中，系统会读取镜像加载分类文件并关联到他的宿主类中。 4、分类加载调用栈 加载中，分类的方法会“覆盖”原生类的方法，这里的覆盖并不是真正意义上的覆盖，而是将原类的方法在内存指针中后移，而分类方法会前移。不同分类所添加的同方法名的方法也会根据编译顺序而互相覆盖，最后被编译的分类方法将会“覆盖”掉之前编译的分类。由于编译时，分类所拥有的方法会根据分类的名称对应存储在一个数组中，所以相同的分类名会造成编译时的报错。 5、源码分析(1)、分类添加的方法可以”覆盖”原类方法。(2)、同名分类方法谁能生效取决于编译顺序。最后被编译的分类最优先会生效(3)、名字相同的分类会引起编译报错。 二、关联对象1、能否给分类添加”成员变量”？可以！可以写@property，原则上是不可以添加成员变量，但并没有在分类中添加实例变量。实际上可以通过关联对象associated object扩展属性。 //根据指定key 到object对象中获取key相对应的关联值,将关联值作为函数返回值,返回给调用方 id objc_getAssociatedObject(id object, const void * key) //将key和value建立映射关系,将对应关系通过policy策略关联到对象object上面, 关联策略是告诉函数value是copy还是assign, retain形式关联到数组对象上 void objc_setAssociatedObject(id object, const void * key, id value, objc_AssociationPolicy policy) //移除指定对象的所有的关联对象 void objc_removeAssociatedObjects(id object) 在分类中使用关联对象，可以使分类具有成员变量的效果。 2、关联对象的本质分类添加的成员变量，添加到成员变量数组里面了吗？(1)、关联对象由AssociationsManger管理，并在AssociationsHashMap存储。(2)、所有对象的关联内容都在同一个全局容器中。 图说明:1&gt;根据传入value (如 @”Hello”) 和policy 封装成ObjcAssociation结构2&gt; ObjcAssociation 和 key (如 @selector(text) ) 建立映射关系构成 ObjcAssociationMap3&gt; 由object的地址通过DISGUISE函数返回值生成key,和所建立映射结构 ObjcAssociationMap 作为全局容器AssociationHashMap中 object 对应的value ,放到全局容器中 关联对象保存了需要关联实例的值，和引用规则，并使用键Key来指向关联对象，被关联对象作为key又指向了他自身的关联表。 3、源码分析 三、扩展1、一般用扩展做什么？(1)、声明私有属性(2)、声明私有方法(3)、声明私有成员变量 2、扩展特点？(1)、编译时决议(2)、只以声明的形式存在，多数情况下寄生于宿主类的.m中。(3)、不能为系统类添加扩展。 问题： 扩展和类别的区别是什么？从二者的特点来回答 四、代理(Delegate)1&gt;定义1、准确的说是一种软件设计模式。代理设计模式2、iOS当中以@protocol形式体现。3、传递方式一对一。 2&gt; 代理工作流程。 委托方要求协议声明需要的属性以及方法 代理方遵循这个协议，并实现方法，可能返回处理结果 委托方调用代理方遵从的方法，如有返回结果，接收并处理 3&gt;代理遇到问题:问题: 代理方和委托方以什么样的关系存在？应该注意什么问题？答: 声明为weak规避循环引用（代理方强持有strong委托方 委托方需要有一个代理方的声明 声明weak） 五、通知(NSNotification)1、通知特点(1)、是使用观察者模式来实现的用于跨层传递消息的机制。(2)、传递方式为一对多。 问题:通知和代理的区别 模式区别 代理模式 观察者模式 传递方式 一对多 一对一 2、如何实现通知机制？ 问题:通知的实现机制？发送者 ——&gt;通知中心——&gt;广播给多个观察者 问题: 怎么实现通知机制猜想：（类似runtime添加属性的方式）可能会由一个管理者管理一个HashMap表，每一个notificationName对应一个存放有多个观察者对象相关信息( 回调方法)的数组 六、KVO1、KVO介绍 KVO是Key-value observing的缩写。 KVO是OC对观察者设计模式的又一实现。 Apple使用了 isa 混写 (isa-swizzling) 来实现KVO。 这里提到的isa混写模式就是指，注册KVO的时候，系统会动态创建一个被观察对象的子类，然后令被观察对象的isa指针指向该子类，在该子类中重写了setter方法。这样，当原对象属性被修改时（基于KVC的修改），就会调用setter方法，然后通知观察者。 问题:isa-swizzling 混写技术怎么体现?答: 当调用addObserver:forKeyPath:options:context: 后, 系统会在运行时动态创建类KVONotifying_A, 同时将原来A的指针指向类KVONotifying_A 。 问题:isa混写是怎么实现KVO的呢？答:当注册一个对象class的观察者的时候，也就是调用下面的方法，系统会在runtime动态创建一个该对象的子类NSKVONotifiying_class(NSKVONotifiying_类名)，并将isa指针指向该派生类，并重写setter方法，负责通知所有的观察对象 /* options: 有4个值，分别是： NSKeyValueObservingOptionOld 把更改之前的值提供给处理方法 NSKeyValueObservingOptionNew 把更改之后的值提供给处理方法 NSKeyValueObservingOptionInitial 把初始化的值提供给处理方法，一旦注册，立马就会调用一次。通常它会带有新值，而不会带有旧值。 NSKeyValueObservingOptionPrior 分2次调用。在值改变之前和值改变之后。 */ //注册一个监听器用于监听指定的key路径 [self.person addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew context:nil]; 键值观察依赖依赖于NSObject的两个方法willChangeValueForKey:和didChangevalueForKey:继而也会调用的下面的方法observeValueForKeyPath - (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)contex } 例如，A类的实例的name属性被B类的实例监听了。这时，OC的runtime机制生成了一个KVONotifying_A的类来替代原来的A类，重写了+ (Class)class方法，返回[A Class]，从而把自己伪装成A类。重写了A类属性name的setter方法加入了NSObject的两个方法:willChangeValueForKey:(值改变之前)和didChangevlueForKey:(值改变之后)。在一个被观察属性发生改变之前，willChangeValueForKey:一定会被调用，这就会记录旧的值。而当改变发生后，didChangeValueForKey:会被调用，继而observeValueForKey:ofObject:change:context:也会被调用。 2、KVO特点 (什么情况下能使KVO生效呢？) 使用setter方法改变值，KVO才会生效。 使用setValue: forKey: 改变值，KVO才会生效。 成员变量直接修改，需手动添加KVO才会生效。 3、通过KVC设置value能否促使KVO生效？为什么答:可以，KVC会重写setter方法。setValue: forKey:会调用对象的set方法 4、通过成员变量直接赋值value能否生效？不可以。可以在给成员变量赋值前后手动添加 [self willChangeValueForKey: ] 和 [self didChangeValueForKey: ] 。didChangeValueForKey方法会触发KVO回调。 如何实现手动KVO？ - (void)setValue:(id)obj { [self willChangeValueForKey:@&quot;keyPath&quot;]; [super setValue:obj]; [self didChangeValueForKey:@&quot;keyPath&quot;]; } 七、KVCKVC是key-value coding的缩写。 //获取某个实例key同名或者相似名称的实例变量的值 -(id)valueForKey:(NSString *)key //设置某个实例和key同名或者相似名称的实例变量的值 -(void)setValue:(id)value forKey:(NSString *)key 问题: KVC是否会破坏面向对象编程思想？答: 在我们外部知道某个类的私有成员变量名时，可以通过上面两个方法设置/访问，会破坏面向对象编程思想 1、-(id)valueForKey:(NSString *)key 系统实现流程 可以看到，系统先判断有没有对应setter getter方法，如果有则直接执行，如果没有则判断有没有对应的实例变量，如果有则执行实例变量的赋值，没有则会抛出异常。 Accessor Method (访问器方法是否存在判断) Instance var (实例变量是否存在判断) _key _isKey key isKey 问题: valueForKey的实现逻辑？答: 判断访问器方法，是否存在或相似的方法名( getKey key isKey )，存在则返回；不存在再判断实例变量(_key _isKey key isKey)，存在或相似则返回；不存在就调用valueForUndefineKey:然后抛出一个异常 2、-(void)setValue:(id)value forKey:(NSString *)key 系统实现流程 问题:setValue:forKey:的实现逻辑？答: 判断访问器方法，存在或相似则返回；不存在再判断实例变量，存在或相似则返回；不存在就调用setValue:ForUndefineKey:然后抛出一个异常 八、属性关键字1、读写权限 readonly、*readwrite(默认)2、原子性 atomic(默认)、nonatomic。atomic只能保证赋值和获取是线程安全(成员属性)，不能保证操作和访问线程安全。例如NSArray，可以保证赋值和获取对象线程安全，不能保证删除和添加对象线程安全。 3、引用计数(1)、retain/strong （都用于修饰对象，retain在 MRC中使用， stong在ARC中使用）。(2)、assign /unsafe_unretained (assign 修饰基本数据类型/对象类型， unsafe_unretained ARC基本不用)assign特点: 修饰基本数据类型，如int、BOOL等。 修饰对象类型时，不改变其引用计数。 会产生悬垂指针。(3)、weakweak特点 不改变被修饰对象的引用计数。 所指对象在被释放之后会自动置为nil。 问题:通过atomic修饰是怎么保证线程安全的呢？答: 通过atomic修饰一个数组，对其进行赋值获取，保证线程安全，但是对其进行增加、删除是无法保证线程安全的 问题: assign和weak有什么区别？答:从二者的特点来说：assign的特点 可以修饰基本数据类型和对象 修饰对象类型时，不改变引用计数 释放时依然指向原对象内存地址，继续访问会产生悬空指针（野指针是只没有被初始化过的指针 区分） weak的特点 只用于修饰对象 不改变被修饰对象的引用计数 所指对象再被释放之后会自动置为nil (4)、copy问题:浅拷贝和深拷贝有什么区别？答:浅拷贝：对内存地址的复制，让目标对象指针和源对象指向同一块内存空间浅拷贝特点 :1.浅拷贝会增加被拷贝对象的引用计数2.没有发生新的内存分配深拷贝：让目标对象指针和源对象指针指向两片内容相同的内存空间（特点:产生内存分配）深拷贝特点:1.深拷贝不会增加被拷贝对象的引用计数2.深拷贝发生新的内存分配,出现两块内存 深拷贝、浅拷贝区别? 是否开辟了新的内存空间 是否影响了引用计数 2&gt; copy对对象造了什么影响？ 表格总结： 可变对象的copy和mutableCopy都是深拷贝。 不可变对象的copy是浅拷贝，mutableCopy是深拷贝。 copy方法返回的对象都是不可变对象。 3&gt;、copy面试题 @property(copy)NSMutableArray *array? 答: 如果赋值过来的是NSMutableArray, copy之后是NSArray 如果赋值过来的是NSArray, copy之后是NSArray OC语言特性面试总结:1、MRC下如何重写retain修饰变量的setter方法？ @property(nonatomic,retain) id obj; - (void)setObj:(id)obj { //判断防止异常处理 防止如果传进来的是非obj对象，就会release掉非obj的对象 if(_obj != obj) { [_obj release]; _obj = [obj retain]; } } 2、请简述分类实现原理。答: 分类实现原理由运行时来决议的 不同分类中含有同名分类方法,谁最终生效取决于谁最后参与编译,最后参与编译的分类中同名方法会最终生效. 如果分类中的方法和宿主类方法同名,分类方法会覆盖宿主类同名方法. 覆盖指由于消息传递过程中, 优先查找数组靠前的元素,如果找到同名方法就进行调用,实际宿主类同名方法仍然存在. 3、KVO的实现原理是咋样的？答:1)KVO是系统关于观察者模式的实现2)KVO运用isa混写技术,系统会动态创建一个被观察对象的子类，然后令被观察对象的isa指针指向该子类，在该子类中重写了setter方法。这样，当原对象属性被修改时（基于KVC的修改），就会调用setter方法，然后通知观察者。 4、能否为分类添加成员变量？答: 能, 可以通过关联对象associated object来为分类添加成员变量]]></content>
      <categories>
        <category>iOS笔记</category>
      </categories>
      <tags>
        <tag>iOS面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[iOS面试]第1章 UI视图相关面试问题]]></title>
    <url>%2F2020%2F05%2F23%2FiOS%E9%9D%A2%E8%AF%95-%E7%AC%AC1%E7%AB%A0-UI%E8%A7%86%E5%9B%BE%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[本文主讲UI相关面试问题，包括UITableView相关、事件传递&amp;视图相应、图像显示原理、卡顿&amp;掉帧、绘制原理&amp;异步绘制、离屏渲染。 一、UITableView相关1、重用机制 为什么要用重用机制？当UITableView滚动时，如果不用重用机制，会重复初始化原来已经有初始化过的cell，因此用重用机制会节省性能，避免出现卡顿现象 重用机制的原理重用机制主要用到了一个可变数组visiableCells和一个可变的字典类型reusableTableCells,其中visiableCells用来存储当前UITableView显示的cell，reusableTableCells用来存储已经用’identify’缓存的cell。当UITableView滚动的时候，会先在reusableTableCells中根据identify找是否有有已经缓存的cell，如果有直接用，没有再去初始化。 代码实例:自定义tableView 字母索引条 2、数据源同步(1)、数据源同步问题 (2)、数据源同步解决方案1&gt;、并发访问、数据拷贝 并发即多个线程都可以执行同一段时间，不需要相互等待，主线程与用户互动，子线程做所需要的网络数据请求、数据解析及预排版等 主线程事先拷贝一份数据给子线程做网络请求、数据解析、预排版等，如果主线程有相关操作，记录操作，在子线程完成相关操作后将这条操作，与子线程的数据进行同步，再回到主线程刷新界面 缺点：需要拷贝大量数据，耗内存 2&gt;、串行访问 创建一个GCD串行队列，主线程的操作需要等待子线程操作完成 缺点：需要等待子线程完成，可能会耗时较长 3&gt; 比较:两种方案各有利弊串行访问方式: 要求在子线程处理任务特别耗时的时候,我们某一个删除动作可能会有延时.并发访问,数据拷贝方式:要记录数据同步操作,如上边例子需要记录同步删除的动作,需要进行大量的数据源拷贝,对内存的开销是有一定的问题.所以在具体场景中,需要根据实际业务去选择使用哪种方案. 二、事件传递&amp;视图响应1、UIView和CALayer的关系和区别 关系：UIView的内部包含CALayer层。创建UIView时，会自动创建一个CALyer层的对象，通过UIView的layer属性可以访问到。UIView需要显示时，会调用drawRect方法进行绘制，并将所有内容绘制在自己的layer层。也就是CALayer层才有显示功能。区别：UIView负责提供内容，以及负责处理触摸等事件，参与响应链CALayer负责显示内容contents这体现了系统设计的原则:六大职责原则中的 单一原则, 职责上的分工. 2、事件传递与视图响应链 问题:点击c2空白区域,系统最终是以怎样方式找到最终视图响应视图是c2呢?(考察系统有关视图) 事件的分发与传递:1)当iOS程序中发生触摸事件，系统会将事件加入到UIApplication管理的一个任务队列2)UIApplication将处于任务队列最前端的事件向下分发。即UIWindow -&gt;UIView3)UIView首先看自己是否能处理事件，触摸点是否在自己身上。如果能，那么继续寻找子视图。4)遍历子控件，重复以上两步5)如果没有找到，那么自己就是事件处理者6)如果自己不能处理，那么不做任何处理 其中不接受处理的事件情况如下三种： alpha &lt;0.01 userInteractionEnabled = NO hidden ＝ YES.如果父视图不接受事件处理，则子视图也不能接收。事件只要触摸就会产生，关键在于是否有合适的View处理接收事件 1&gt; 如何寻找最合适的View呢？以下两个方法 //返回响应事件的视图 - (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event; //判断点击位置是否在当前视图范围内, 在范围内返回YES - (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event; 这两个方法，第一个方法用于找出事件的响应者，第二个方法用于确定事件触发的位置。 事件传递给窗口或控件的后，就调用hitTest:withEvent:方法寻找更合适的view,如果子控件是合适的view，则在子控件再调用hitTest:withEvent:直到找到最合适的为止。 通过这两个方法来做事件的传递和响应过程，如下图： 2&gt;事件传递流程 hitTest:withEvent:方法内部会进行一个递归调用，对响应者的所有subviews调用hittest，hitTest:withEvent:系统实现如下图： 3&gt;代码实战:方形按钮指定区域接收事件响应 4&gt;视图响应流程 响应者链的传递方法是事件传递的反方法，如果所有的响应者都不处理，则事件被丢弃 视图事件响应三个方法: - (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event; - (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event; - (void)touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event; 三、图像显示原理 CPU GPU通过总线连接 通过CPU进行绘图，将位图经由总线在合适的时机给GPU，GPU做位图的涂层渲染和纹理合成，再放到帧缓冲区域(Frame Buffer)中， 由视频控制器根据VSync在帧缓冲区域中提取屏幕显示内容，显示到手机屏幕中 可以看到，CPU处理了UI布局，绘制，以及图片编解码等预处理工作，最后将bitmap位图提交给GPU进行屏幕渲染。 1、CPU工作Layout(UI布局、文本计算)； Display(绘制，drawRect方法)；Prepare(图片编解码)； Commit(提交位图)。2、GPU渲染管线(openGL)顶点着色、图元装配、光栅化、片段着色、片段处理。GPU渲染管线五步做完后就会,就会把最终像素点提交到对应的帧缓冲区中,然后由视频控制器在对应的VSync信号到来之前,去帧缓冲区中提取最终要显示的屏幕内容。 四、卡顿&amp;掉帧1、原因 UI卡顿、掉帧的原因:保持流畅的UI交互，屏幕的刷新频率应该保持在60帧，即每16.7ms就会进行一次屏幕刷新，如果此时系统中绘制渲染工作还没有完成，导致VSync信号到来之前CPU和GPU无法完成下一帧画面的合成，则会将显示拖延到下一个刷新点，这样就会造成掉帧从而产生卡顿 2、滑动优化方案(1)、CPU对象创建、调整、销毁 , 放到子线程中做；预排版（布局计算、文本计算）, 放到子线程中做；预渲染（文本等异步绘制，图片编解码等）。(2)、GPU纹理渲染（离屏渲染）；视图混合（视图层级复杂度，GPU需要做每个视图的合成）。(在绘制时减少图层层级，将多个层级绘制到一个层级下，以减少GPU在做视图混合时消耗的时间) 如何具体优化呢？ 官方在iOS9.0后对UIImageView设置圆角进行优化，但是设置阴影依然会触发离屏渲染 圆角优化1.使用贝塞尔曲线UIBezierPath和Core Graphics框架画出一个圆角2.使用CAShapeLayer和UIBezierPath设置圆角 shadow优化通过设置shadowPath来优化性能 其他优化方案： 尽量使用不包含透明（alpha）通道的图片资源 尽量设置layer的大小值为整形值 使用一张中间透明图片蒙上去 如果是本地图:直接让美工把图片切成圆角进行显示 上传图片进行显示，可以让服务端处理圆角 利用UIBezierPath（CoreGraphics框架）画出来圆角图片 Core Animation工具检测离屏渲染对于离屏渲染的检测，苹果为我们提供了一个测试工具Core Animation。可以在Xcode-&gt;Open Develeper Tools-&gt;Instruments中找到 五、UIView绘制原理&amp;异步绘制 CALayer会在当前RunLoop结束前调用自身的display方法进行绘制，下图是系统调用CALayer的display方法绘制的流程： 一、系统绘制流程 UIView的drawRect方法是一个空方法，他给调用者提供了一个在系统绘制的基础上二次操作的空间。bitmap作为layer的contents属性的值，在被赋值后提交给GPU进行渲染。我们可以在displayLayer方法中进行异步绘制。 二、异步绘制-[layer.delegate displayLayer:]代理负责生成对应的bitmap设置该bitmap作为layer.contents属性的值 六、离屏渲染1、什么是离屏渲染？ On-Screen Rendering意为当前屏幕渲染，指的是GPU的渲染操作是在当前用于显示的屏幕缓冲区中进行 Off-Screen Rendering意为离屏渲染，指的是GPU在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作 通俗讲: 当设置某一些UI视图的图层属性时，如果未被预合成之前不能用于当前屏幕直接显示的时候，就会触发离屏渲染，比如设置圆角属性，一些视图遮罩。而离屏渲染的概念起源于GPU层面，指的是GPU在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。 当屏渲染：指的是GPU的渲染操作是在当前用于显示的屏幕缓存区中进行。 2、何时会触发？(1)、圆角（layer.masksToBounds = YES 和layer.cornerRadius 同时使用)(2)、图层蒙版 (layer.mask)(3)、阴影 (layer.shadow)(4)、光栅化 ( layer.shouldRasterize=true)(5)、透明度 (layer.allowsGroupOpacity = YES 和 layer.opacity &lt; 1.0) 由于离屏渲染要创建新的渲染缓冲区，同时还要进行上下文的切换，这会增加GPU的处理时间，可能会造成掉帧 3、为何要避免离屏渲染？(1)、触发离屏渲染，会增加GPU的工作量，会导致CPU和GPU的工作总耗时超过16.7毫秒，会导致UI的卡顿和掉帧。(2)、创建新的渲染缓冲区，会内存开销。(3)、上下文切换，会导致GPU额外开销。 UI视图相关面试问题总结：1、系统的UI事件传递机制是咋样的？考察hitTest: 和pointInside: 系统内部实现2、使UITableView滚动更流畅的方案或思路都有哪些？(参考滑动优化方案)从CPU和GPU两方面3、什么是离屏渲染？(参考概念 和为何要避免离屏渲染)离屏渲染的概念起源于GPU层面，指的是GPU在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。 4、UIView和CALayer之间的关系是咋样的？]]></content>
      <categories>
        <category>iOS笔记</category>
      </categories>
      <tags>
        <tag>iOS面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Carthage安装和使用教程]]></title>
    <url>%2F2018%2F11%2F18%2FCarthage%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Carthage简单介绍 主页: https://github.com/Carthage/Carthage.git 作者: Justin Spahr-Summers等 版本: 0.31 目标: 用最简单的方式来管理Cocoa第三方框架 性质: 第三方框架管理工具(类似于cocoapods) Carthage为用户管理第三方框架和依赖，但不会自动修改项目文件和生成配置，把对项目结构和设置的控制权交给用户。 原理 自动将第三方框架编程为Dynamic framework(动态库) 限制 仅支持iOS8+。它只支持框架，所以不能用来针对iOS8以前的系统版本进行开发 Carthage的安装和使用 直接下载Carthage.pkg安装包，安装运行 Carthage.pkg下载 如果使用的XCode为7.0+版本，那么也可以使用下面的方法来安装 1 安装homebrew $ /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 2 升级brew $ brew update 3 使用brew来安装 $ brew install Carthage 4 查看版本 $ Carthage version Carthage的使用先进入到项目所在文件夹 $ cd 项目路径 创建一个空的Carthage文件$ touch Cartfile 编辑cartfile文件,例如要安装AFN框架GitHub库可在cartfile文件添加以下内容,指定GitHub的关键字: github &quot;AFNetworking/AFNetworking&quot; 或者填写其他git源,指定git关键词: git &quot;https://github.com/AFNetworking/AFNetworking.git&quot; 保存并关闭cartfile文件，使用cartfile安装框架$ Carthage update --platform iOS 注: 不追加参数会编译出 iOS、OSX、tvos多个framework 注2: 如果失败的话，先用Xcode打开你的项目，Product &gt; Scheme &gt; Manage Schemes 在新窗口中，勾选上 Shared，点击 Close。在终端再次执行这个命令 打开Carthage 查看生成的文件目录$ open Carthage 执行安装依赖命令后的文件夹结构 # 执行文件多出三个文件 Cartfile # 存放需要安装的依赖列表 Cartfile.resolved # 自动生成的依赖关系文件，需提交到git # 确保提交的项目可以使用完全相同的配置与方式运行启用, 跟踪项目当前所用的依赖版本号 Carthage # 自动生成的Carthage目录 (不需要提交到 Git) # 目录下有两个文件夹：Build Checkouts # Build 存放编译后的文件，包括 iOS/Mac/tvOS/watchOS对应的framework # Checkouts 存放从git拉取的依赖库源文件 配置项目打开项目，点击Target -&gt; Build Phases -&gt; Link Library with Libraries选择Carthage/Build目录中要导入的framework 添加编译的脚本（该脚本文件保证在提交归档时会对相关文件和dSYMs进行复制） (1)点击Build Phases，点击“+” -&gt; New Run Script Phase (2)添加添加脚本 /usr/local/bin/Carthage copy-frameworks (3)添加”Input Files” $(SRCROOT)/Carthage/Build/iOS/AFNetworking.framework 在项目中使用第三方库 #import &lt;AFNetworking/AFNetworking.h&gt; 其它： 卸载Carthage：$ brew uninstall Carthage 更新第三方框架：更新多个框架：修改Cartfile文件，并重新执行 $ carthage update更新某个框架：$ carthage update 具体的框架名称 carthage update # 修改了Cartfile文件，并重新编译 carthage update Alamofire # 仅更新Alamofire框架 carthage update --platform ios # 仅编译iOS平台的framework carthage bootstrap # 从本地库重新编译依赖 Carthage优缺点Carthage的优点​ 1）使用了CocoaPods的项目是高度集成的，而Carthage更灵活强调尽可能将任务委托给Xcode和Git。​ CocoaPods在使用中会自动创建和更新workspace、依赖和Pod项目并进行整合;​ Carthage在使用中不需要创建和集成相应的workspace和project,只需要依赖打包好的framework文件即可。​ 总结一下，CocoaPods的方法更容易使用，而Carthage更灵活且对项目没有侵入性。​ 2）CocoaPods相对来说功能要比Carthage多很多，因此也更复杂,而CocoaPods配置简单项目干净。​ 3）CocoaPods有一个中心仓库，而Carthage是去中心化的，没有中心服务器也就避免了可能因中心节点错误而带来的失败，即Carthage每次配置和更新环境，只会去更新具体的库，时间更快。​ 4) Carthage 管理的依赖只需编译一次，项目干净编译时，不会再去重新编译依赖，节省时间​ 5) 与 CocoaPods 无缝集成，一个项目能同时拥有 CocoaPods 和 Carthage Carthage的不足 仅支持 iOS8 + 它只支持框架，所以不能用来针对 iOS 8 以前的系统版本进行开发 支持的 Carthage 安装的第三方框架和依赖不如 CocoaPods 丰富 无法在 Xcode 里定位到第三方库源码 Carthage的工作过程说明① 创建一个Cartfile文件，在该文件中列出您想使用的框架 ② 运行Carthage,获取并编译Cartfile文件中列出的框架 ③ 把框架的二进制文件配置到项目中 关于版本指定Carthage 支持以下几种版本指定方法: = 1.0 代表 “最低 1.0版本”~&gt; 1.0 代表 “表示使用版本1.0以上但是低于2.0的最新版本，如1.5, 1.9”== 1.0 代表 “必须是 1.0 版本” “some-branch-or-tag-or-commit”指定一个 Git 对象 (任何被 git rev-parse 允许的)如果没有版本要求,任何版本的依赖是允许的。 版本好的兼容性是根据语语义化版本控制决定的。这意味着任何大于或等于1.5.1版本,但小于2.0,将认为与1.5.1“兼容”。 Cartfile示例 # Require version 2.3.1 or later 最低2.3.1版本 github &quot;ReactiveCocoa/ReactiveCocoa&quot; &gt;= 2.3.1 # Require version 1.x 必须1.x版本 github &quot;Mantle/Mantle&quot; ~&gt; 1.0 # (大于或等于 1.0 ，小于 2.0) # Require exactly version 0.4.1 必须0.4.1版本 github &quot;jspahrsummers/libextobjc&quot; == 0.4.1 # Use the latest version 使用最新版本 github &quot;jspahrsummers/xcconfigs&quot; # Use the branch 使用git分支 github &quot;jspahrsummers/xcconfigs&quot; &quot;branch&quot; # Use a project from GitHub Enterprise 使用一个企业项目，在 &quot;development&quot; 分支 github &quot;https://enterprise.local/ghe/desktop/git-error-translations&quot; # Use a project from any arbitrary server, on the &quot;development&quot; branch 使用一个私有项目，在 &quot;development&quot; 分支 git &quot;https://enterprise.local/desktop/git-error-translations2.git&quot; &quot;development&quot; # Use a local project 使用一个本地的项目 git &quot;file:///directory/to/project&quot; &quot;branch&quot; Git 中忽略不需要提交到版本库的文件与文件夹修改 .gitignore 文件，增加忽略 Carthage 文件夹就行了： #Carthage Carthage Carthage的其他命令 archive Archives built frameworks into a zip that Carthage can use bootstrap Check out and build the project&#39;s dependencies build Build the project&#39;s dependencies checkout Check out the project&#39;s dependencies copy-frameworks In a Run Script build phase, copies each framework specified by a SCRIPT_INPUT_FILE environment variable into the built app bundle fetch Clones or fetches a Git repository ahead of time help Display general or command-specific help outdated Check for compatible updates to the project&#39;s dependencies update Update and rebuild the project&#39;s dependencies version Display the current version of Carthage]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>iOSTool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GCD之dispatch_semaphore]]></title>
    <url>%2F2018%2F11%2F17%2FGCD%E4%B9%8Bdispatch-semaphore%2F</url>
    <content type="text"><![CDATA[dispatch_semaphore定义1&gt; 信号量：就是一种可用来控制访问资源的数量的标识，设定了一个信号量，在线程访问之前，加上信号量的处理，则可告知系统按照我们指定的信号量数量来执行多个线程。 其实，这有点类似锁机制了，只不过信号量都是系统帮助我们处理了，我们只需要在执行线程之前，设定一个信号量值，并且在使用时，加上信号量处理方法就行了。 2&gt; 信号量主要有3个函数，分别是： // 创建信号量.该函数接收一个long类型的参数, 返回一个dispatch_semaphore_t类型的信号量，值为传入的参数 dispatch_semaphore_t dispatch_semaphore_create(long value) //等待降低信号量. 接收一个信号和时间值，若信号的信号量为0，则会阻塞当前线程，直到信号量大于0或者经过输入的时间值；若信号量大于0，则会使信号量减1并返回，程序继续住下执行 long dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout) // 提高信号量. 使信号量加1并返回 long dispatch_semaphore_signal(dispatch_semaphore_t dsema) //dispatch_semaphore_wait() 与 dispatch_semaphore_signal() 成对使用 dispatch_semaphore 简单使用- (void)dispatchSignal{ //crate的value表示，最多几个资源可访问 dispatch_semaphore_t semaphore = dispatch_semaphore_create(2); dispatch_queue_t quene = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); //任务1 dispatch_async(quene, ^{ dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); NSLog(@&quot;run task 1&quot;); sleep(1); NSLog(@&quot;complete task 1&quot;); dispatch_semaphore_signal(semaphore); });&lt;br&gt; //任务2 dispatch_async(quene, ^{ dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); NSLog(@&quot;run task 2&quot;); sleep(1); NSLog(@&quot;complete task 2&quot;); dispatch_semaphore_signal(semaphore); });&lt;br&gt; //任务3 dispatch_async(quene, ^{ dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); NSLog(@&quot;run task 3&quot;); sleep(1); NSLog(@&quot;complete task 3&quot;); dispatch_semaphore_signal(semaphore); }); } 执行结果： 总结：由于设定的信号值为2，先执行两个线程，等执行完一个，才会继续执行下一个，保证同一时间执行的线程数不超过2。 这里我们扩展一下，假设我们设定信号值=1 dispatch_semaphore_create(1) 那么结果就是： 如果设定信号值=3 dispatch_semaphore_create(3) 那么结果就是： 其实设定为3，就是不限制线程执行了，因为一共才只有3个线程。 dispatch_semaphore 作用 dispatch_semaphore有两个主要应用 ： 保持线程同步 为线程加锁 dispatch_semaphore 保持线程同步- (void)syncThread{ dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); dispatch_semaphore_t semaphore = dispatch_semaphore_create(0); __block int j = 0; dispatch_async(queue, ^{ j = 100; dispatch_semaphore_signal(semaphore); }); dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); NSLog(@&quot;finish j = %d&quot;, j); } 结果输出 j ＝ 100；如果注掉dispatch_semaphore_wait这一行，则 j ＝ 0；原理： 由于是将block异步添加到一个并行队列里面，所以程序在主线程跃过block直接到dispatch_semaphore_wait这一行，因为semaphore信号量为0，时间值为DISPATCH_TIME_FOREVER，所以当前线程会一直阻塞，直到block在子线程执行到dispatch_semaphore_signal，使信号量+1，此时semaphore信号量为1了，所以程序继续往下执行。这就保证了线程间同步了。 dispatch_semaphore 线程加锁- (void)lockThread{ dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); dispatch_semaphore_t semaphore = dispatch_semaphore_create(1); for (int i = 0; i &lt; 100; i++) { dispatch_async(queue, ^{ // 相当于加锁 dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); NSLog(@&quot;i = %d semaphore = %@&quot;, i, semaphore); // 相当于解锁 dispatch_semaphore_signal(semaphore); }); } } 原理：当线程1执行到dispatch_semaphore_wait这一行时，semaphore的信号量为1，所以使信号量-1变为0，并且线程1继续往下执行；如果当在线程1NSLog这一行代码还没执行完的时候，又有线程2来访问，执行dispatch_semaphore_wait时由于此时信号量为0，且时间为DISPATCH_TIME_FOREVER,所以会一直阻塞线程2（此时线程2处于等待状态），直到线程1执行完NSLog并执行完dispatch_semaphore_signal使信号量为1后，线程2才能解除阻塞继续住下执行。以上可以保证同时只有一个线程执行NSLog这一行代码。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AppExtension编程指南:扩展基础]]></title>
    <url>%2F2018%2F11%2F17%2FAppExtension%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97-%E6%89%A9%E5%B1%95%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[通过应用扩展提升你的应用iOS8/OS X v10.10 翻译自苹果官方文档 App Extension Programming Guide–App Extensions Essentials 重要提示： 该文档是一个开发过程中使用API或技术的预发布文档。Apple提供该文档的目的在于让开发者尽快熟悉新技术和新的编程接口，使得开发者针对苹果品牌设备进行开发。但是该文档会不断的更新，使用该文档提供的技术开发的软件应该基于最终操作系统软件和最终的文档进行测试。要时刻关注该文档的更新，以便了解新的API和技术特性。 当iOS 8.0和OS X v10.10发布后，一个全新的概念出现在我们眼前，那就是应用扩展。顾名思义，应用扩展允许开发者扩展应用的自定义功能和内容，能够让用户在使用其他app时使用该项功能。你可以开发一个应用扩展来执行某些特定的任务，用户使用该扩展后就可以在多个上下文环境中执行该任务。比如说，你提供了一个能让用户把内容分享到社交网站的扩展，用户可以在阅读邮件信息或者上网时通过app扩展来发表评论。或者说，如果你提供了一个能展示当前比赛分数的扩展，那么用户可以把它放在通知中心，这样在他们打开Today view时就能看到最新的比分。你甚至可以开发一个提供自定义键盘的扩展，用户可以用它代替iOS系统自带的键盘。 APP扩展的类型iOS和OS X定义了几种应用扩展的类型，每一种类型的扩展都对应系统中的一块区域，比如分享、通知中心以及键盘等。我们把这些支持扩展的区域称为扩展点。每个扩展点都定义了使用策略并提供了API，你可以用来针对该区域创建扩展。要注意的一点是，当你针某个扩展点开发应用扩展时，该应用扩展的功能必须要符合该扩展点的功能特性。 table 1-1 列出了iOS和OS X中的扩展点，并列举了对应扩展点的示例任务。 由于系统定义了扩展特定领域，所以当你在开发应用扩展时，很重要的一点是，你要选择最能匹配你想在app中提供的功能的区域。比如说你要开发一个分享信息的应用扩展，那么你只能选择分享扩展点，而不能使用Today或Action扩展点。 重要提示：你开发的app扩展要精确地匹配Table 1-1中列出的扩展点。你不能开发一个通用的扩展来匹配一个以上的扩展点， Xcode和App Store帮助你创建并交付应用扩展应用扩展不同于应用，虽然你需要基于应用去开发应用扩展，但是每个应用扩展都是独立于应用运行的二进制文件。 当你要创建一个应用扩展时，需要在项目中创建一个新的Target。和其他 Target 一样，扩展 Target 将设置信息和相关文件打包在Products文件下生成一个扩展名为.appex的包。你可以在应用项目中创建多个扩展Target（一个应用程序可以包含一个或多个应用扩展，该应用程序称为主体应用程序）。 开发一个应用扩展最好的切入点是使用 Xcode 在两个平台上为每个扩展点提供的模板去开发。每个模板包含扩展点的具体实现文件和相关设置，并生成独立的二进制文件添加到应用程序的包中。 注意：在iOS中，包含扩展的应用必须提供一个扩展之外的功能。而在OS X中没有这个硬性要求，一个包含扩展的应用不要求必须提供一个额外功能。 为了将扩展分发给使用者，你需要提交一个包含扩展的应用到App Store。用户只要下载并安装了你的应用，那么同时也自动安装了你的应用扩展。 当安装了应用扩展之后，用户首先必须要开启他们。通常，用户可以在他们当前任务的上下文环境中启动扩展。比如，如果你的扩展启用了“Today”通知，那用户可以在通知中心编辑“Today ”view 来添加你的扩展。在其他情况中，用户可以使用 iOS 中的“Settings”或者 OS X 中的“System Preferences”来启用和管理扩展。 用户在不同的情形下体验不同的应用扩展虽然每种类型的应用扩展的功能都是不同的，但对大部分扩展来说，它们在用户体验上还是有一些共同点的。如果你准备开发一个应用扩展，有一点很重要，那就是要理解在你选择的扩展点中，用户体验是什么样的。从一个更高角度看，对于所有扩展来说，最佳的用户体验是快速、流畅以及只关注单一任务。 通常用户通过与系统提供的用户界面进行交互来开启应用扩展。比如说，用户在app中通过激活系统提供的分享按钮来访问 Share 扩展，并从展示的列表中选择扩展。一个应用扩展必须要提供一个图标，以便用户选择和识别，通常情况下，应用扩展的图标与应用程序的图标是相同的。 虽然大多数的应用程序扩展都提供了一些自定义的UI元素，但一般用户不会看到你的自定义用户界面，除非他们进入到应用程序扩展中。当用户进入应用扩展，你的自定义UI可以让用户知晓他们正进入一个新的上下文环境。由于用户可以把你的扩展和当前应用区别开来，所以他们会欣赏你提供的独特功能。当用户意识到扩展其实是独立运行的实体时，他们也可以确认并移除体验不好或功能不好的扩展。 为了让用户平滑过渡到你的应用程序扩展，你要斟酌自定义界面与扩展点界面的风格，做一个权衡。比如说，一个很好的方法就是让你的插件看起来像是通知中心中原生的Widget，再比如说照片编辑扩展，你应该创建一个和 iOS 中 Photos 应用风格相协调的用户界面。 注意：即使你的应用程序扩展没有展示自定义UI（不包括图标），但用户仍然知道该扩展不同于当前的应用，因为它们需要采用特定的操作来激活。 了解应用程序扩展的工作原理iOS8/OS X v10.10 应用程序扩展不是一个应用，相反，它是主体应用程序（containing app）中一个单独的包，并能生成单独的二进制文件。与主体应用程序不同，应用扩展实现的是一个特定的、狭义范围内的任务，并且要严格遵循扩展点的协议。 应用程序扩展的生命周期因为一个应用程序扩展不是一个应用，所以它的生命周期和运行环境也不同于应用。一般情况来说，应用程序扩展的生命周期始于用户从某个应用中启动它。允许用户选择某一种扩展来帮助他们执行某项任务的应用，我们称之为扩展的载体应用（host app）。载体应用（host app）定义了激活扩展的上下文环境，并在其发送请求以响应用户操作时开始扩展的生命周期。当应用扩展完成载体应用发送的请求任务后，该扩展的生命周期也随之结束。 比如说，假定这样一个场景，用户在扩展载体应用（host app）中选中一段文字，点击分享按钮，并从分享列表中选择某一个分享扩展，将选中的内容分享至社交网站。此时，载体应用就会向扩展发送一个包含用户所选文本的请求，启动该扩展，从而去响应用户的请求，即分享所选文本的内容。应用扩展基本的生命周期归纳在下图2-1中。 基本的扩展生命周期 在图2-1中的第2步中，系统实例化载体应用请求中确定的扩展，并在两者之间建立通信通道。然后扩展在载体应用的上下文场景中显示相关界面，并使用其在载体应用请求中接收到的项目来执行任务（在上述的例子中，扩展接收到的项目是用户选中的文本） 在图2-1的第3步中，用户在扩展中执行或取消某个任务，或者直接可以忽略该扩展。在对用户的操作做出响应的过程中，扩展会根据载体应用的请求立即开始执行任务，但如果有特殊需要时，扩展也会在系统后台执行任务，这种情况下，载体不会显示扩展相关界面，并且用户返回到其先前在载体应用中的上下文环境。当应用扩展执行完任务后，不管是立刻返回还是延迟返回，但最后其执行结果都会返回给载体应用。 当扩展开始执行任务之后（或者开始在系统后台执行任务），系统就会终止扩展，比如图2-1中的第4步。 应用扩展是如何进行通信的当应用扩展在运行的时候，它只会直接和载体应用（host app）进行通信，而扩展和主体应用containing app之间不会直接通信。在扩展运行的过程中，主体应用（containing app）甚至都不运行。另外，载体应用（host app）和主体应用（containing app）之间也不会进行通信。图2-2中描述了运行中的应用扩展、载体应用（host app）以及主体应用（containing app）这三者之间的关系。 运行中的扩展仅和载体应用进行通信 当一个扩展需要和主体应用containing app进行通信时，只能在载体应用确定的上下文环境中进行间接通信。比如，一个应用扩展有可能会运行调用它的应用程序。在这个例子中，扩展使用了不能与 containing app 传递消息的API。此外，应用扩展与其 containing app 可以在一个定义为私有的共享容器中访问数据。图2-3描述了扩展和 containing app 之间的间接通信类型。 运行中的扩展可以与其containing app进行间接通信 注意：在底层，系统使用进程间通信来确保应用扩展和扩展载体应用共同来开启无缝结合体验。在你的代码中，你无需考虑这些底层的通信机制，因为你使用的是扩展点和系统提供的高级API。 创建应用扩展iOS8/OS X v10.10 当你准备好开发一个应用扩展时，可以从选择一个支持你想执行的任务的扩展点开始。然后选择适用于你所选的扩展点的Xcode模板，如果需要的话，可使用自定义代码和自定义用户界面来增强默认文件。最后，在你调试并优化你的应用扩展之后，就可以打包进你的应用程序给用户使用了。 从选择正确的扩展点开始每个扩展点都针对一个定义明确的用户场景，你首先要清楚这个应用能为用户提供什么样的功能，所以要选择一个支持该功能的扩展点。这是非常关键的，因为每个扩展点定义了不同的API，为你提供不同的功能开发，所以如果选错了扩展点，那么很有可能无法实现想要的功能。表1-1列出了iOS和OS X中支持的所有扩展点。 选定了一个适用于应用扩展的扩展点后，在你的containing app中会有一个新的Target。添加应用扩展Target最简单的方式就是使用Xcode提供的模板，这些模板为扩展点提供了预配置。 你可以通过菜单选择 File &gt; New &gt; Target在你的Xcode工程中添加一个新Target。在左边的侧边栏中，选择iOS或OS X的Application Extension选项，然后在右边面板呈现的Xcode 模板中选择你想要创建的应用扩展模板，如下图所示： 选择好模板，并在工程中添加Target，在自定义扩展代码之前，你可以试着编译并运行一下项目。如果你是基于Xcode提供的模板创建的扩展，那么当编译成功后，就会生成一个扩展名为 .appex的应用扩展包。 注意64位的架构：一个应用程序扩展在Architectures设置中必须要包含arm64的架构，否则在上传App Store时会被拒绝。创建完一个应用扩展后，你可以在Xcode的“Standard architectures”设置选项中设置arm64架构。 如果你的包含扩展的应用程序使用了一些嵌入框架，那么你的应用程序也必须要包含arm64架构，否则上传App Store时也会被拒绝。 关于64位架构开发环境的更多信息，请根据你的target平台参阅64-Bit Transition Guide for Cocoa Touch或者64-Bit Transition Guide for Cocoa。 在大多数情况下，你可以通过在System Preferences或Settings中启用应用扩展或者授予权限来测试默认的应用扩展，然后可以通过其他应用来访问它。比如你可以在OS X系统中通过Safari中打开一个页面来测试分享扩展，点击分享按钮，然后选择你要测试的扩展即可。 检查默认的扩展模板一般情况下，每个扩展模板都包含一个属性列表文件（就是Info.plist文件），一个View Controller类和一个默认的UI，这些都是扩展点定义的。默认的View Controller类（或principal class）都含有扩展点对应功能的方法，需要我们去实现。 应用扩展Target的Info.plist文件除了识别扩展点外还罗列了应用扩展的详细信息。该文件至少包括NSExtension字典以及扩展点指定的其他键值字典。。比如NSExtensionPointIdentifier的key值就是扩展点的反向DNS名称，比如com.apple.widget-extension。在应用扩展的NSExtension字典中还有其他的Key和值： NSExtensionAttributes：这是一个描述扩展点具体属性的字典，就像照片编辑扩展中的PHSupportedMediaTypes一样。NSExtensionPrincipalClass：这是扩展模板创建的主体视图控制器类，比如SharingViewController。当载体应用程序（host app）调用扩展时，扩展点会实例化这个类。NSExtensionMainStoryboard（只适用于iOS）：扩展默认的Storyboard文件，一般名为MainInterface。 除了在属性列表中设置以外，扩展模板还可以设置一些默认的功能。每个扩展点可以定义扩展点支持的适用于某个类型任务的功能。比如，一个iOS的Document Provider扩展就包含com.apple.security.application-groups的功能。 所有的OS X扩展模板都默认包含应用程序沙箱和com.apple.security.files.user-selected.read-only功能。如果你开发的扩展需要适用网络，或者访问用户的相册，再或者需要访问用户的通讯录，那么你就需要额外定义这些功能。 注意：通常情况下，如果用户允许主应用程序（containing app）访问他们的私有数据，那么主程序里的扩展也同样拥有该权限。 响应“载体程序”（Host App）的请求正如你在Understand How an Extension Works这篇文档中了解的，当用户在host app选择一个扩展，并使host app向扩展发出请求时，就会打开扩展。说的再详细一点，你的扩展会根据用户的操作接收到请求，帮用户执行任务，然后完成或者关闭请求。比如说，一个分享扩展收到了来自host app的请求，然后该扩展会打开相应视图来响应请求。然后用户在该界面中编辑要分享的内容，用户可以选择发送或者不发送，最后扩展根据用户的行为响应完成还是关闭请求。 当host app向扩展发出请求时，一般都会指明扩展运行的上下文。对于很多扩展来说，最重要的一部分就是要设置一个工作项，这个工作项就是用户在使用这个扩展时要处理的工作项。比如说，一个分享扩展的上下文可能就包含用户选择的想要分享的一段文字。 当host app发出一个请求（通常就是调用beginRequestWithExtensionContext:方法），你的扩展就可以用主试图控制器中的 extensionContext 属性来获得上下文，然后使用 NSExtensionContext 类解析上下文并获得工作项。通常，在视图控制器的 loadView 方法中解析上下文并获得工作项，这样在加载完视图后就可以将信息显示在视图界面中了。获取扩展上下文可以使用如下代码： NSExtensionContext *myExtensionContext = [self extensionContext]; 有意思的是内容对象的 inputItems 属性，它包含了应用扩展需要使用的工作项。inputItems 属性包含一个 NSExtensionItem 类型的数组，数组的每一个成员都包含一个可执行的工作项。从上下文中获取工作项可以使用如下代码： NSArray *inputItems = [myExtensionContext inputItems]; 每个 NSExtensionItem 对象都包含若干个描述工作项的属性，比如标题、文本内容、附件信息、用户信息。 注意 attachments 属性，它包含一个与工作项相关联的媒体数据数组。比如说一个分享请求的工作项，那么 attachments 属性可能就包含用户想要分享网页中的信息。 当用户工作项处理完后，应用扩展通常会给用户两个选择，完成任务或取消任务。根据用户的选择，扩展会调用 completeRequestReturningItems:expirationHandler:completion: 方法，把工作项返回给 host app，或者会调用 cancelRequestWithError: 方法，返回一个错误代码。 在iOS中，你的应用程序扩展可能需要更多的时间去处理潜在的需长时间处理的任务，比如说往网上上传内容。这种情况下，你就要使用 NSURLSession 类将该任务转为后台处理的任务。因为转换到后台处理任务需要用一个单独的线程，所以在扩展完成主应用请求并关闭后仍然可以处理。想了解更多关于扩展中NSURLSession类的用法，请参阅：Performing Uploads and Downloads。 重要：虽然你可以设置一个后台URL来上传或下载任务，但是有一些类型的后台任务，比如支持 VoIp 或者在后台播放音乐的任务，是不能通过扩展来实现的。 如果你应用扩展的Info.plist文件中含有 UIBackgroundModes 关键字，那么在上传App Store时会被拒绝。（想了解更多关于 UIBackgroundModes 关键字的内容，请参阅 Information Property List Key Reference 中的 UIBackgroundModes） 优化效率和性能应用扩展在内存使用优先级上要明显低于当前运行的应用程序。不管是 iOS 还是 OS X，系统都会毫不犹豫地终止扩展，因为用户想返回到host app中的主要目标中。但是也有一些应用扩展的内存使用优先级要高于其他扩展，比如说widgets就要求要高一些，因为它要实时的显示一些信息，因为一般用户更倾向于同时开启多个widgets。 你的应用扩展并不拥有主循环线程，你要遵循这一规则，以便让扩展在主循环线程中发挥最好的性能。比如说，如果你的应用扩展阻止了主循环线程，那么在用户使用主应用程序的过程中会造成非常糟糕的用户体验效果。我们需要记住的一点是，GPU在系统中是一个共享的资源，所以应用扩展不会得到很高的优先级照顾。比如说，如果你正在玩一个对GPU消耗很高的游戏，那么由于内存压力比较大，它就有可能会选择关闭Today widget。 设计一个精简的用户界面大多数的扩展点都要求你向用户提供一些自定义的界面，它在用户打开你的应用扩展时呈现给用户。通常情况下，应用扩展的界面要尽可能的简约、内敛，并主要关注一个单一任务。为了提高性能和用户体验效果，你要避免与该扩展功能无关的界面出现。 大多数Xcode 提供的应用扩展模板都包含一个初始界面文件，你可以从这个文件中设计界面开始。 在用户的惯性思维中，一般他们都是通过应用扩展的图标来辨识扩展功能的。通常情况下，应用扩展的图标和它的主体应用的图标是一致的。使用主体应用的图标作为应用扩展的图标有利于用户去判断这个扩展的来源，也就是说让用户确信这个扩展是来源于他们安装的主体应用。当然也有一些例外。 在iOS中，自定义的Action扩展的图标使用其主体应用的图标。在OS X中，如果一个扩展的主体程序只是用来安装扩展的封装包，那么该扩展要提供一个单独的图标，否则都会使用主体应用的图标。 应用扩展要使用一个简短，语义明确的名字，这能让帮助用户把扩展和你的主应用程序联系起来，并且能让他们在系统中更好的管理应用扩展。通过应用扩展 Target的 CFBundleDisplayName 属性来设置它的名称，你可以在Info.plist文件中修改它。如果你没有给 CFBundleDisplayName设置值，也就是没有给扩展设置名称，那么应用扩展会使用其主体应用的名称，也就是CFBundleName属性中的值。 同时一些应用扩展也需要一个简短的说明。比如说，OS X中的 Widget 扩展就会显示一个简单的描述，这能帮助用户更好的选择他们想要显示在今日通知中的Widget扩展。扩展的描述可以在 InfoPlist.strings 文件的widget.description 属性中设置。 确保您的iOS App扩展适用于所有设备您必须确保提交的应用扩展程序是通用的：它必须适用于iPhone，iPod touch和iPad。无论您为包含的应用选择哪个目标设备系列，此要求均适用。Xcode中的应用程序扩展模板已针对通用目标设备系列进行了正确配置。 要声明您的应用扩展程序是通用的，请使用Xcode中的目标设备系列构建设置，指定“iPhone / iPad”值。 确保您的应用扩展程序具有通用性 在keyboard project的Xcode项目导航器中，选择项目文件。如果隐藏了项目编辑器中的project和targets列表，请显示它。为此，请单击project编辑器选项卡栏左侧的按钮。 在project 和 targets列表的targets组中，选择应用扩展程序的targets。 在project编辑器中选择Build Settings选项卡。确保选中Basic 和 Combined按钮，以便于您更轻松地找到所需的设置。 在project编辑器的Deployment group中，查看“Targeted Device Family”设置。对于Debug和Release配置，值应为“iPhone / iPad”。如果您找到不同的值，请将其更正为“iPhone / iPad”。 在设计和构建应用扩展时 使用Auto Layout和size classes类。测试您的应用扩展程序，以确保其符合您对所有设备大小和方向的预期行为。如“ Simulator User Guide所述，在iOS模拟器中执行此操作，如果可能，还可以在两个方向上对物理设备进行测试。 请记住，即使您的主体应用(containing app)仅针对iPad设备系列，您所包含的应用扩展程序也会以兼容模式运行显示在的iPhone应用中。 重要要通过App Review，您必须将“iPhone / iPad”（有时称为*universal)*）指定为应用扩展程序的目标设备系列，无论您为主体应用(containing app)选择哪个目标设备系列。 在以后的iOS更新中，应用扩展程序仅在扩展程序主体应用本机支持的设备（或设备兼容模式）上运行。例如，在兼容模式下使用iPhone应用程序时，在只有iPad的主体应用(containing app)提供的扩展程序将不可见。为确保获得最佳用户体验，我们建议您的主体应用(containing app)和其应用扩展程序是通用的。 调试，配置和测试你的应用扩展 注意：要确保主体应用中的所有扩展都要使用相同签名方式的代码。Xcode项目中的所有target都必须以相同的方式进行代码签名。例如，在测试期间，您可以使用临时代码签名或使用开发人员证书，但必须对项目中的所有target使用相同的方法。要提交到App Store，请使用您的分发证书来获取所有目标。 使用 Xcode 调试应用扩展和调试其他程序基本是一样的，但唯一点不同的是：你要选择一个能访问扩展的载体应用。当你编译运行应用扩展后，Xcode 会运行载体应用，等待你去使用扩展并触发调试点来调试扩展。你要在 scheme 中要为扩展指定一个载体应用（一个 scheme 封装了 Target 编译的说明）。 当你在主体应用工程中添加一个应用扩展的Target时，Xcode 就会为应用扩展默认创建一个 scheme。应用扩展的 scheme 可以让你指定在调试时由哪个应用程序来调用你的扩展，也就是指定一个调试时的载体应用。默认情况下，当你编译运行扩展时，会询问你使用哪个载体应用来调用该扩展。 在你编译运行应用扩展之前，你要确保你的扩展已经选择了一个 scheme。你可以通过 Product &gt; Scheme &gt; MyExtensionName 或者使用 Xcode 菜单栏呼出 scheme 菜单并选择 MyExtensionName 来设置应用扩展的 scheme。 注意：如果你运行主体应用的 scheme 代替应用扩展的 scheme，那么你在编译工程时Xcode会告诉你它正在等待调试应用扩展。 当你编译运行应用扩展时，Xcode会为你列出允许调用该扩展的载体应用程序。当你选择一个载体应用程序并且运行后，调试器就准备开始工作了，并准备好在你打的断点处进行拦截。当你在载体应用程序中使用扩展时，就可以对应用扩展进行Debug调试了。调试应用扩展的方式和使用Xcode调试其他进程一样。 在OS X中，你在载体应用程序中访问扩展之前，要确保该扩展是允许被使用的。一般情况下，在System Preferences的扩展面板中开启或关闭扩展（你也可以在共享或Action菜单中打开应用扩展面板）。这里要注意一点，在 OS X 中使用 Widget 模拟器调试 Widget扩展时，是不需要对其进行开启操作的。当你要调试键盘扩展时，必须要开启该扩展（你可以通过Settings &gt; General &gt; Keyboard &gt; Keyboards开启键盘扩展）。 在调试时，Xcode会在OS X中创建一个持续的编译应用扩展的会话。这意味着，如果你要使用OS X系统下的扩展，你需要使用Finder把它从构建处拷贝到类似 Applications folder的地方。 注意：在Xcode的调试控制台日志中，应用扩展的二进制值可能是和 CFBundleIdentifier 属性关联，而不是 CFBundleDisplayName 属性。 由于应用扩展必须具有响应性和高效性，因此当运行应用扩展时，最好在调试导航器中查看调试指标( the debug gauges)。调试指标显示扩展在运行时如何使用CPU，内存和其他系统资源。当你发现类似占用CPU资源出现异常的性能问题时，例如CPU使用率出现异常高峰，您可以使用Instruments来分析您的扩展，并确定需要改进的地方。通过在任何调试仪表报告中单击Instruments中的配置文件，您可以在调试会话期间打开Instruments（要查看调试仪报告，请单击调试区域中的仪表）。想学习了解调试监控器，请查阅Debug Your App；想学习了解Instruments，请查阅Instruments User Guide。 注意：在Xcode中选择 Product &gt; Profile可以直接在Instruments中编译并运行应用扩展。Instruments使用方案的Profile部分中的可执行文件集作为扩展的载体。 如果要使用Xcode提供的测试框架（比如XCTest APIs）测试应用扩展，你需要在主体应用程序中写一些测试用例代码。想了解更多XCTest的知识，请参阅Testing with Xcode。 分发扩展主体应用程序你无法直接将应用扩展上传至App Store，除非它包含在主体应用程序中，并且你不能将应用扩展从一个应用程序中转到另一个应用程序。 如果想让用户使用你的应用扩展，你必须提交一个主体应用程序到App Store中，并且主体应用程序如要有其他的功能，不能只包含应用扩展。 如果你想提交 OS X 应用程序扩展，推荐你将主体应用程序提交至App Store，但这也不是唯一的途径。在OS X中，主体应用程序就可以只包含应用扩展，而不需要提供扩展外的其他功能。 注意：如果你不使用App Store来将主体应用程序和OS X 扩展交付给用户，那么在主体应用程序通过审核前，Gatekeeper是不会允许应用扩展生效的。同时，如果你不将主体应用程序上传至App Store，那么该主体应用程序也不能签署你的开发者ID名称，所以用户必须明确从主体应用程序中重载Gatekeeper，才可以让应用扩展生效。 常见问题的处理方案当编写自定义代码以执行app扩展任务时，你可能需要处理一些其他多种类型扩展也会出现的情况。在这一章节中，我们将帮助你如何应对和处理这些常见的问题。 使用内嵌框架共享代码你可以创建一个内嵌框架，用于在应用扩展和它的主应用程序（containing app）之间共享代码。比如，你在照片编辑扩展中开发了图片滤镜功能，那么同时该扩展的主应用程序containing app也有这个功能，那么你可以将实现该功能的代码封装成一个框架，并在扩展target和主应用程序target中嵌入这个框架。 你要确保你创建的内嵌框架不包含应用扩展不能使用的API。这类API一般使用unavailability宏来标记，比如像 NS_EXTENSION_UNAVAILABLE。 如果你创建的内嵌框架中包含应用扩展不能使用的API，你可将其安全地Link到containing app，它可以正常使用框架中的API，但是不能与应用扩展共享代码（译者注：也就是应用扩展不能使用该框架提供的所有API，继而无法做到代码共享）。如果你上传App Store的应用扩展中有这种框架，或者其他部分使用了不可用的API，那么审核时会被拒绝。 如果我们要想应用扩展使用内嵌框架，那么首先要配置一下。将target的Require Only App-Extension-Safe API选项设置为Yes。如果你不这样设置，那么Xcode会向你提示警告：linking against dylib not safe for use in application extensions。 重要提示：如果containing app要链接至内嵌框架，那么必须要支持arm64架构，否则在上传App Store时会被拒绝。（如“创建应用扩展”章节中介绍的，所有应用扩展都要支持arm64架构。） 在配置配置Xcode项目时，必须在Copy Files编译阶段选择“Frameworks”作为内嵌框架的目标。 重要提示：我们通常要选择 Frameworks 作为 Copy Files 编译阶段目标。如果你将其设置为 SharedFramework，那么上传App Store时会被拒绝的。 你可以让containing app支持iOS7或更早的版本，但当在iOS8或更新的版本中运行时，要特别注意内嵌框架的安全性。详细内容可以参阅 Deploying a Containing App to Older Versions of iOS。 有关创建和使用内嵌框架的更多内容，请观看WWDC 2014的视频“Building Modern Frameworks”。 与Containing App共享数据应用扩展和它的containing app的安全域是有区别的。即便扩展包是嵌套在containing app包中的。默认情况下，应用扩展和containing app是不能直接访问对方的容器的。 BACKGROUND 要了解容器，阅读 About the iOS File System 中的 File System Programming Guid. 不过你可以通过数据共享来实现这个愿望。比如，你希望应用扩展和它的containing app共享一个单一的大数据集。比如prerendered assets。 要实现数据共享，我们要使用Xcode或者开发者门户网站允许应用扩展和它的containing app成为一个应用组，然后在开发者门户网站中注册应用组，并指明在containing app中使用该应用组。关于应用组的知识请查阅 Entitlement Key Reference 文档的 Adding an App to an App Group 章节。 当你设置好应用组后，应用扩展和它的containing app就可以通过 NSUserDefaults API共享访问用户的信息。我们可以使用 initWithSuiteName: 方法实例化一个 NSUserDefaults 对象，然后传入共享组的标示符。比如一个共享扩展，它或许会更新用户最近经常使用的共享账号，那么我们可以这样来写： // Create and share access to an NSUserDefaults object. NSUserDefaults *mySharedDefaults = [[NSUserDefaults alloc] initWithSuiteName:@"com.example.domain.MyShareExtension"]; // Use the shared user defaults object to update the user's account. [mySharedDefaults setObject:theAccountName forKey:@"lastAccountName"]; 下图向我们展示了应用扩展和它的containing app是如何通过共享容器实现数据共享的. Figure 4-1应用扩展的容器与其containing app的容器是不同的。 重要提示：如果你的应用扩展使用NSURLSession类执行后台的上传下载任务时，你必须要设置一个共享容器，这样扩展和containing app就可以访问到转换传输的数据。后台上传下载的更多知识请参阅 Performing Uploads and Downloads。 如果你设置了共享容器，那么containing app和它包含的允许参与数据分享的扩展就可以对共享容器里的内容进行读写操作了。同时你还必须要对数据的操作进行同步，以避免数据损坏或出错。使用UIDocument类、Core Data或者SQLite可以帮你可以让用户通过要求Safari运行JS文件来访问网络内容，并将结果返回到扩展。 版本说明在iOS 8.2及更高版本中，您也可以使用UIDocument该类来协调共享数据访问。在iOS 9及更高版本中，您可以NSFileCoordinator直接使用该类进行共享数据访问，但是如果您这样做，则必须NSFilePresenter在应用扩展转换为后台时删除对象。 访问网页在分享扩展（iOS与OS X平台）和Action扩展（iOS平台）中，一般都允许用户使用Safari浏览器访问网页并通过执行JavaScript脚本，并将结果返回到扩展中。你也可以在你的扩展运行之前（适用于两个平台）或执行完任务之后（仅适用于iOS平台）通过JavaScript文件修改网页内容。比如分享扩展，它可以帮助用户分享网页上的内容，或者iOS上的Action扩展可能会显示当前网页的指定翻译内容。 如果想添加网页访问和操作应用扩展，那么需要遵循下面几个步骤：1.创建一个JavaScript文件，并申明一个全局对象，命名为 ExtensionPreprocessingJS，并为该对象分配一个新的自定义JavaScript类的实例。2.在应用扩展的属性列表文件中添加关键字 NSExtensionJavaScriptPreprocessingFile，给 Safari 浏览器指明使用哪个 JavaScript 文件。3.在NSExtensionActivationRule字典中，将NSExtensionActivationSupportsWebURLWithMaxCount 赋值一个非零的值。（更多关于 NSExtensionActivationRule 字典的知识请参阅 Declaring Supported Data Types for a Share or Action Extension。）4.当你的应用扩展开始运行时，使用NSItemProvider类获得运行JavaScript文件所返回的结果。5.在iOS系统的应用扩展中，如果你希望Safari在扩展执行完任务后更新网页，那么你要向JavaScript文件中传入值。（在这一步中也使用NSItemProvider类。） 为了告知Safari你的应用扩展中包含一个JavaScript文件，你需要在应用扩展的Info.plist文件中，向NSExtensionAttributes字典添加NSExtensionJavaScriptPreprocessingFile关键字来指明你的JavaScript文件。这个键的值就是你希望当你的应用扩展运行前，Safari要加载的JavaScript文件的名称。比如： &lt;key>NSExtensionAttributes&lt;/key> &lt;dict> &lt;key>NSExtensionJavaScriptPreprocessingFile&lt;/key> &lt;string>MyJavaScriptFile&lt;/string> &lt;!-- Do not include the ".js" filename extension --> &lt;/dict> 在iOS和OS X平台中，在你自定义的JavaScript类中可以定义一个run()函数，该函数就是Safari加载JavaScript文件的入口。在run()函数中，Safari提供了一个名为completionFunction的参数，你可以使用键值对象的形式将结果传给应用扩展。 在iOS平台中，你还可以定义一个finalize()函数，当应用扩展在任务结束阶段调用completeRequestReturningItems:expirationHandler:completion:方法时Safari会调用finalize()函数。在该函数中，可以通过向completeRequestReturningItems:expirationHandler:completion:方法传值，来改变网页内容。 比如，你的iOS应用扩展需要基于一个网页URI启动，并且当它结束运行时改变网页的背景色，那么你需要这样写JavaScript代码： 清单4-1示例run()和finalize()函数 var MyExtensionJavaScriptClass = function() {}; MyExtensionJavaScriptClass.prototype = { run: function(arguments) { // Pass the baseURI of the webpage to the extension. arguments.completionFunction({"baseURI": document.baseURI}); }, // Note that the finalize function is only available in iOS. finalize: function(arguments) { // arguments contains the value the extension provides in [NSExtensionContext completeRequestReturningItems:completion:]. // In this example, the extension provides a color as a returning item. document.body.style.backgroundColor = arguments["bgColor"]; } }; // The JavaScript file must contain a global object named "ExtensionPreprocessingJS". var ExtensionPreprocessingJS = new MyExtensionJavaScriptClass; 在iOS和OS X平台中，你需要编写代码来处理run()函数返回的值，为获取到字典中的值，我们需要指定kUTTypePropertyList类型作为标示符传入NSItemProvider类的 loadItemForTypeIdentifier:options:completionHandler:方法。在该字典中使用 NSExtensionJavaScriptPreprocessingResultsKey作为key来取值。比如下面例子中我们想要获取将 URI 传入 run()的返回值： [imageProvider loadItemForTypeIdentifier:kUTTypePropertyList options:nil completionHandler:^(NSDictionary *item, NSError *error) { NSDictionary *results = (NSDictionary *)item; NSString *baseURI = [[results objectForKey:NSExtensionJavaScriptPreprocessingResultsKey] objectForKey:@"baseURI"]; }]; finalize() 函数是在当应用扩展执行完任务后传参并调用的，创建一个含有我们需要处理的值的字典，然后用NSItemProvider 的 initWithItem:typeIdentifier:方法来封装该字典。比如当扩展执行完任务后我们想让网页变为红色，我们可以这样写： NSExtensionItem *extensionItem = [[NSExtensionItem alloc] init]; extensionItem.attachments = @[[[NSItemProvider alloc] initWithItem: @{NSExtensionJavaScriptFinalizeArgumentKey: @{@"bgColor":@"red"}} typeIdentifier:(NSString *)kUTTypePropertyList]]; [[self extensionContext] completeRequestReturningItems:@[extensionItem] completion:nil]; 执行上传下载任务用户一般的操作习惯都倾向于当使用你的应用扩展完成某个任务后，可以将结果立即反馈在使用扩展的应用中。如果一个扩展要处理的任务包含较长时间的上传下载操作时，你要确保当你的应用扩展关闭后能继续完成该任务。为实现这个功能，我们需要使用NSURLSession类创建一个URL会话并创建后台的上传下载任务。 提示：你可以回想一下其他类型的后台任务，比如后台支持VoIP、后台播放音乐，这些是不能用应用扩展去实现的。更多信息请参阅Respond to the Host App’s Request。 当你的应用扩展准备好上传下载任务后，扩展会完成调用它的应用发出的请求，并在不影响上传下载任务的前提下终止扩展。更多关于扩展处理载体应用请求的知识请参阅Respond to the Host App’s Request。在iOS系统中，如果你的应用扩展在执行完后台任务时并没有在运行，那么系统会自动在后台运行扩展的载体应用，并调用application:handleEventsForBackgroundURLSession:completionHandler: 代理方法。 重要提示：如果你的应用扩展在后台创建了 NSURLSession 任务，那么你必须要设置一个共享容器，以确保扩展和载体应用实现数据共享。我们可以在 NSURLSessionConfiguration 类中使用sharedContainerIdentifier属性来指定一个共享容器的标示符，然后我们就可以通过该标示符获取到共享容器。请参阅 Sharing Data with Your Containing App 文档来设置共享容器。 下面的例子展示了如何配置一个URL会话，并创建一个下载任务： NSURLSession *mySession = [self configureMySession]; NSURL *url = [NSURL URLWithString:@"http://www.example.com/LargeFile.zip"]; NSURLSessionTask *myTask = [mySession downloadTaskWithURL:url]; [myTask resume]; - (NSURLSession *) configureMySession { if (!mySession) { NSURLSessionConfiguration* config = [NSURLSessionConfiguration backgroundSessionConfigurationWithIdentifier:@“com.mycompany.myapp.backgroundsession”]; // To access the shared container you set up, use the sharedContainerIdentifier property on your configuration object. config.sharedContainerIdentifier = @“com.mycompany.myappgroupidentifier”; mySession = [NSURLSession sessionWithConfiguration:config delegate:self delegateQueue:nil]; } return mySession; } 因为在单位时间内只能由一个进程使用后台会话，所以你需要为载体应用中的所有扩展创建不同的后台会话（每个后台会话都要有一个唯一的标示符）。在这里我们建议当载体应用在后台处理扩展的任务时，只使用一个该扩展创建的后台会话。如果你要执行其他的网络相关的任务，那么就要创建相应的URL会话。 如果你需要在后台创建URL会话之前完成载体应用的请求，那么要确保创建和使用会话的代码是有效可执行的。当你的扩展调用 completeRequestReturningItems:completionHandler: 方法告知主叫应用已经完成相关请求后，系统就可以随时终止你的应用扩展。 为分享和Action扩展申明支持的数据类型在你的分享或Action扩展中，在它们的工作中可能会使用到一些数据，并且这些数据的类型各不相同。为了确保只有当用户在载体应用中选择了你的扩展支持的数据类型时，才会展示你的扩展功能。你需要在扩展的Info.plist属性列表文件中添加 NSExtensionActivationRule 关键字。你也可以使用该关键字指定扩展处理每种类型的最大数目。当你的应用扩展运行时，系统会将NSExtensionActivationRule键的值与扩展项的attachments属性中的信息进行比较。关于 NSExtensionActivationRule 关键字的详细信息可以参阅 Action Extension Keys文档中的 Information Property List Key Reference 章节。 比如，你可以申明你的分享扩展支持最多处理10张图片，一部影片和一个网站URL。您可以使用以下字典作为该NSExtensionAttributes键的值： &lt;key&gt;NSExtensionAttributes&lt;/key&gt; &lt;dict&gt; &lt;key&gt;NSExtensionActivationRule&lt;/key&gt; &lt;dict&gt; &lt;key&gt;NSExtensionActivationSupportsImageWithMaxCount&lt;/key&gt; &lt;integer&gt;10&lt;/integer&gt; &lt;key&gt;NSExtensionActivationSupportsMovieWithMaxCount&lt;/key&gt; &lt;integer&gt;1&lt;/integer&gt; &lt;key&gt;NSExtensionActivationSupportsWebURLWithMaxCount&lt;/key&gt; &lt;integer&gt;1&lt;/integer&gt; &lt;/dict&gt; &lt;/dict&gt; 如果你想指定不支持的数据类型，那么你可以将该类型的值设置为0，或者在 NSExtensionActivationRule 中不添加该类型即可。 注意：如果你的分享扩展或iOS中的Action扩展需要访问网页，那你必须要确保 NSExtensionActivationSupportsWebURLWithMaxCount 关键字的值不为0（更多关于在应用扩展中通过JavaScript访问网页的内容请参阅Accessing a Webpage 你也可以使用 NSExtensionItem 定义的 UTI子 类型以便数据检测器检测文本信息，比如电话号码或通讯地址。 NSExtensionActivationRule字典中的键足以满足大多数应用的过滤需求。如果你需要做更复杂的过滤，比如像 public.url 和 public.image 之间的区别，那么你就得在文本中创建断言语句。如果你要创建一个断言，那么就将NSExtensionActivationRule关键字的值设置为你指定的断言字符串。（在运行时，系统会自动将该字符串编译为 NSPredicate 对象 比如，一个应用扩展的附件属性可以指定为PDF文件，可以这样写： {extensionItems = ({ attachments = ({ registeredTypeIdentifiers = ( &quot;com.adobe.pdf&quot;, &quot;public.file-url&quot; ); }); })} 为了指定你的应用扩展可以处理PDF文件，你可以像这样创建断言字符串： SUBQUERY ( extensionItems, $extensionItem, SUBQUERY ( $extensionItem.attachments, $attachment, ANY $attachment.registeredTypeIdentifiers UTI-CONFORMS-TO &quot;com.adobe.pdf&quot; ).@count == $extensionItem.attachments.@count ).@count == 1 以下是更复杂的断言语句的示例： SUBQUERY ( extensionItems, $extensionItem, SUBQUERY ( $extensionItem.attachments, $attachment, ANY $attachment.registeredTypeIdentifiers UTI-CONFORMS-TO &quot;org.appextension.action-one&quot; || ANY $attachment.registeredTypeIdentifiers UTI-CONFORMS-TO &quot;org.appextension.action-two&quot; ).@count == $extensionItem.attachments.@count ).@count == 1 此语句遍历一个NSExtensionItem对象数组，其次是遍历attachments每个扩展项中的数组。对于每个附件，谓词评估附件中每个表示的统一类型标识符（UTI）。当附件表示UTI符合两个不同的指定UTI中的任何一个（您在每个UTI-CONFORMS-TO操作员的右侧看到）时，收集该UTI以进行最终比较测试。TRUE如果应用程序扩展名仅提供了一个支持UTI的扩展项附件，则返回最后一行。 开发过程中，在你创建断言语句之前你可以使用TRUEPREDICATE常量（结果为true）测试你的代码路径。更多断言语句的语法知识请参阅Predicate Format String Syntax。 重要提示：在将你的载体应用上传App Store之前，要确保所有的 TRUEPREDICATE 常量已经替换为指定的断言语句或 NSExtensionActivationRule 关键字，不然载体应用会被App Store拒绝。 配置载体应用以适用于老版本的iOS系统如果你在主体应用中使用了内嵌框架，那么它就可以在iOS8.0之后的版本中使用，即便内嵌框架不支持老版本的系统也没关系。 使主体应用能做到上述这一点的是 dlopen 命令，它可以使你使用条件链接和加载框架包的机制。你可以使用这个命令来代替编译时链接，你可以在 Xcode 的 General 选项或 Build Phases 选项中对该命令进行编辑。其原理就是只有当主体应用在 iOS8.0 或更高的版本中运行时，才会链接使用内嵌框架。 您必须在有条件地 framework bundle的代码语句中使用Objective-C而不是Swift。您的应用程序的其余部分可以用任何一种语言编写，内嵌框架本身也可以用任何一种语言编写。 调用之后dlopen，使用以下类型的语句访问内嵌框架类： MyLoadedClass *loadedClass = [[NSClassFromString (@&quot;MyClass&quot;) alloc] init]; 重要提示：如果你的主体应用使用了内嵌框架，那么就必须要支持arm64架构，否则会被App Store拒绝。 设置Xcode项目中应用扩展的条件链接 1.将每一个应用扩展的运行系统版本设置为iOS8.0或更高，通常选中Xcode中的target，在General选项中设置Deployment info。2.将你主体应用的运行系统版本设置为你想支持的最低iOS版本。3.在你的主体应用中，通过 systemVersion 方法，在运行时检查判断iOS的版本，并判断是否执行dlopen命令。只有你的载体应用在iOS8.0或更高的版本中运行时才会指定dlopen命令。进行此调用时，请务必使用Objective-C，而不是Swift。 特定的iOS API通过dlopen命令使用内嵌框架。你必须选择性的使用这些API，就像使用 dlopen 命令时那样。这些API都是 CFBundleRef 的封装类型： CFBundleGetFunctionPointerForName CFBundleGetFunctionPointersforNames 还有来自NSBundle类的方法： loadloadAndReturnError:classNamed: 因为你一般会将载体应用的运行系统版本配置为较低的版本，所以这些API通常都是在运行时检查，只有确保载体应用在iOS8.0或更高版本中运行时才会使用这些API。]]></content>
      <categories>
        <category>iOS文档</category>
      </categories>
      <tags>
        <tag>文档翻译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018CocoaPods安装和使用]]></title>
    <url>%2F2018%2F11%2F12%2F2018CocoaPods%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[2018 CocoaPods最新安装和使用以及跳过pod setup快速安装教程 第一步:修改ruby源安装CocoaPods,需要ruby环境,然而Mac系统默认会安装好ruby环境。 打开Mac终端 gem sources -l //查看ruby源 默认情况下，会显示 https://rubygems.org/ ruby源在墙内是访问不到的,需要置换为国内 原来一直用的是淘宝的 gem sources -a https://ruby.taobao.org/ 但是淘宝的ruby源不更新了,不建议使用 ,原因可以看这个链接 https://ruby.taobao.org/ 现在用 https://gems.ruby-china.org //删除之前使用的淘宝 gem sources --remove https://ruby.taobao.org/ gem source -a https://gems.ruby-china.org 为了验证你的Ruby镜像是并且仅是gems.ruby-china，可以用以下命令查看： gem sources -l //检测是否成功 只有在终端中出现下面文字才表明你上面的命令是成功的： https://gems.ruby-china.org 补充: 最近ruby-china域名变化由org更改为com，请大家改为 https://gems.ruby-china.com gem sources --remove https://gems.ruby-china.org gem source -a https://gems.ruby-china.com 第二步:升级GemGem是来管理Ruby标准包. gem -v //查看版本 sudo gem update --system //升级gem 不升级在第三步可能,会报很多错误,因为Gem版本太低,无法安装第三步,安装CocoaPods 如果报错： ERROR: While executing gem ... (OptionParser::AmbiguousOption) ambiguous option: -system 安装RVM: curl -L get.rvm.io | bash -s stable 查看版本： ruby -v 已知版本： rvm list known 安装版本： rvm install 2.4.1 第三步,安装CocoaPodssudo gem install cocoapods // Mac OS X 10.11前 输入这一条 sudo gem install -n /usr/local/bin cocoapods //Mac OS X 10.11后 输入这一条 成功后 pod setup 这条命令是将Github上的开源库都托管都安装Podspec索引安装到到本地, 测试如果有版本号，则说明已经安装成功 pod --version //查看版本 第四步,利用cocoapods来安装第三方框架 1 进入要安装框架的项目的.xcodeproj同级文件夹 2 在该文件夹中新建一个文件Podfile pod init pod init首先需要判断当前目录有没有 XCODEPROJ 项目，如果没有直接报错；若果有单个 XCODEPROJ 项目，会直接创建一个 podfile 文件；如果有多个XCODEPROJ 项目，需要指定一个项目，否则会报错： [!] Multiple Xcode projects found, please specify one 或者手动 新建文件Podfile vim Podfile vim Podfile Podfile文件中, 写入以下内容并保存 小提示：（终端vim文件 按 i 可编辑 ，esc 退出编辑，：wq 可保存退出） # Uncomment the next line to define a global platform for your project platform :ios, &#39;7.0&#39; target &#39;MyApp&#39; do # Uncomment the next line if you&#39;re using Swift or would like to use dynamic frameworks # use_frameworks! # Pods for sync pod &#39;AFNetworking&#39; , &#39;~&gt; 3.1.0&#39; end 解释一下platform : ios, ‘7.0’代表当前AFNetworking支持的iOS最低版本是iOS 7.0, 使用时需要去掉前面井号MyApp : 就是你自己的工程名字，pod &#39;AFNetworking&#39;, &#39;~&gt; 3.1.0&#39;代表要下载的AFNetworking版本是3.1.0及以上版本，还可以去掉后面的’~&gt; 3.1.0’，直接写pod ‘AFNetworking’，这样代表下载的AFNetworking是最新版。 3 上面信息表示文件中告诉cocoapods需要安装的框架信息 a.该框架支持的平台 b.适用的iOS版本 c.框架的名称 d.框架的版本 4.导入第三方库–no-repo-update : 不更新仓库,迅速加载第三方框架pod install --no-repo-update pod update --no-repo-update 5.可使用search命令搜索类库名比如:pod search AFNetworking（也可以pod search UI等，可以查询你想要的） 退出搜索, 输入 :wq 第五步,CocoaPods 中删除不需要的第三方库 1 打开Podfile, 找到不需要的类库, 直接删除该类库信息, 或者前面加#注释掉比如要删除AFNetworking库 ,直接去掉Podfile中第五行信息 pod ‘AFNetworking’, ‘~&gt; 3.1.0’ 2 打开终端cd到当前项目的根目录下重新执行 pod update --no-repo-update 3 更新完成就删除成功了 注意: 删除一些三方库后编译可能会报错: library not found for -l 库名 解决:在Build Settings中搜索Other Linker Flags，去掉-l”库名”。(有时不管用,应该是cocoapods的版本问题) 第六, Cocoapods降低版本及卸载一. 移除pod组件 1.这条指令会告诉你Cocoapods组件装在哪里 : which pod 2.你可以手动移除这个组件 : sudo rm -rf 路径 二. 移除 RubyGems 中的 Cocoapods程序包 Q: RubyGems是什么? A: RubyGems（简称 gems）是一个用于对 Ruby组件进行打包的 Ruby 打包系统。 它提供一个分发 Ruby 程序和库的标准格式，还提供一个管理程序包安装的工具。 1.查看gems中本地程序包 gem list 2.移除程序包 sudo gem uninstall cocoapods -v 要移除的版本号 3.安装指定版本的Cocoapods sudo gem install cocoapods -v 要安装的版本号 跳过pod setup快速安装有不少同学执行pod setup这一步, 感觉很慢….. 大约要下载200M的文件,偏偏下载速度出奇的慢,本人保持在30K/S,大约2个小时,关键是没有任何进度条显示,就这样傻乎乎的卡死在这里 一句 pod setup 卡你2个小时,前提还是你安装没有错,如果错误,又要重新2小时. 怎么能如此浪费时间呢? 前面说了,pod setup 这条命令是将Github上的开源库都托管都安装Podspec索引安装到到本地. 简单说就是下载一个包,到本地,也就是这个东西 如果你同事电脑上有安装好,你其实可以从你同事电脑上拷贝过来,直接放到该路径就OK了. 如果你身边没有装好的CocoaPods的朋友,可以访问这个链接 https://github.com/CocoaPods/Specs (github所有的第三方开源库的Podspec文件都托管在这里,这也是你pod setup所要下载的). 选择Download ZIP,用你的浏览器或者迅雷什么的,什么下载快用什么,分分钟下载完目前为111.3M(随着开源库的壮大,会慢慢变大). 解压后为这个样子 对比上图,Specs-master改名为master 放在 ~/.cocoapods/repos 路径即可. ~/.cocoapods/repos 这个路径是在执行 pod setup生成的,所以电脑无法前往此路径是,建议先pod setup下,然后关闭掉即可生成路径. 还有就是,FQ,会很快下载,也就是挂个VPN.]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>iOSTool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo搭建github博客]]></title>
    <url>%2F2018%2F11%2F11%2FHexo%E6%90%AD%E5%BB%BAgithub%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[hexo官方网站 一.系统环境配置：要使用Hexo，需要在你的系统中支持Nodejs以及Git，如果还没有，那就开始安装吧！ 1.安装 node.js​ 下载地址 node.js​ 直接双击下载下来的msi文件，一路下一步就ok了，安装完之后调出命令行或者node命令输入终端，输入node -v看到版本信息就表明安装成功了。如果不会就参考node.js安装 2.安装 git​ 下载地址 git下载​ 直接双击下载下来的git安装程序，同node安装，安装完之后右键发现多了两个Git GUI Here 、Git Bash Here，点击后者，然后输入git –version出现版本信息就表明安装成功了。 3.注册 github账号​ github 官网 github 二.搭建个人博客安装 hexo： 1.更新镜像参考 2018 mac终端更新淘宝npm镜像 2. 安装 hexo 命令 $ sudo cnpm install -g hexo-cli 在这里会有 一段时间等待，请稍等 3. 安装个人博客进入到 你本地的博客存放路径 # 进入本地博客存放目录 $ cd /github/blog # 初始化 个人博客 $ hexo init #等待一段时间 初始化完成以后，会生成以下目录： #生成静态网页 $ hexo g # 启动服务器。默认情况下，访问网址为： http://localhost:4000/ $ hexo s 执行完以后，你就可以去打开 http://localhost:4000/ 看本地版的博客效果了。 三.修改主题：next官网这里有一些常见的hexo主题，读者可以挑选自己喜欢的安装。 个人比较喜欢 next 这款主题。基本呢就是这个效果个人博客 清除缓存文件 (db.json) 和已生成的静态文件 (public)。 $ hexo clean 下载主题 $ git clone https://github.com/iissnan/hexo-theme-next.git themes/next 启动主题：1. 修改Hexo目录下的_config.yml配置文件中的theme属性，将其设置为next theme : next 2.生成静态页面 $ hexo clean # 生成静态页面 $ hexo g # 启动服务器 $ hexo s 打开 http://localhost:4000/ 查看静态页面. 四.部署到GitHub上：修改站点根目录下 _config.yml 文件，在最后添加 # Deployment ## Docs: https://hexo.io/docs/deployment.html deploy: type: git repo: git@github.com:honkerSK/honkerSK.github.io.git #这里填你自己的github地址 branch: master 然后在命令行中执行 #注意需要提前安装一个扩展： $ cnpm install hexo-deployer-git --save #部署网站, 提交到github $ hexo d 到此呢，你的博客基本就搭建完毕了。 博客外部插件：这个是个人博客的第三方插件，一个博客搜索插件，一个评论插件。 搜索插件 algolia： 1) 注册账号 algolia 2) 登陆，进去创建一个索引，如图： 3) 创建一个api key，并赋予增删的权限，如图所示： 并赋予 add records,delete recourds,list indices,delete index 4个权限，如图所示： 4) 然后编辑配置文件，首先是 next 目录下的 _config.yml： 将 # Algolia Search 下的 algolia_search: enable: true ---改为true 5) 然后修改 站点目录下的 _config.yml： 最后增加： #站内搜索： algolia: applicationID: &#39;ZMNZVONxxx&#39; #Application ID 对应的值 apiKey: &#39;a3b6cc86714b99e25e614968b07xxxxx&#39; # 这里填你新建的 api key 对应的值 indexName: &#39;bigDataBeginner&#39; #这里填你 创建的索引名称 chunkSize: 5000 #这个值不动 6) 执行命令，将文章列表同步到 algolia： $ export HEXO_ALGOLIA_INDEXING_KEY=a3b6cc86714b99e25e614968b073f442 # key值对于你新建 api key的值 $ hexo algolia 如果报错 执行 hexo clean 后，重试。然后预览。 评论插件 来必力： 1) 注册账号来必力 2) 登陆，绑定自己博客地址。如图所示： 3) 复制 自己地址对应的id值。如图所示： 4) 编辑 next 目录下的 _config.yml 配置文件： 修改下面一行： livere_uid: &quot;MTAyMC8zMjg2xxxxxx&quot; ---这里填入你复制的id值 清空缓存，重新生成静态页面预览就看到效果了。 Hexo常用命令：$ hexo clean 清除本地缓存 $ hexo g # 或者hexo generate，生成静态页面 $ hexo s # 或者hexo server，可以在http://localhost:4000/ 查看 $ hexo new &quot;postName&quot; #新建文章 $ hexo new page &quot;pageName&quot; #新建页面 $ hexo d # 代码同步到github上 好了，本文到此结束。]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>前端Tool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何优雅管理github的star项目]]></title>
    <url>%2F2018%2F11%2F11%2F%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%AE%A1%E7%90%86github%E7%9A%84star%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[在使用GitHub的过程中，我们经常会Star一些项目。数量一多，完全无法掌控。很早就有人提议官方添加分组和标签功能，但官方给出了回应说，不会做这个功能。所以我们只能使用第三方的工具来管理star项目了，接下来介绍几个常用的工具： Chrome 插件github-stars-manager (推荐)github-stars-manager源代码 Chrome应用商店 比较： 优点 缺点 开源 只有start标签，没有Repositoriesb标签 直接在 github 的 star 页面中增加tag，无缝集成。 需要github授权访问所有公开和私有仓库 可以直接导出数据到chrome书签栏 添加标签要一次读取内容，有延迟 比较新，18年5月创建并上架Chrome应用商店 标签不能排序，看上去比较乱 github-stars-taggergithub-stars-tagger源代码 Chrome应用商店 Github 改版之前的插件，可以管理 star 项目，自带同步功能，最近更新时间17年2月，Github改版之后这个插件不能用了。 CodelfCodelf在线应用 Chrome应用商店 具有Bootstrap 风格，不是很美观，不过它支持导出导入数据，方便同步！ 这个工具有一个 Chrome 插件，不过插件也是一个网页。 比较： 优点 缺点 支持导入导出 在线网站管理，需要授权 响应快 只能导入导出，数据保存在缓存中，容易丢失。 开源的AstralAstral源代码 Astral在线应用 Astral 是一款基于 PHP 使用 Vue.js 构建的 Github star 项目管理工具，方便个人用户管理自己的 star 项目。 比较： 优点 缺点 开源 在线网站标签管理 界面漂亮 不能同步到chrome书签 可以以json导出备份 需要授权 gitmarkgitmark源代码 gitmark在线网址 比较： 优点 缺点 开源 只是在线查看，没有标签管理功能 15年创建项目，最近一直在更新 需要授权访问公共仓库 不开源的GitconstellationGitconstellation网站：http://gitconstellation.com 这是一个不开源的 star 管理工具。界面有一种小清新的风格。它采用分段加载 star 项目的方式加载。 比较： 优点 缺点 界面美观 不开源 只授权了读取公共信息 无法导出相关内容 响应速度慢 OhMyStar2ohmystarapp2 网址： http://www.ohmystarapp.com/ 只能在苹果电脑上用。 分为免费版和收费版。 比较： 优点 缺点 界面美观 不开源 可以导出相关内容 需要授权访问公共仓库 免费版添加标签没有数量限制 添加标签，响应速度慢 Starry 国人开发，Appstore 17年上线， 界面和OhMyStar2类似。 比较： 优点 缺点 可以创建group管理 不开源 能拖拽项目添加到group中 免费版最多添加5个group 响应速度快 需要授权访问公共仓库 不能导出数据 Star Orde AppStore上收费12RMB,有mac版和iOS版。 不建议的MyGitStarMyGitStar源码 这个项目最近更新是14年4月，不清楚具体长啥样。 说明文档为中文 gitstars-openapigitstars-openapi 源码 最近更新是16年9月，现在仅仅是先把 API 公开出来了，还在开发中，网站还没上线。 GitStars.comGitStars.com源码 最近更新是15年3月，现在停了，网站都打不开了，不过源码还在。 Gitrep Gitrep在线网站 网站虽然在，但是基本是废了，不能用。 总结如果你没有私有仓库，建议使用 google插件github-stars-manager。如果是苹果电脑，并且想要本地管理保存，建议使用mac软件 OhMyStar2]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>plug-in</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多个github帐号更新多个hexo博客]]></title>
    <url>%2F2018%2F11%2F11%2F%E5%A4%9A%E4%B8%AAgithub%E5%B8%90%E5%8F%B7%E6%9B%B4%E6%96%B0%E5%A4%9A%E4%B8%AAhexo%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[一台电脑, 多个github帐号的SSH key切换, 更新多个hexo博客 github账号，工作有一个，自己有一个。但是默认下使用ssh key在git push时只有默认账号能免输入账号和密码。 如果你建立并配置了.ssh/config文件后, 但却不知道怎么使用。这篇文章是为你准备的。 打开终端,进入ssh根目录下cd ~/.ssh/ 创建新的 私钥/公钥, 并指定秘钥名称, 如 kentsun_rsa 使用一下命令行, 然后两次回车即可. ssh-keygen -t rsa -f ~/.ssh/随便名字_id_rsa -C &quot;yourmail@xxx.com&quot; 或者使用下面命令行创建秘钥, 需要三次回车, 但是第一次回车需要输入秘钥名字. ssh-keygen -t rsa -C &quot;yourmail@xxx.com&quot; 注意:这次创建新的秘钥 ,不要再三次回车了, 要在第一次回车的地方,填入新秘钥名字, 如果不填将使用默认的id_rsa , 会将原来的ssh_key覆盖. 新秘钥名后面建议加_rsa或者id_rsa. 配置config如果 ~/.ssh/根路径下, 没有config, 则创建一个config文件 touch config config配置如下, 第一个为原来的ssh key配置, kentsun为新的ssh key配置 #第一个账号，默认使用的账号 Host github.com HostName github.com User git IdentityFile ~/.ssh/id_rsa # 第二个账号 kentsun Host kentsun.github.com # kentsun为前缀名，可以任意设置 HostName github.com User git IdentityFile ~/.ssh/kentsun_rsa 我们指定 kentsun.github.com 这个”作用域”下的ssh连接统一指向 github.com ，并且使用之前生成好的 github_rsa 这个密钥加密。 默认的使用 ~/.ssh/id_rsa 这个密钥加密 原理分析: 1.ssh 客户端是通过类似 git@github.com:githubUserName/repName.git 的地址来识别使用本地的哪个私钥的，地址中的 User 是@前面的git， Host 是@后面的github.com。 2.如果所有账号的 User 和 Host 都为 git 和 github.com，那么就只能使用一个私钥。所以要对User 和 Host 进行配置，让每个账号使用自己的 Host，每个 Host 的域名做 CNAME 解析到 github.com，如上面配置中的Host kentsun.github.com。 3.配置了别名之后，新的地址就是git@kentsun.github.com:githubUserName/repName.git。这样 ssh 在连接时就可以区别不同的账号了。 设置新github账户SSH key最终会生成一个文件在用户目录下，打开用户目录，找到.ssh\kentsun_rsa.pub文件，记事本打开并复制里面的内容，打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key： 将刚复制的内容粘贴到key那里，title随便填，保存。 在.ssh根目录下, 清空本地的 SSH 缓存，添加新的 SSH 密钥 到 SSH agent中cd ~/.ssh ssh-add -D ssh-add id_rsa ssh-add id_rsa_second 最后确认一下新秘钥已经添加成功ssh-add -l 输入指令, 验证配置是否成功 默认ssh_key验证 ssh -T git@github.com 新ssh_key验证, 新秘钥名替换username ssh -T git@username.github.com 如下提示信息, 则配置成功 $ ssh -T git@github.com Hi username! You&#39;ve successfully authenticated, but GitHub does not provide shell access. 进入各自项目文件夹，单独设置用户名/邮箱 注意：如果有多个账号，建议使用局部的。 // 取消全局 用户名/邮箱 配置 git config –global –unset user.name git config –global –unset user.email // 单独设置每个repo 用户名/邮箱 git config user.name &quot;用户名&quot; //在config后加上--global即全局 git config user.email &quot;邮箱&quot; 查看设置是否成功git config --list 最后在 hexo 配置文件修改git地址deploy: type: git repository: git@username.github.com:githubUserName/githubUserName.github.io.git branch: master repo配置相当于在原来 git仓库地址中添加了Host名字 kentsun, 其他不变. 可参考我的: deploy: type: git repo: git@kentsun.github.com:KentSun/KentSun.github.io.git branch: master 配置多个git账户重复以上步骤。 修改remote 作用域+ 最后修改一下我们在 kentsun 克隆下来的项目的 remote “作用域” 。 $ git remote rm origin $ git remote add origin git@kentsun.github.com:kentsun/123.git // 注意是 kentsun.github.com $ git push origin master Everything up-to-date]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>前端Tool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安装telnet]]></title>
    <url>%2F2018%2F11%2F11%2F%E5%AE%89%E8%A3%85telnet%2F</url>
    <content type="text"><![CDATA[MacOS 10.12及以下版本，都内置了telnet命令，但是在之后的版本就已经取消了, 会报一下错误-bash: telnet: command not found 所以接下来, 我们先来安装下telnet: 一.telnet安装 安装homebrew /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 使用 homebrew 安装telnet： brew install telnet 二.telnet使用telnet命令用于登录远程主机，对远程主机进行管理。telnet因为采用明文传送报文，安全性不好，很多Linux服务器都不开放telnet服务，而改用更安全的ssh方式了。但仍然有很多别的系统可能采用了telnet方式来提供远程登录，因此弄清楚telnet客户端的使用方式仍是很有必要的。 语法telnet(选项)(参数) 选项-8：允许使用8位字符资料，包括输入与输出； -a：尝试自动登入远端系统； -b&lt;主机别名&gt;：使用别名指定远端主机名称； -c：不读取用户专属目录里的.telnetrc文件； -d：启动排错模式； -e&lt;脱离字符&gt;：设置脱离字符； -E：滤除脱离字符； -f：此参数的效果和指定&quot;-F&quot;参数相同； -F：使用Kerberos V5认证时，加上此参数可把本地主机的认证数据上传到远端主机； -k&lt;域名&gt;：使用Kerberos认证时，加上此参数让远端主机采用指定的领域名，而非该主机的域名； -K：不自动登入远端主机； -l&lt;用户名称&gt;：指定要登入远端主机的用户名称； -L：允许输出8位字符资料； -n&lt;记录文件&gt;：指定文件记录相关信息； -r：使用类似[rlogin](http://man.linuxde.net/rlogin &quot;rlogin命令&quot;)指令的用户界面； -S&lt;服务类型&gt;：设置telnet连线所需的[ip](http://man.linuxde.net/ip &quot;ip命令&quot;) TOS信息； -x：假设主机有支持数据加密的功能，就使用它； -X&lt;认证形态&gt;：关闭指定的认证形态。 参数 远程主机：指定要登录进行管理的远程主机； 端口：指定TELNET协议使用的端口号。 实例telnet 192.168.2.10 Trying 192.168.2.10... Connected to 192.168.2.10 (192.168.2.10). Escape character is &#39;^]&#39;. localhost (Linux release 2.6.18-274.18.1.el5 #1 SMP Thu Feb 9 12:45:44 EST 2012) (1) [login](http://man.linuxde.net/login &quot;login命令&quot;): root Password: Login incorrect]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>iOSTool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用runtime封装字典转模型分类]]></title>
    <url>%2F2018%2F09%2F28%2F%E4%BD%BF%E7%94%A8runtime%E5%B0%81%E8%A3%85%E5%AD%97%E5%85%B8%E8%BD%AC%E6%A8%A1%E5%9E%8B%E5%88%86%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[将后台JSON数据中的字典转成本地的模型，我们一般选用部分优秀的第三方框架，如SBJSON、JSONKit、MJExtension、YYModel等。但是，一些简单的数据，我们也可以尝试自己来实现转换的过程。 快速使用当我们的请求到的数据不是很复杂, 也不希望引入第三方框架的时候, 可以使用下这个分类, 来实现字典转模型. 1.根据请求数据, 创建对应的模型类, 并根据字典中的键值对定义对应的属性 创建模型原则: 从外层到内存, 一个类型字典对应一个模型 示例程序中, 根据plist, 创建了三个类: ShopItem , AttrModel , ListItemModel 注意: 定义的属性名和字典中的键名字一致. 2.在分类中导入最外层模型 3.最外层类中导入 NSObject+EnumDict 分类 4.遵守分类协议 ModelDelegate, 实现协议方法 5.控制器中, 导入最外层模型 ShopItem.h , 解析数据遍历数组, 并字典转模型 原理讲解runtime字典转模型的核心算法思路 以往, 我们字典转模型,总是需要在模型类中定义一个静态方法或者对象方法,来字典转模型, 这样, 我们在不同的模型中, 都必须定义这样一个方法来完成字典转模型, 如果我们写的项目比较大, 模型比较多,这样字典转模型的效率就太低了,耦合性也比较高, 那我们如何做到字典转模型 与 模型类的彻底解耦呢? 我们可以创建一个 NSObject 的分类, 因为所有的类(NSProxy 除外)都继承自 NSObject, 那我们就可以用任意的类去调 NSObject 的这个分类方法, 子类可以任意调用父类方法 那么我们如何在这个分类方法中完成字典转模型呢? 这里就要用到运行时的概念了, 首先我们在分类中导入 &lt;objc/runtime.h&gt;这个框架, 然后进行第一步,获取属性列表const char *kPropertyListKey = "SKPropertyListKey"; + (NSArray *)sk_objcProperties { /* 获取关联对象 */ NSArray *ptyList = objc_getAssociatedObject(self, kPropertyListKey); /* 如果 ptyList 有值,直接返回 */ if (ptyList) { return ptyList; } /* 调用运行时方法, 取得类的属性列表 */ /* 成员变量: * class_copyIvarList(__unsafe_unretained Class cls, unsigned int *outCount) * 方法: * class_copyMethodList(__unsafe_unretained Class cls, unsigned int *outCount) * 属性: * class_copyPropertyList(__unsafe_unretained Class cls, unsigned int *outCount) * 协议: * class_copyProtocolList(__unsafe_unretained Class cls, unsigned int *outCount) */ unsigned int outCount = 0; /** * 参数1: 要获取得类 * 参数2: 类属性的个数指针 * 返回值: 所有属性的数组, C 语言中,数组的名字,就是指向第一个元素的地址 */ /* retain, creat, copy 需要release */ objc_property_t *propertyList = class_copyPropertyList([self class], &outCount); NSMutableArray *mtArray = [NSMutableArray array]; /* 遍历所有属性 */ for (unsigned int i = 0; i < outCount; i++) { /* 从数组中取得属性 */ objc_property_t property = propertyList[i]; /* 从 property 中获得属性名称 */ const char *propertyName_C = property_getName(property); /* 将 C 字符串转化成 OC 字符串 */ NSString *propertyName_OC = [NSString stringWithCString:propertyName_C encoding:NSUTF8StringEncoding]; [mtArray addObject:propertyName_OC]; } /* 设置关联对象 */ /** * 参数1 : 对象self * 参数2 : 动态添加属性的 key * 参数3 : 动态添加属性值 * 参数4 : 对象的引用关系 */ objc_setAssociatedObject(self, kPropertyListKey, mtArray.copy, OBJC_ASSOCIATION_RETAIN_NONATOMIC); /* 释放 */ free(propertyList); return mtArray.copy; } 其实上面这段代码,只有4句是最关键的1./* 获取关联对象 */ NSArray *ptyList = objc_getAssociatedObject(self, kPropertyListKey);如果在程序运行的时候, 模型对象的属性是不会发生变化的, 我们在利用这个函数如果能获取到关联对象的属性列表, 就不用再走下面的代码去利用运行时再去获取属性列表了 2.objc_property_t *propertyList = class_copyPropertyList([self class], &amp;outCount);这句代码就是真正的利用运行时获取属性列表, 这个属性列表是 C 的结构体指针数组,我们必须将其遍历,并利用另外一个函数将取出结构体指针所指向的结构体中国的 C 字符串,也就是属性名称 3.const char *propertyName_C = property_getName(property);获得C字符串后,我们只需要将其转换为 OC 字符串,加到可变数组中即可 4.objc_setAssociatedObject(self, kPropertyListKey, mtArray.copy, OBJC_ASSOCIATION_RETAIN_NONATOMIC);设置属性列表, 就是把已经生成好的属性列表设置到一个类似于属性的东西储存起来, 下次 get 的时候,直接拿出来用即可,有点类似于懒加载. 获取属性列表之后, 我们就要进行字典转模型的操作了首先我们要遍历参数字典, 如果我们获取得属性列表中包含了字典中的 key,就利用 KVC 方法赋值,然后就完成了字典转模型的操作 + (instancetype)sk_objcWithDict:(NSDictionary *)dict { /* 实例化对象 */ id objc = [[self alloc]init]; /* 使用字典,设置对象信息 */ /* 1\. 获得 self 的属性列表 */ NSArray *propertyList = [self sk_objcProperties]; /* 2\. 遍历字典 */ [dict enumerateKeysAndObjectsUsingBlock:^(id _Nonnull key, id _Nonnull obj, BOOL * _Nonnull stop) { /* 3\. 判断 key 是否字 propertyList 中 */ if ([propertyList containsObject:key]) { /* 说明属性存在,可以使用 KVC 设置数值 */ [objc setValue:obj forKey:key]; } }]; /* 返回对象 */ return objc; } 这样, 比如我在 ViewDidLoad 方法中, 自定义一个字典然后我只需要一行代码就可以获取到模型对象,如下 - (void)viewDidLoad { [super viewDidLoad]; /* 创建一个字典 */ NSDictionary *dict = @{ @"name":@"小明", @"age":@18, @"title":@"master", @"height":@1.7, @"something":@"nothing" }; Person *person = [Person sk_objcWithDict:dict]; } 而此时, 模型类中,没有添加任何的构造方法,只有单纯的属性,这样就做到了彻底的解耦, 比如我现在再来一个学生(Student)类,我也无需添加构造方法,也同样只需要调用-(instancetype)sk_objcWithDict:dict;即可. 由于笔者水平有限，文中如果有错误的地方，或者有更好的方法，还望大神指出。附上本文的所有 demo 下载链接，【GitHub】。如果你看完后觉得对你有所帮助，还望在 GitHub 上点个 star。赠人玫瑰，手有余香。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KVO官方文档-键值观察者指南]]></title>
    <url>%2F2018%2F09%2F18%2FKVO%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3-%E9%94%AE%E5%80%BC%E8%A7%82%E5%AF%9F%E8%80%85%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[KVO编程指南 Key-Value Observing Programming Guide 1 Introduction to Key-Value Observing Programming Guide - KVO编程指南介绍Key-value observing is a mechanism that allows objects to be notified of changes to specified properties of other objects. 键 - 值观察是一种机制，当指定对象属性改变的时候允许另一个对象接受通知。 Important: In order to understand key-value observing, you must first understand key-value coding. 重要：了解键值观察之前，首先要理解键值编程 (key-value coding) 1.1 At a Glance - 概括Key-value observing provides a mechanism that allows objects to be notified of changes to specific properties of other objects. It is particularly useful for communication between model and controller layers in an application. (In OS X, the controller layer binding technology relies heavily on key-value observing.) A controller object typically observes properties of model objects, and a view object observes properties of model objects through a controller. In addition, however, a model object may observe other model objects (usually to determine when a dependent value changes) or even itself (again to determine when a dependent value changes). You can observe properties including simple attributes, to-one relationships, and to-many relationships. Observers of to-many relationships are informed of the type of change made—as well as which objects are involved in the change. There are three steps to setting up an observer of a property. Understanding these three steps provides a clear illustration of how KVO works. 键 - 值观察是一种机制，当指定对象属性改变的时候允许另一个对象接受通知。在应用中，对于模型和控制器层之间的交流非常有用。（在 OS X 中，控制器层绑定技术严重依赖于键-值观察。）一个控制器对象通常观察模型对象的属性，视图对象通过控制器观察模型对象的属性。然后，一个模型对象可以观察其它模型对象（通常为了确定从属值是什么时候改变的），或者甚至观察自身（也是为了确定从属值何时变化）。 你可以观察一些属性，比如简单的属性，一对一关系的，一对多关系的。一对多关系的观察者可以收到变化的类型，以及哪些对象发生了改变。 建立属性的观察者有三步。下面提供一个清晰的KVO工作方式演示，来理解这三步。 1.First, see whether you have a scenario where key-value observing could be beneficial, for example, an object that needs to be notified when any changes are made to a specific property in another object. 1.首先，考虑这样的一个场景，例如当对一个A对象的特定做出任何改变的时候，B对象需要被通知。 2.The PersonObject must register as an observer of the BankObject’s accountBalance property by sending an addObserver:forKeyPath:options:context: message. 2.PersonObject必须注册为 BankObject 的 accountBalance 属性的观察者，通过发送一个消息 addObserver:forKeyPath:options:context: Note: The addObserver:forKeyPath:options:context: method establishes a connection between the instances of the objects that you specify. A connection is not established between the two classes, but rather between the two specified instances of the objects. 注意：addObserver:forKeyPath:options:context: 方法规定了一个指定对象实例之间的连接。注意不是两个类之间的连接，两个对象的实例。 3.In order to respond to change notifications, the observer must implement the observeValueForKeyPath:ofObject:change:context: method. This method implementation defines how the observer responds to change notifications. It is in this method that you can customize your response to a change in one of the observed properties. 3.为了响应变化的通知，观察者必须实现方法 observeValueForKeyPath:ofObject:change:context:。这个方法的实现中定义了观察者如何响应改变通知。可以在这个方法中定制被观察属性之一改变时的响应。 Registering for Key-Value Observing describes how to register and receive observation notifications. Registering for Key-Value Observing说明如何注册和接受观察的通知。 4.The observeValueForKeyPath:ofObject:change:context: method is automatically invoked when the value of an observed property is changed in a KVO-compliant manner, or if a key upon which it depends is changed. 4.当被观察属性的值在KVO-compliant方式中改变 或者它依赖的一个key改变的时候，observeValueForKeyPath:ofObject:change:context: 方法自动被调用。 Registering Dependent Keys explains how to specify that the value of a key is dependent on the value of another key. Registering Dependent Keys 解释了指定一个键的值依赖于另一个键的值。 KVO’s primary benefit is that you don’t have to implement your own scheme to send notifications every time a property changes. Its well-defined infrastructure has framework-level support that makes it easy to adopt—typically you do not have to add any code to your project. In addition, the infrastructure is already full-featured, which makes it easy to support multiple observers for a single property, as well as dependent values. KVO Compliance describes the difference between automatic and manual key-value observing, and how to implement both. Unlike notifications that use NSNotificationCenter, there is no central object that provides change notification for all observers. Instead, notifications are sent directly to the observing objects when changes are made. NSObject provides this base implementation of key-value observing, and you should rarely need to override these methods. Key-Value Observing Implementation Details describes how key-value observing is implemented. KVO的优点是，每次属性改变的时候，不需要自己实现发送通知。它良好定义的基础设施有架构层面的支持，使得它易于使用，通常不需要再工程中添加任何代码。此外，基础设施已经是全特性的，它可以很容易地支持单一属性的多个观察者，以及相关的值。 KVO Compliance 描述了自动和手动键值观察的区别，以及如何实现两者。 于使用 NSNotificationCenter 的通知不同，这里没有为所有观察者提供更改通知的中央对象，。相反，更改时通知直接被发送到观察对象。NSObject 提供了键值观察的基本实现，你应该很少需要重写这些方法。 Key-Value Observing Implementation Details描述键值观察室如何实现的。 2 Registering for Key-Value Observing - 注册键值观察In order to receive key-value observing notifications for a property, three things are required: The observed class must be key-value observing compliant for the property that you wish to observe. You must register the observing object with the observed object, using the method addObserver:forKeyPath:options:context:. The observing class must implement observeValueForKeyPath:ofObject:change:context:. 针对一个属性，为了接收键值观察通知，有3个要求： 对于你希望观察的属性，被观察的类必须是键值观察兼容的。 你必须对被观察的对象注册观察对象，使用方法 addObserver:forKeyPath:options:context: 观察类必须实现方法 observeValueForKeyPath:ofObject:change:context: Important: Not all classes are KVO-compliant for all properties. You can ensure your own classes are KVO-compliant by following the steps described in KVO Compliance. Typically properties in Apple-supplied frameworks are only KVO-compliant if they are documented as such. 重要提示：不是所有类对于所有属性都是KVO兼容的。你可以通过下面几个步骤确保你自己的类是KVO兼容的，在KVO Compliance中有描述。通常，如果它们被记录为这种苹果提供的框架属性，那就唯一KVO兼容的。 2.1 Registering as an Observer - 注册为一个观察者In order to be notified of changes to a property, an observing object must first register with the object to be observed by sending it an addObserver:forKeyPath:options:context: message, passing the observer object and the key path of the property to be observed. The options parameter specifies the information that is provided to the observer when a change notification is sent. Using the option NSKeyValueObservingOptionOld specifies that the original object value is provided to the observer as an entry in the change dictionary. Specifying the NSKeyValueObservingOptionNew option provides the new value as an entry in the change dictionary. To receive both values, you would bitwise OR the option constants. The example in Listing 1 demonstrates registering an inspector object for the property openingBalance. 为了属性改变时能被通知到，观察对象首先要对被观察对象进行注册，通过给被观察对象发送消息 addObserver:forKeyPath:options:context: 。传给的参数是观察者对象，被观察对象属性的键路径（key path）。可选的参数是当改变通知被发送的时候，提供给观察者的指定信息。使用选项 NSKeyValueObservingOptionOld 指定原始对象的值，在变化字典中提供给观察者。NSKeyValueObservingOptionNew 选项，提供新的值。为了收到这两个值，你应该对这两个选项常量使用位或。 清单1的例子演示给 openingBalance 属性注册一个观察者 inspector 对象。 - (void)registerAsObserver { /* 注册 `inspector` ，来接收 `account` 对象的属性 `openingBalance` 改变时的通知，并且指定旧值和新值都应该提供给观察者。 */ [account addObserver:inspector forKeyPath:@"openingBalance" options:(NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld) context:NULL]; } When you register an object as an observer, you can also provide a context pointer. The context pointer is provided to the observer when observeValueForKeyPath:ofObject:change:context: is invoked. The context pointer can be a C pointer or an object reference. The context pointer can be used as a unique identifier to determine the change that is being observed, or to provide some other data to the observer. Note: The key-value observing addObserver:forKeyPath:options:context: method does not maintain strong references to the observing object, the observed objects, or the context. You should ensure that you maintain strong references to the observing, and observed, objects, and the context as necessary. 注册的时候，也可以提供一个上下文指针（context pointer），当 observeValueForKeyPath:ofObject:change:context: 被调用的时候，context pointer 会被提供给观察者。context pointer 可以是一个 C pointer 或者 一个对象引用。context pointer 可以用作唯一标识符，来确定正在被观察对象的变化，或者提供某些其他数据给观察者。 注意：键值观察方法 addObserver:forKeyPath:options:context: ，对于观察者对象，被观察的对象或者 context 都不会维持强引用。在必要的时候，你应该自己确保你对于它们维持强引用。 2.2 Receiving Notification of a Change - 针对改变接收通知When the value of an observed property of an object changes, the observer receives an observeValueForKeyPath:ofObject:change:context: message. All observers must implement this method. The observer is provided the object and key path that triggered the observer notification, a dictionary containing details about the change, and the context pointer that was provided when the observer was registered. The change dictionary entry NSKeyValueChangeKindKey provides information about the type of change that occurred. If the value of the observed object has changed, the NSKeyValueChangeKindKey entry returns NSKeyValueChangeSetting. Depending on the options specified when the observer was registered, the NSKeyValueChangeOldKey and NSKeyValueChangeNewKey entries in the change dictionary contain the values of the property before, and after, the change. If the property is an object, the value is provided directly. If the property is a scalar or a C structure, the value is wrapped in an NSValue object (as with key-value coding). If the observed property is a to-many relationship, the NSKeyValueChangeKindKey entry also indicates whether objects in the relationship were inserted, removed, or replaced by returning NSKeyValueChangeInsertion, NSKeyValueChangeRemoval, or NSKeyValueChangeReplacement, respectively. The change dictionary entry for NSKeyValueChangeIndexesKey is an NSIndexSet object specifying the indexes in the relationship that changed. If NSKeyValueObservingOptionNew or NSKeyValueObservingOptionOld are specified as options when the observer is registered, the NSKeyValueChangeOldKey and NSKeyValueChangeNewKey entries in the change dictionary are arrays containing the values of the related objects before, and after, the change. The example in Listing 2 shows the observeValueForKeyPath:ofObject:change:context: implementation for an inspector that reflects the old and new values of the property openingBalance, as registered in Listing 1. 当一个改变了被观察对象属性的值，观察者收到消息 observeValueForKeyPath:ofObject:change:context: 。所有的观察者必须实现这个方法。 观察者被提供 触发观察者通知的对象和 key path ，就是一个字典，包含了变化和注册时填写的context pointer。 变化字典中 NSKeyValueChangeKindKey 提供了关于发生变化的信息。如果被观察对象的值被改变了，NSKeyValueChangeKindKey 返回 NSKeyValueChangeSetting 。根据观察者被注册时指定的选项，NSKeyValueChangeOldKey 和 NSKeyValueChangeNewKey ，在变化字典中包含了属性之前的值以及改变之后的值。如果属性是一个对象，值会被直接提供。如果属性是标量或者C结构体，值会被包含在一个 NSValue 对象中（比如 键值编程）。 如果被观察的属性是一对多的关系（比如数组，集合），NSKeyValueChangeKindKey 也会指定关系中的对象是否被返回的 NSKeyValueChangeInsertion 插入，NSKeyValueChangeRemoval 移除或者 NSKeyValueChangeReplacement 替代。 变化字典的条目 NSKeyValueChangeIndexesKey 是一个 NSIndexSet 对象，指出被改变关系的下标。如果注册的时候 NSKeyValueObservingOptionNew 或者 NSKeyValueObservingOptionOld 被指定为选项，变化字典中 NSKeyValueChangeOldKey 和 NSKeyValueChangeNewKey 就会是数组，包含了相关对象变化之前和之后的值。 清单2的例子演示了 observeValueForKeyPath:ofObject:change:context: 实现 - (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context { if ([keyPath isEqual:@"openingBalance"]) { [openingBalanceInspectorField setObjectValue: [change objectForKey:NSKeyValueChangeNewKey]]; } /* Be sure to call the superclass's implementation *if it implements it*. NSObject does not implement the method. */ [super observeValueForKeyPath:keyPath ofObject:object change:change context:context]; } 2.3 Removing an Object as an Observer 移除对象观察者You remove a key-value observer by sending the observed object a removeObserver:forKeyPath: message, specifying the observing object and the key path. The example in Listing 3 removes the inspector as an observer of openingBalance. 你可以给被观察对象发送一个消息 removeObserver:forKeyPath: 来移除键值观察，指定观察者对象和 key path 。清单3 的例子移除了 openingBalance 的观察者 inspector 。 - (void)unregisterForChangeNotification { [observedObject removeObserver:inspector forKeyPath:@"openingBalance"]; } If the context is an object, you must keep a strong reference to it until removing the observer. After receiving a removeObserver:forKeyPath: message, the observing object will no longer receive any observeValueForKeyPath:ofObject:change:context: messages for the specified key path and object. 如果 context 是一个对象，在移除观察者之前你必须对它保持一个强引用。接收到 removeObserver:forKeyPath: 消息后，观察对象将不在接收任何指定 key path 和对象的 observeValueForKeyPath:ofObject:change:context: 消息。 3 KVO Compliance - KVO 兼容性In order to be considered KVO-compliant for a specific property, a class must ensure the following: The class must be key-value coding compliant for the property, as specified in Ensuring KVC Compliance. KVO supports the same data types as KVC. The class emits KVO change notifications for the property. Dependent keys are registered appropriately (see Registering Dependent Keys). There are two techniques for ensuring the change notifications are emitted. Automatic support is provided by NSObject and is by default available for all properties of a class that are key-value coding compliant. Typically, if you follow standard Cocoa coding and naming conventions, you can use automatic change notifications—you don’t have to write any additional code. Manual change notification provides additional control over when notifications are emitted, and requires additional coding. You can control automatic notifications for properties of your subclass by implementing the class method automaticallyNotifiesObserversForKey:. 考虑到指定属性的 KVO-compliant，类必须确认下面几点： 类对于属性必须被键值编程兼容，在 Ensuring KVC Compliance 中有指出。KVO支持与KVC相同的数据类型。 类对于属性能发出KVO改变通知。 在注册时适当的设置相关的 key （见 Registering Dependent Keys） 有两种技术确保改变通知被发出。自动支持由 NSObject 提供，并且对于一个类的所有属性键值编程兼容性都是可用的。通常来说，如果遵循标准的Cocoa 编程和命名规范，你就可以使用自动变化通知，不用写任何额外的代码。 手动变化通知在当通知被发出的时候提供了额外的控制，并且需要添加一些代码。你可以通过实现类方法 automaticallyNotifiesObserversForKey: 来控制你子类属性的自动通知。 3.1 Automatic Change Notification - 自动变化通知NSObject provides a basic implementation of automatic key-value change notification. Automatic key-value change notification informs observers of changes made using key-value compliant accessors, as well as the key-value coding methods. Automatic notification is also supported by the collection proxy objects returned by, for example, mutableArrayValueForKey:. The examples shown in Listing 1 result in any observers of the property name to be notified of the change. Listing 1 Examples of method calls that cause KVO change notifications to be emitted NSObject 提供了一个自动键值变化通知的基本实现。自动键值变化通知告知所做改变的观察者使用键值兼容的 accessors，以及键值编程方法。自动通知也被返回的集合代理对象支持，例如 mutableArrayValueForKey:。 清单1的例子展示了改变时，属性名被修改的情况下任何观察者的结果。 清单1，导致发出KVO变化通知的方法调用例子 // Call the accessor method. [account setName:@"Savings"]; // Use setValue:forKey:. [account setValue:@"Savings" forKey:@"name"]; // Use a key path, where 'account' is a kvc-compliant property of 'document'. [document setValue:@"Savings" forKeyPath:@"account.name"]; // Use mutableArrayValueForKey: to retrieve a relationship proxy object. Transaction *newTransaction = ; NSMutableArray *transactions = [account mutableArrayValueForKey:@"transactions"]; [transactions addObject:newTransaction]; 3.2 Manual Change Notification - 手动变化通知Manual change notification provides more granular control over how and when notifications are sent to observers. This can be useful to help minimize triggering notifications that are unnecessary, or to group a number of changes into a single notification. A class that implements manual notification must override the NSObject implementation of automaticallyNotifiesObserversForKey:. It is possible to use both automatic and manual observer notifications in the same class. For properties that perform manual notification, the subclass implementation of automaticallyNotifiesObserversForKey: should return NO. A subclass implementation should invoke super for any unrecognized keys. The example in Listing 2 enables manual notification for the openingBalance property allowing the superclass to determine the notification for all other keys. Listing 2 Example implementation of automaticallyNotifiesObserversForKey: 手动变化通知在当通知被发送给观察者的时候提供了更多精细的控制。对于减少不必要的触发通知，或者一大波变化给一个通知，都很有帮助。 实现手动通知的类必须重写 NSObject 实现的方法 automaticallyNotifiesObserversForKey: 。有可能在相同的类中使用自动和手动的观察通知。对于执行手动通知的属性，子类的 automaticallyNotifiesObserversForKey: 方法实现应该返回 NO。子类实现中对于任何为确认的 key，应该调用父类。清单2的例子对于 openingBalance 属性启用了手动通知，允许父类来决定所有其他 key 的通知。 清单2 automaticallyNotifiesObserversForKey:实现的例子 + (BOOL)automaticallyNotifiesObserversForKey:(NSString *)theKey { BOOL automatic = NO; if ([theKey isEqualToString:@"openingBalance"]) { automatic = NO; } else { automatic = [super automaticallyNotifiesObserversForKey:theKey]; } return automatic; } To implement manual observer notification, you invoke willChangeValueForKey: before changing the value, and didChangeValueForKey: after changing the value. The example in Listing 3 implements manual notifications for the openingBalance property. Listing 3 Example accessor method implementing manual notification 要实现手动观察通知，在值变化之前要调用 willChangeValueForKey:，值变化之后要调用 didChangeValueForKey: 。清单3的例子，对于 openingBalance 属性实现了手动通知。 清单3 accessor 方法实现手动通知的例子 - (void)setOpeningBalance:(double)theBalance { [self willChangeValueForKey:@"openingBalance"]; _openingBalance = theBalance; [self didChangeValueForKey:@"openingBalance"]; } You can minimize sending unnecessary notifications by first checking if the value has changed. The example in Listing 4 tests the value of openingBalance and only provides the notification if it has changed. Listing 4 Testing the value for change before providing notification 你可以先检查值是否改变，来将不必要发送的通知最小化。清单3的例子测试了 openingBalance 的值，并且只提供了如果它改变的通知。 清单4 在通知之前测试值得变化 - (void)setOpeningBalance:(double)theBalance { if (theBalance != _openingBalance) { [self willChangeValueForKey:@&quot;openingBalance&quot;]; _openingBalance = theBalance; [self didChangeValueForKey:@&quot;openingBalance&quot;]; } } If a single operation causes multiple keys to change you must nest the change notifications as shown in Listing 5. Listing 5 Nesting change notifications for multiple keys 如果一个操作导致多个 key 的变化，你必须像清单5 一样将变化通知进行嵌套。 清单5 对多个 key 将变化通知嵌套 - (void)setOpeningBalance:(double)theBalance { [self willChangeValueForKey:@&quot;openingBalance&quot;]; [self willChangeValueForKey:@&quot;itemChanged&quot;]; _openingBalance = theBalance; _itemChanged = _itemChanged+1; [self didChangeValueForKey:@&quot;itemChanged&quot;]; [self didChangeValueForKey:@&quot;openingBalance&quot;]; } In the case of an ordered to-many relationship, you must specify not only the key that changed, but also the type of change and the indexes of the objects involved. The type of change is an NSKeyValueChange that specifies NSKeyValueChangeInsertion, NSKeyValueChangeRemoval, or NSKeyValueChangeReplacement. The indexes of the affected objects are passed as an NSIndexSet object. The code fragment in Listing 6 demonstrates how to wrap a deletion of objects in the to-many relationship transactions. Listing 6 Implementation of manual observer notification in a to-many relationship 在有序，一对多关系的情况下，你必须指出不仅 key 发生了变化，还要指出变化的类型以及被调用对象的下标。变换的类型是 NSKeyValueChange ，可以指定 NSKeyValueChangeInsertion，NSKeyValueChangeRemoval或者 NSKeyValueChangeReplacement 。受影响对象的索引作为 NSIndexSet 对象被传递。 清单6 一对多关系的手动观察通知的实现 - (void)removeTransactionsAtIndexes:(NSIndexSet *)indexes { [self willChange:NSKeyValueChangeRemoval valuesAtIndexes:indexes forKey:@&quot;transactions&quot;]; // Remove the transaction objects at the specified indexes. [self didChange:NSKeyValueChangeRemoval valuesAtIndexes:indexes forKey:@&quot;transactions&quot;]; } 4 Registering Dependent Keys - 注册相关 keyThere are many situations in which the value of one property depends on that of one or more other attributes in another object. If the value of one attribute changes, then the value of the derived property should also be flagged for change. How you ensure that key-value observing notifications are posted for these dependent properties depends on the cardinality of the relationship. 一个属性的值取决于一个或者多个其他对象的属性，有很多种情况。如果一个属性变化，那么派生属性也应该被标记改变。对于这些相关属性依赖于关系的基数，你如果确保通知被发出。 4.1 To-one Relationships - 一对一关系To trigger notifications automatically for a to-one relationship you should either override keyPathsForValuesAffectingValueForKey: or implement a suitable method that follows the pattern it defines for registering dependent keys. For example, the full name of a person is dependent on both the first and last names. A method that returns the full name could be written as follows: 对于一对一关系，为了自动触发通知，你应该重写 keyPathsForValuesAffectingValueForKey: 方法，或者实现一个合适的方法，遵循一种模式，它定义取决于注册相关的key。 例如，一个人的全名依赖于人的姓和名。一个返回全名的方法可以写成下面形式： - (NSString *)fullName { return [NSString stringWithFormat:@"%@ %@",firstName, lastName]; } An application observing the fullName property must be notified when either the firstName or lastName properties change, as they affect the value of the property. One solution is to override keyPathsForValuesAffectingValueForKey: specifying that the fullName property of a person is dependent on the lastName and firstName properties. Listing 1 shows an example implementation of such a dependency: Listing 1 Example implementation of keyPathsForValuesAffectingValueForKey: 应用观察 fullName 属性，必须注意到当 firstName 或者 lastName 属性变化时，会影响到 fullName属性的值。 一种解决方法是重写 keyPathsForValuesAffectingValueForKey: ，指定人的 fullName 属性依赖于 lastName 和 firstName 属性。清单1 展示了这样一个例子： 清单1 keyPathsForValuesAffectingValueForKey: 的实现例子 + (NSSet *)keyPathsForValuesAffectingValueForKey:(NSString *)key { NSSet *keyPaths = [super keyPathsForValuesAffectingValueForKey:key]; if ([key isEqualToString:@"fullName"]) { NSArray *affectingKeys = @[@"lastName", @"firstName"]; keyPaths = [keyPaths setByAddingObjectsFromArray:affectingKeys]; } return keyPaths; } Your override should typically invoke super and return a set that includes any members in the set that result from doing that (so as not to interfere with overrides of this method in superclasses). You can also achieve the same result by implementing a class method that follows the naming convention keyPathsForValuesAffecting, where is the name of the attribute (first letter capitalized) that is dependent on the values. Using this pattern the code in Listing 1 could be rewritten as a class method named keyPathsForValuesAffectingFullName as shown in Listing 2. Listing 2 Example implementation of the keyPathsForValuesAffecting naming convention 重写，通常应该调用 super ，并且返回一个 set ，包括这样做的导致结果的任何成员。（在父类中不要因为这个方法的重写造成干扰）。 你也可以通过实现一个类方法达到同样的结果，遵循命名约定 keyPathsForValuesAffecting， 是属性名（首字母大写），依赖于值。清单1中使用这种模式的代码，可以像在清单2中被重写为一个类方法 keyPathsForValuesAffectingFullName 。 清单2 keyPathsForValuesAffecting 命名约定的实现例子 + (NSSet *)keyPathsForValuesAffectingFullName { return [NSSet setWithObjects:@&quot;lastName&quot;, @&quot;firstName&quot;, nil]; } You can’t override the keyPathsForValuesAffectingValueForKey: method when you add a computed property to an existing class using a category, because you’re not supposed to override methods in categories. In that case, implement a matching keyPathsForValuesAffecting class method to take advantage of this mechanism. Note: You cannot set up dependencies on to-many relationships by implementing keyPathsForValuesAffectingValueForKey:. Instead, you must observe the appropriate attribute of each of the objects in the to-many collection and respond to changes in their values by updating the dependent key yourself. The following section shows a strategy for dealing with this situation. 当你使用一个 category 给一个现有的类添加一个计算属性的时候，你不能重写 keyPathsForValuesAffectingValueForKey: 方法，因为不允许重写分类（categories）中的方法。这种情况下，实现一个匹配的 keyPathsForValuesAffecting&lt;Key&gt; 类方法，体现了这种机制的优势。 注意：你不能通过实现 keyPathsForValuesAffectingValueForKey: 方法建立依赖于一对多的关系。相反，你必须观察一对多集合中对象的每个响应属性，并通过更新自己依赖的 key 来响应它们值的变化。下面一节讲了处理这种情况的一种策略。 4.2 To-many Relationships - 一对多关系The keyPathsForValuesAffectingValueForKey: method does not support key-paths that include a to-many relationship. For example, suppose you have a Department object with a to-many relationship (employees) to a Employee, and Employee has a salary attribute. You might want the Department object have a totalSalary attribute that is dependent upon the salaries of all the Employees in the relationship. You can not do this with, for example, keyPathsForValuesAffectingTotalSalary and returning employees.salary as a key. There are two possible solutions in both situations: 1.You can use key-value observing to register the parent (in this example, Department) as an observer of the relevant attribute of all the children (Employees in this example). You must add and remove the parent as an observer as child objects are added to and removed from the relationship (see Registering for Key-Value Observing). In the observeValueForKeyPath:ofObject:change:context: method you update the dependent value in response to changes, as illustrated in the following code fragment: keyPathsForValuesAffectingValueForKey: 方法不支持包含一对多关系的 key-path。例如，Department 对象有一个一对多的关系 对于 Employee，Employee 有 salary 属性。你希望 Department 对象有一个 totalSalary 属性，这个属性依赖于所有 Employees。你不能像下面这样，keyPathsForValuesAffectingTotalSalary 并且将 employees.salary 作为一个 key 返回。 在两种情况中有两个可能的解决方法： 1.可以使用键值观察注册 parent(例子中就是 Department) 作为所有 children（Employees） 相关属性的观察者。你必须添加和移除 parent 。在 observeValueForKeyPath:ofObject:change:context: 方法中，在响应变化中更新相关的值，就像下面的代码所示： - (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context { if (context == totalSalaryContext) { [self updateTotalSalary]; } else // deal with other observations and/or invoke super... } - (void)updateTotalSalary { [self setTotalSalary:[self valueForKeyPath:@&quot;employees.@sum.salary&quot;]]; } - (void)setTotalSalary:(NSNumber *)newTotalSalary { if (totalSalary != newTotalSalary) { [self willChangeValueForKey:@&quot;totalSalary&quot;]; _totalSalary = newTotalSalary; [self didChangeValueForKey:@&quot;totalSalary&quot;]; } } - (NSNumber *)totalSalary { return _totalSalary; } 2.If you’re using Core Data, you can register the parent with the application’s notification center as an observer of its managed object context. The parent should respond to relevant change notifications posted by the children in a manner similar to that for key-value observing. 2.如果使用Core Data，你可以在应用程序的通知中心注册 parent 作为它管理的对象 context 的观察者。parent 应该响应 与键值观察类似方式被 children 发出的的变化通知。 4.3 Key-Value Observing Implementation Details - 键值观察实现细节Automatic key-value observing is implemented using a technique called isa-swizzling. The isa pointer, as the name suggests, points to the object’s class which maintains a dispatch table. This dispatch table essentially contains pointers to the methods the class implements, among other data. When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class. As a result the value of the isa pointer does not necessarily reflect the actual class of the instance. You should never rely on the isa pointer to determine class membership. Instead, you should use the class method to determine the class of an object instance. 自动键值观察是使用一种称为 isa-swizzling 的技术实现。 isa 指针，顾名思义，只想一个对象的类，维持一个调度表。这个调度表基本上包含指向类的方法实现以及其他数据的指针。 当一个观察者被注册，被观察者对象的 isa 指针所指的对象的属性被修改，指的是一个中间的类而不是真正的类。结果就是 isa 指针的值并不一定反映实际类的实例。 你应该永远不要依靠 isa 指针来确定类成员资格。相反，你应该使用 class 方法来确定对象实例的类。 苹果官方文档地址：Key-Value Observing Programming Guide 由于笔者水平有限，文中如果有错误的地方，或者有更好的方法，还望大神指出。附上本文的所有 demo 下载链接，【GitHub】。如果你看完后觉得对你有所帮助，还望在 GitHub 上点个 star。赠人玫瑰，手有余香。]]></content>
      <categories>
        <category>iOS文档</category>
      </categories>
      <tags>
        <tag>文档翻译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KVC官方文档-键值编码指南第二部分6]]></title>
    <url>%2F2018%2F09%2F18%2FKVC%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3-%E9%94%AE%E5%80%BC%E7%BC%96%E7%A0%81%E6%8C%87%E5%8D%97%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%866%2F</url>
    <content type="text"><![CDATA[Key-Value Coding Programming Guide 官方文档第二部分第6节2018.9.20 第一次修正 iOS-KVC官方文档第二部分第6节 Key-Value Coding Fundamatals–Accessor Search Patterns##访问器搜索方式 NSObject默认实现NSKeyValueCoding协议提供的基于键的访问器，使用一组明确定义的规则来调用对象的基础属性。这些协议方法使用键参数在其自己的对象实例中搜索访问器，实例变量以及遵循某些命名约定的相关方法。尽管您很少修改此默认搜索， 但了解它的工作方式会有所帮助，对于跟踪键值编码对象的行为，也可以使您自己的对象兼容。 注意本节中的描述使用&lt;key&gt;或&lt;Key&gt;作为键字符串的占位符，该键字符串在一个键值编码协议方法中作为参数出现，然后该方法将该键字符串用作间接方法调用或变量名称查找的一部分。映射的属性名称遵循占位符大小写的情况。例如，对于getter&lt;key&gt;和is&lt;KEY &gt;，名为 hidden 的属性映射为hidden和isHidden .。 基本的Getter搜索模式valueForKey：的默认实现，给定一个key参数作为输入，在接收valueForKey：调用的类实例中操作，执行以下过程。 1.搜索实例与名称，按照该顺序，搜索找到的名称为get&lt;Key&gt;、&lt;key&gt;、is&lt;Key&gt;或&lt;key&gt;的第一个访问器方法。如果找到，调用它并继续到步骤5。否则请继续执行下一步。 2.如果找不到简单取值方法, 则在实例中搜索其方法名形如 countOf&lt;Key&gt;和objectIn&lt;Key&gt;AtIndex: （相当于NSArray类中定义的基本方法）和&lt;key&gt;AtIndexes:（相当于NSArray类中的objectsAtIndexes:方法）的方法。 如果第一个方法和后边两个方法中的至少一个方法被实现了, 则创建一个能够响应所有NSArray方法并返回该方法的集合代理对象。否则, 继续执行步骤3。 代理对象随后将它接收的任何NSArray消息转换为countOf &lt;Key&gt;，objectIn &lt;Key&gt; AtIndex：和&lt;key&gt; AtIndexes：的消息，并将其发送给创建它的键值编码兼容对象。如果原始对象还实现了一个名为get &lt;Key&gt;：range：的可选方法，则代理对象也会在适当时使用该方法。实际上，与符合键值编码的对象一起工作的代理对象允许底层属性的行为就像它是一样NSArray，即使它不是。 3.如果没有找到简单的访问器方法或数组访问方法组，请查找名为countOf &lt;Key&gt;，enumeratorOf &lt;Key&gt;和memberOf &lt;Key&gt;：的方法的三个方法（对应于NSSet类定义的原始方法）。 如果找到所有三个方法，请创建一个响应所有NSSet方法并返回该方法的集合代理对象。 否则，请继续执行步骤4。 这个代理对象随后将它接收的任何NSSet消息转换为count Of &lt;Key&gt;，enumeration of &lt;Key&gt;和member Of &lt;Key&gt;：消息到创建它的对象。实际上，与符合键值编码的对象一起工作的代理对象允许底层属性的行为就像它是一样NSSet，即使它不是。 4.如果找不到简单访问器方法或集合访问方法组, 并且消息接收者的类方法accessInstanceVariablesDirectly返回YES, 则系统按以下顺序搜索名为:_&lt;key&gt;、 _is&lt;Key&gt;、 &lt;key&gt;或is&lt;Key&gt;的实例变量。如果找到, 则直接获取实例变量的值, 然后继续执行步骤5。否则, 继续跳转到步骤6。 5.如果获取到的属性值是对象指针,即获取的是对象, 则直接将对象返回。 如果获取到的属性值是NSNumber支持的数据类型, 则将其存储在NSNumber实例并返回。如果获取到的属性值不是 NSNumber 支持的类型, 则转换为NSValue对象, 然后返回。 6.如果上述所有方法都没有执行，则调用valueForUndefinedKey：。 默认情况下，这会引发异常，但NSObject的子类可以通过重载并根据特定key做一些特殊处理。 基本的Setter搜索方式setValue:forKey:的默认实现, 给定key和value参数作为输入, 在接收调用的对象内尝试将名为key的属性设置为value(或者, 对于非对象属性, 则为unwarp value, 详见Representing Non-Object Values), 使用以下过程: 1.按照顺序查找第一个名为set&lt;Key&gt;:或_set&lt;Key&gt;的方法。如果找到, 传入输入值 (或根据需要展开值) 调用它, 然后完成。 2.如果找不到简单访问器, 并且类方法accessInstanceVariablesDirectly返回YES, 则按以下顺序查找实例变量: _&lt;key&gt;、 _is&lt;Key&gt;、&lt;key&gt;、is&lt;Key&gt; 。如果找到, 则直接使用输入值 (或展开值) 设置变量并完成。 3.如果找不到以上方法或实例变量, 则调用setValue:forUndefinedKey:。默认情况下，这会引发异常，但NSObject的子类可以通过重载并根据特定key做一些特殊处理。 可变数组的搜索方式mutableArrayValueForKey：的默认实现，给定一个key参数作为输入，使用以下过程为接收访问者调用的对象内的一个名为key的属性返回一个可变代理数组： 1.查找一对方法, 名为insertObject：in &lt;Key&gt; AtIndex：和removeObjectFrom &lt;Key&gt; AtIndex：的方法（分别对应于NSMutableArray原始方法insertObject：atIndex：和removeObjectAtIndex：） ，或者名称类似于insert &lt;Key&gt;：atIndexes：和remove &lt;Key&gt; AtIndexes：（对应于NSMutableArrayinsertObjects：atIndexes：和removeObjectsAtIndexes：方法）。 如果对象至少实现一个插入方法和至少一个删除方法，则返回一个响应NSMutableArray消息的代理对象，方法是发送insertObject：in &lt;Key&gt; AtIndex：，removeObjectFrom &lt;Key&gt; AtIndex：，insert &lt;Key&gt;：atIndexes：，和remove &lt;Key&gt; AtIndexes：消息到mutableArrayValueForKey：的原始接收者。 当接收mutableArrayValueForKey：消息的对象也实现了一个可选的替换对象方法，其名称如replaceObjectIn &lt;Key&gt; AtIndex：withObject：或replace &lt;Key&gt; AtIndexes：with &lt;Key&gt;：，代理对象在适合最佳性能时会自动调用该可选方法。 2.如果对象没有可变数组方法，则查找名称与模式set &lt;Key&gt;：匹配的访问器方法。 在这种情况下，通过向mutableArrayValueForKey：的原始接收者发出set &lt;Key&gt;：消息，返回响应NSMutableArray消息的代理对象。 注意:此步骤中描述的机制比上一步的效率要低得多, 因为它可能涉及重复创建新的集合对象, 而不是修改现有的。因此, 在设计自己的键值编码兼容对象时, 通常应避免这种情况。 3.如果既没有找到可变数组方法，也没有找到访问器，并且接收者的类对accessInstanceVariablesDirectly响应’YES，则按照顺序搜索名为_ 或`的实例变量。 如果找到这样的实例变量，则返回一个代理对象，该对象将它接收的每个NSMutableArray消息转发给实例变量的值，该值通常是NSMutableArray的实例或其子类之一。 4.如果所有其他方法都失败了，只要收到NSMutableArray消息，就返回一个可变集合代理对象，该对象向mutableArrayValueForKey：消息的原始接收者发出setValue：forUndefinedKey：消息。 setValue:forUndefinedKey:的默认实现会抛出NSUndefinedKeyException异常, 但子类可能会重写此行为。 可变有序集的搜索方式mutableOrderedSetValueForKey的默认实现：将相同的简单访问器方法和有序集访问器方法识别为valueForKey :(请参阅 Default Search Pattern for the Basic Getter），并遵循相同的直接访问实例变量策略，但始终返回可变集合代理对象 valueForKey：返回的不可变集合。 此外，它还执行以下操作： 1.搜索名称类似于以下形式的方法: insertObject：in &lt;Key&gt; AtIndex：和removeObjectFrom &lt;Key&gt; AtIndex：（对应于NSMutableOrderedSet类定义的两个最原始方法），以及insert &lt;Key&gt;： atIndexes：和remove &lt;Key&gt; AtIndexes：（对应于insertObjects：atIndexes：和removeObjectsAtIndexes：）。 如果找到至少一个insert方法和至少一个remove方法，返回的代理对象每次接收到 NSMutableOrderedSet的消息后， 会通过以下组合方法给mutableOrderedSetValueForKey的原始对象 发送消息: mutableOrderedSetValueForKey: insertObject:in&lt;Key&gt;AtIndex:, removeObjectFrom &lt;Key&gt; AtIndex :, insert &lt;Key&gt;：atIndexes： remove&lt;Key&gt;AtIndexes: 代理对象还使用方法名为 replaceObjectIn &lt;Key&gt; AtIndex：withObject： 的方法，或replace&lt;Key&gt;AtIndexes:with&lt;Key&gt;: ,当这些方法存在于原始对象中时。 2.如果找不到可变的set方法，请搜索名为set &lt;Key&gt;：的访问器方法。 在这种情况下，返回的代理对象每次收到NSMutableOrderedSet消息时都会向mutableOrderedSetValueForKey：的原始接收者发送一个set &lt;Key&gt;：消息。 注意此步骤中描述的机制比前一步骤的效率低得多，因为它可能涉及重复创建新的集合对象而不是修改现有的集合对象。 因此，在设计自己的符合键值编码的对象时，通常应该避免使用它。 3.如果找不到可变集消息和访问器，并且接收者的accessInstanceVariablesDirectly类方法返回YES，则按顺序搜索名称如_ &lt;key&gt;或&lt;key&gt;的实例变量。 如果找到这样的实例变量，则返回的代理对象将它接收的任何NSMutableOrderedSet消息转发给实例变量的值，该值通常是NSMutableOrderedSet或其子类之一的实例。 4.如果所有其他方法都失败了，那么只要收到一个可变的set消息，返回的代理对象就会向mutableOrderedSetValueForKey：的原始接收者发送一个setValue：forUndefinedKey：消息。 setValue：forUndefinedKey：的默认实现引发了一个NSUndefinedKeyException，但是对象可能会覆盖此行为。 可变集的搜索方式mutableSetValueForKey：的默认实现，给定一个key参数作为输入，使用以下过程为接收访问者调用的对象内的一个名为key的数组属性返回一个可变代理集： 1.搜索方法名称为add&lt;Key&gt;Object:和 remove &lt;Key&gt; Object 的方法：（分别对应于NSMutableSet原始方法addObject:和removeObject:）以及add&lt;Key&gt;：和remove&lt;Key&gt;:（对应于NSMutableSet 方法unionSet:和minusSet: ）。如果找到至少一个添加方法和至少一个删除方法，则返回一个NSMutableSet代理对象，该代理对象发送add &lt;Key&gt; Object：，remove &lt;Key&gt; Object：，add &lt;Key&gt;：的某种组合， 和remove &lt;Key&gt;：对于它收到的每个NSMutableSet消息的mutableSetValueForKey：的原始接收者的消息。 代理对象还使用名称为“cross：”或“set：”的方法来提高性能（如果可用的话）。 2.如果mutableSetValueForKey：调用的接收者是托管对象，则搜索模式不会像非托管对象那样继续。 有关更多信息，请参阅“Core Data Programming Guide”中的托管对象访问器方法。 3.如果找不到可变集合方法，并且对象不是托管对象，则搜索名为set &lt;Key&gt;：的访问器方法。 如果找到这样的方法，则返回的代理对象将set &lt;Key&gt;：消息发送给它接收的每个NSMutableSet消息的mutableSetValueForKey：的原始接收者。 注意此步骤中描述的机制的效率远低于第一步的机制，因为它可能涉及重复创建新的集合对象而不是修改现有的集合对象。 因此，在设计自己的符合键值编码的对象时，通常应该避免使用它。 4.如果找不到可变的set方法和accessor方法，并且accessInstanceVariablesDirectly类方法返回YES，则按照顺序搜索名为_ &lt;key&gt;或&lt;key&gt;的实例变量。 如果找到这样的实例变量，则代理对象将它接收的每个NSMutableSet消息转发给实例变量的值，该值通常是NSMutableSet的实例或其子类之一。 5.如果所有其他方法都失败了，返回的代理对象通过向mutableSetValueForKey：&#39;的原始接收者发送setValue：forUndefinedKey：消息来响应它收到的任何NSMutableSet`消息。 由于笔者水平有限，文中如果有错误的地方，或者有更好的方法，还望大神指出。附上本文的所有 demo 下载链接，【GitHub】。如果你看完后觉得对你有所帮助，还望在 GitHub 上点个 star。赠人玫瑰，手有余香。]]></content>
      <categories>
        <category>iOS文档</category>
      </categories>
      <tags>
        <tag>文档翻译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KVC官方文档-键值编码指南第二部分5]]></title>
    <url>%2F2018%2F09%2F18%2FKVC%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3-%E9%94%AE%E5%80%BC%E7%BC%96%E7%A0%81%E6%8C%87%E5%8D%97%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%865%2F</url>
    <content type="text"><![CDATA[Key-Value Coding Programming Guide 官方文档第二部分第5节2018.9.20 第一次修正 iOS-KVC官方文档第二部分第5节 Key-Value Coding Fundamatals–Validating Properties验证属性键值编码协议定义了支持属性验证的方法。就像使用基于键的访问器来读取和写入符合键值编码的对象的属性一样，您也可以按键（或键路径）验证属性。当您调用validateValue:forKey:error:(或validateValue:forKeyPath:error:) 方法时， 协议的默认实现将搜索接收验证消息的对象 (或在键路径的末尾的对象)， 以查找名称与模式匹配的方法validate&lt;Key&gt;:error:。如果对象没有此类方法， 则默认情况下验证成功, 默认实现返回YES`。当存在属性特定的验证方法时， 默认实现将返回调用该方法的结果。 注意您通常仅在Objective-C中使用此处描述的验证。在 Swift 中, 通过依赖 optionals 和强类型检查的编译器支持, 可以更便捷地处理属性验证, 同时使用内置的 willSet 和 didSet 属性观察器来测试任何运行时 API 协定, 详见The Swift Programming Language (Swift 4.2)中Property Observers章节对willSet didSet的描述。 由于属性特定的验证方法通过引用的方式接收值和错误参数, 因此验证有三种可能的结果: 验证方法判断值对象有效并返回YES而不改变值或错误。 验证方法判断值对象无效, 但选择不更改它。在这种情况下, 该方法返回NO并将错误引用 (如果调用方提供) 设置到NSError指示失败原因的对象。 验证方法判断值对象无效, 但创建一个新的、有效的对象作为替换。在这种情况下, 该方法返回YES同时保持错误对象不变。返回之前, 该方法修改值引用以指向新值对象。当它进行修改时, 该方法总是创建一个新对象, 而不是修改旧值, 即使 value 对象是可变的。 清单 6-1显示了如何调用name字符串的验证的示例。 Person* person = [[Person alloc] init]; NSError* error; NSString* name = @"John"; if (![person validateValue:&name forKey:@"name" error:&error]) { NSLog(@"%@",error); } 自动验证通常, 键值编码协议及其默认实现都不定义任何自动执行验证的机制。相反, 您可以在您的应用程序中使用适合的验证方法。 某些其他Cocoa技术在某些情况下会自动进行验证。例如, Core Data会在保存托管对象上下文时自动执行验证 (详见Core Data Programming Guide)。此外, 在 macOS 中, Cocoa Bindings 允许您指定验证是否自动进行 (请阅读Cocoa Bindings Programming Topics了解有关Cocoa Bindings的更多信息。)。 由于笔者水平有限，文中如果有错误的地方，或者有更好的方法，还望大神指出。附上本文的所有 demo 下载链接，【GitHub】。如果你看完后觉得对你有所帮助，还望在 GitHub 上点个 star。赠人玫瑰，手有余香。]]></content>
      <categories>
        <category>iOS文档</category>
      </categories>
      <tags>
        <tag>文档翻译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KVC官方文档-键值编码指南第二部分4]]></title>
    <url>%2F2018%2F09%2F18%2FKVC%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3-%E9%94%AE%E5%80%BC%E7%BC%96%E7%A0%81%E6%8C%87%E5%8D%97%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%864%2F</url>
    <content type="text"><![CDATA[Key-Value Coding Programming Guide 官方文档第二部分第4节2018.9.20 第一次修正 iOS-KVC官方文档第二部分第4节 Key-Value Coding Fundamatals–Representing Non-Object Values表示非对象值通过NSObject使用对象和非对象属性提供的键值编码协议方法的默认实现。 默认实现自动在对象参数或返回值以及非对象属性之间进行转换。 这允许即使存储的属性是标量或结构体，基于key的getter和setter的命名也保持一致。 注意因为Swift中的所有属性都是对象，所以本节仅适用于Objective-C属性。 当你调用协议的其中一个getter时，valueForKey：，默认实现根据Accessor Search Patterns中描述的规则 确定为指定键提供值的特定访问器方法或实例变量。 如果返回值不是对象，则getter使用此值初始化NSNumber对象（对于标量）或NSValue对象（对于结构体）并返回该值。 同样，默认情况下，像setValue：forKey:这样的setter在给定特定键的情况下确定属性的访问器或实例变量所需的数据类型。 如果数据类型不是对象，则setter首先向传入值对象发送适当的&lt;type&gt; Value消息以提取基础数据，并存储该数据。 注意当您使用非对象属性的nil值调用其中一个KVC协议setter时，setter没有明显的一般操作过程。 因此，它向接收setter调用的对象发送setNilValueForKey：消息。 此方法的默认实现引发NSInvalidArgumentException异常，但子类可能会覆盖此行为，如Handling Non-Object Values中所述，例如设置标记值或提供有意义的默认值。 包装和解包标量类型Table 5-1 列出默认KVC实现使用NSNumber实例包装的标量类型。 对于每种数据类型，该表显示用于初始化NSNumber基础属性值以提供getter返回值的创建方法。 然后显示用于在设置操作期间从setter输入参数中提取值的访问器方法。 Table 5-1 标量类型包含在NSNumber对象中 Data type Creation method Accessor method BOOL numberWithBool: boolValue (in iOS) charValue (in macOS)* char numberWithChar: charValue double numberWithDouble: doubleValue float numberWithFloat: floatValue int numberWithInt: intValue long numberWithLong: longValue long long numberWithLongLong: longLongValue short numberWithShort: shortValue unsigned char numberWithUnsignedChar: unsignedChar unsigned int numberWithUnsignedInt: unsignedInt unsigned long numberWithUnsignedLong: unsignedLong unsigned long long numberWithUnsignedLongLong: unsignedLongLong unsigned short numberWithUnsignedShort: unsignedShort 注意*在macOS中，由于历史原因，BOOL的类型定义为signed char，而KVC不区分这些。 因此，当key为BOOL时，不应将字符串值（例如@“true”或@“YES”）传递给setValue：forKey：。 KVC将尝试调用charValue（因为BOOL本身就是一个char），但是NSString没有实现这个方法，这会导致运行时错误。 相反，当key为BOOL时，只传递一个NSNumber对象，如@(1) 或 @(YES)，作为setValue：forKey: 的值参数。 此限制不适用于iOS，其中BOOL的类型定义为本机布尔类型bool，KVC调用boolValue，它适用于NSNumber对象或格式正确的NSString对象。 包装和解包结构体Table 5-2 下面列出了可以包装成NSPoint，NSRange，NSRect和NSSize的常用结构体的转化方法和取值方法 Table 5-2 包装成NSValue的常用结构类型 Data type Creation method Accessor method NSPoint valueWithPoint: pointValue NSRange valueWithRange: rangeValue NSRect valueWithRect: (macOS only). rectValue NSSize valueWithSize: sizeValue 不仅NSPoint，NSRange，NSRect和NSSize的可以自动包装和解包。 结构体类型（即Objective-C类型中字符串以{开头编码的类型）也可以包成NSValue对象中。 例如，参考5-1表格中声明的结构体和类接口。 Listing 5-1 使用自定义结构体的类 typedef struct { float x, y, z; } ThreeFloats; @interface MyClass @property (nonatomic) ThreeFloats threeFloats; @end 使用名为myClass的类的实例，可以使用KVC获取threeFloats值 NSValue* result = [myClass valueForKey:@"threeFloats"]; valueForKey：的默认实现调用threeFloats 的getter方法，然后返回包含在NSValue对象中的结果。 同样，您可以使用KVC设置threeFloats值： ThreeFloats floats = {1., 2., 3.}; NSValue* value = [NSValue valueWithBytes:&floats objCType:@encode(ThreeFloats)]; [myClass setValue:value forKey:@"threeFloats"]; 默认实现使用getValue:方法解包值，然后使用setThreeFloats:生成的结构体进行调用。 由于笔者水平有限，文中如果有错误的地方，或者有更好的方法，还望大神指出。附上本文的所有 demo 下载链接，【GitHub】。如果你看完后觉得对你有所帮助，还望在 GitHub 上点个 star。赠人玫瑰，手有余香。]]></content>
      <categories>
        <category>iOS文档</category>
      </categories>
      <tags>
        <tag>文档翻译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KVC官方文档-键值编码指南第二部分3]]></title>
    <url>%2F2018%2F09%2F18%2FKVC%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3-%E9%94%AE%E5%80%BC%E7%BC%96%E7%A0%81%E6%8C%87%E5%8D%97%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%863%2F</url>
    <content type="text"><![CDATA[Key-Value Coding Programming Guide 官方文档第二部分第3节2018.9.20 第一次修正 iOS-KVC官方文档第二部分第3节 Key-Value Coding Fundamatals–Using Collection Operators使用集合运算符当你向符合键值编码的对象发送valueForKeyPath:消息时, 可以在键路径中嵌入集合运算符。集合运算符是一个小的关键字列表，前面带一个at符号（@）, 它指定了getter应该执行的操作，以便在返回之前以某种方式操作数据。valueForKeyPath:由NSObject默认实现。 当键路径包含集合运算符时, 运算符前面的键路径的任何部分 (称为左键路径) 指向相对于消息接收者操作的集合。如果将消息直接发送到集合对象 (例如NSArray实例), 则可以省略左键路径。操作符之后的键路径部分（称为右键路径）指定操作符应处理的集合中的属性。除了@count需要正确的键路径之外，所有集合运算符。图4-1说明了操作符键路径格式。 图 4-1运算符键路径格式 集合运算符展示了三种基本行为类型: 聚合运算符以某种方式合并集合的对象，并返回通常与右键路径中指定的属性的数据类型匹配的单个对象。该@count运算符是一个例外，它没有右键路径并始终将返回一个NSNumber实例。 数组运算符返回一个NSArray实例，该实例包含命名集合中保存的对象的某个子集。 嵌套操作符处理包含其他集合的集合，并根据操作符返回一个NSArray或NSSet实例，它以某种方式组合嵌套集合的对象。 示例数据下面描述包括演示如何调用每个运算符的代码段，以及执行此操作的结果。这依赖于BankAccount类 (在[列表 2-1]中显示), 它是一个保存Transaction对象的数组。其中每一个都代表一个简单的checkbook条目, 如清单 4-1中所声明的那样。 清单 4-1Transaction对象的接口声明 @interface Transaction : NSObject @property (nonatomic) NSString* payee; // To whom @property (nonatomic) NSNumber* amount; // How much @property (nonatomic) NSDate* date; // When @end 为了便于讨论, 假定BankAccount实例具有一个使用表4-1中显示的数据填充的交易数组, 并且您可以从BankAccount对象内部进行调用。 表 4-1Transactions对象的示例数据 payee amount date Green Power $120.00 Dec 1, 2015 Green Power $150.00 Jan 1, 2016 Green Power $170.00 Feb 1, 2016 Car Loan $250.00 Jan 15, 2016 Car Loan $250.00 Feb 15, 2016 Car Loan $250.00 Mar 15, 2016 General Cable $120.00 Dec 1, 2015 General Cable $155.00 Jan 1, 2016 General Cable $120.00 Feb 1, 2016 Mortgage $1,250.00 Jan 15, 2016 Mortgage $1,250.00 Feb 15, 2016 Mortgage $1,250.00 Mar 15, 2016 Animal Hospital $600.00 Jul 15, 2016 聚合运算符聚合运算符处理array或set属性, 从而生成反映集合某些方面的单个值。 @avg当指定@avg运算符时, valueForKeyPath:读取集合中每个元素的右键路径指定的属性, 将其转换为double (nil值用0替代), 并计算这些值的算术平均值。然后它返回存储在NSNumber实例中的结果。 获取表 4-1中示例数据之间的平均交易记录金额: NSNumber *transactionAverage = [self.transactions valueForKeyPath:@"@avg.amount"]; transactionAverage的格式化的结果为 $ 456.54。 @count指定@count运算符时, valueForKeyPath:返回一个包含集合中的对象个数的NSNumber实例。右键路径 (如果存在) 将被忽略。 在transactions中获取Transaction对象的数目: NSNumber *numberOfTransactions = [self.transactions valueForKeyPath:@"@count"]; numberOfTransactions的值为13。 @max指定@max运算符时, valueForKeyPath:在由右键路径命名的集合项之间进行搜索, 并返回最大值。搜索使用compare:方法进行比较, 该方法由许多Foundation类（例如NSNumber类）定义。因此, 由右键路径指示的属性必须包含一个对此消息有意义响应的对象。搜索忽略值为nil的集合项。 在表 4-1中列出的交易记录中, 获取日期值 (即最新交易记录的日期) 的最大数量: NSDate *latestDate = [self.transactions valueForKeyPath:@"@max.date"]; latestDate的值为 Jul 15, 2016. @min指定@min运算符时, valueForKeyPath:在由右键路径命名的集合项之间进行搜索, 并返回最小值。搜索使用compare:方法进行比较, 许多基础类 (如NSNumber类) 中都有定义。因此, 由右键路径指示的属性必须持有对此消息有意义响应的对象。搜索忽略值为nil的集合项。 在表 4-1中列出的事务中, 获取日期值 (即最早的事务的日期) 的最短时间。 NSDate *earliestDate = [self.transactions valueForKeyPath:@"@min.date"]; earliestDate的值为 Dec 1, 2015. @sum指定@sum运算符时, valueForKeyPath:读取集合中每个元素的右键路径指定的属性, 将其转换为double (nil值替换为 0), 并计算总和。然后返回存储在NSNumber实例中的结果。 获取表 4-1中示例数据之间的交易记录金额的总和: NSNumber *amountSum = [self.transactions valueForKeyPath:@"@sum.amount"]; amountSum的结果为 $ 5935.00。 数组运算符数组运算符使valueForKeyPath:返回与右键路径指示的特定对象集相对应的对象数组。 重要在使用数组运算符时, 如果有任何叶(leaf)对象为nil, 则valueForKeyPath:方法将引发异常。 @distinctUnionOfObjects指定@distinctUnionOfObjects运算符时, valueForKeyPath:将创建并返回一个数组, 该数组包含与右键路径指定的属性对应的集合的不同对象。 获取transactions中的交易记录的payee属性值的集合, 并省略重复值: NSArray *distinctPayees = [self.transactions valueForKeyPath:@"@distinctUnionOfObjects.payee"]; 生成的distinctPayees数组包含以下每一个字符串实例：Car Loan, General Cable, Animal Hospital, Green Power, Mortgage。 注意@unionOfObjects运算符提供类似的行为, 但不删除重复的对象。 @unionOfObjects指定@unionOfObjects运算符时, valueForKeyPath:将创建并返回一个数组, 该数组包含与由右键路径指定的属性对应的集合的所有对象。与@distinctUnionOfObjects不同, 不会删除重复对象。 获取transactions中的交易记录的payee属性值的集合: NSArray *payees = [self.transactions valueForKeyPath:@"@unionOfObjects.payee"]; 生成的payees数组包含以下字符串：Green Power, Green Power, Green Power, Car Loan, Car Loan, Car Loan, General Cable, General Cable, General Cable, Mortgage, Mortgage, Mortgage, Animal Hospital.记录了重复值。 注意@distinctUnionOfArrays运算符类似, 但删除重复的对象。 嵌套运算符嵌套运算符对嵌套集合进行操作, 集合本身的每个条目都包含一个集合。 重要如果在使用嵌套运算符时, 有任何叶(leaf)对象为nil, 则valueForKeyPath:方法将引发异常。 对于下面的说明, 请看第二个称为moreTransactions的数据数组, 其中填充了表 4-2中的数据, 并与原来的transactions数组一起插入嵌套数组: NSArray* moreTransactions = @[]; NSArray* arrayOfArrays = @[self.transactions, moreTransactions]; 表 4-2 moreTransactions数组中假设的Transaction数据 payee amount date General Cable - Cottage $120.00 Dec 18, 2015 General Cable - Cottage $155.00 Jan 9, 2016 General Cable - Cottage $120.00 Dec 1, 2016 Second Mortgage $1,250.00 Nov 15, 2016 Second Mortgage $1,250.00 Sep 20, 2016 Second Mortgage $1,250.00 Feb 12, 2016 Hobby Sho $600.00 Jun 14, 2016 @distinctUnionOfArrays指定@distinctUnionOfArrays运算符时, valueForKeyPath:创建并返回一个数组, 其中包含与右键路径指定的属性相对应的所有集合的组合的不同对象。 在arrayOfArrays中的所有数组中获取payee属性的不同值: NSArray *collectedDistinctPayees = [arrayOfArrays valueForKeyPath:@&quot;@distinctUnionOfArrays.payee&quot;]; 生成的collectedDistinctPayees数组包含以下值: Hobby Shop, Mortgage, Animal Hospital, Second Mortgage, Car Loan, General Cable - Cottage, General Cable, Green Power。 注意@unionOfArrays运算符类似, 但不移除重复对象。 @unionOfArrays指定@unionOfArrays运算符时, valueForKeyPath:创建并返回一个数组, 其中包含与由右键路径指定的属性相对应的所有集合的组合的所有对象, 而不删除重复项。 在arrayOfArrays中的所有数组中获取payee属性的值: NSArray *collectedPayees = [arrayOfArrays valueForKeyPath:@&quot;@unionOfArrays.payee&quot;]; 生成的collectedPayees数组包含以下值:Green Power, Green Power, Green Power, Car Loan, Car Loan, Car Loan, General Cable, General Cable, General Cable, Mortgage, Mortgage, Mortgage, Animal Hospital, General Cable。 注意@distinctUnionOfArrays运算符类似, 但移除重复对象。 @distinctUnionOfSets当指定@distinctUnionOfSets运算符时, valueForKeyPath:创建并返回一个NSSet对象, 其中包含与由右键路径所指定的属性相对应的所有集合组合的不同对象。 此运算符的行为与@distinctUnionOfArrays类似, 只是它需要一个包含NSSet实例的NSSet实例对象, 其中, 而不是包含NSArray实例的NSArray实例对象。此外, 它还返回一个NSSet实例。假设示例数据已存储在集合而不是数组中, 则示例调用和结果与@distinctUnionOfArrays中显示的相同。 由于笔者水平有限，文中如果有错误的地方，或者有更好的方法，还望大神指出。附上本文的所有 demo 下载链接，【GitHub】。如果你看完后觉得对你有所帮助，还望在 GitHub 上点个 star。赠人玫瑰，手有余香。]]></content>
      <categories>
        <category>iOS文档</category>
      </categories>
      <tags>
        <tag>文档翻译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KVC官方文档-键值编码指南第二部分2]]></title>
    <url>%2F2018%2F09%2F18%2FKVC%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3-%E9%94%AE%E5%80%BC%E7%BC%96%E7%A0%81%E6%8C%87%E5%8D%97%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%862%2F</url>
    <content type="text"><![CDATA[Key-Value Coding Programming Guide 官方文档第二部分第2节2018.9.20 第一次修正 iOS-KVC官方文档第二部分第2节 Key-Value Coding Fundamatals–Accessing Collection Properties访问集合属性符合键值编码的对象以与公开其他属性相同的方式公开其多对多属性。您可以像使用任何其他对象valueForKey:和setValue:forKey: (或它们的键路径等同方法) 一样获取或设置集合对象。但是, 当您要操作这些集合的内容时, 使用协议定义的可变代理方法通常是最有效的。 该协议为集合对象访问定义了三种不同的代理方法, 每个都具有一个键和一个键路径变体方法: mutableArrayValueForKey: 和 mutableArrayValueForKeyPath: 这两个方法返回一个类似于NSMutableArray对象的代理对象。 mutableSetValueForKey: 和 mutableSetValueForKeyPath: 这两个方法返回一个类似于NSMutableSet对象的代理对象。 mutableOrderedSetValueForKey: 和 mutableOrderedSetValueForKeyPath: 这两个方法返回一个类似于`NSMutableOrderedSet`对象的代理对象。 当您对代理对象进行操作，向对象添加对象，从中删除对象或替换对象时, 协议的默认实现将相应地修改基础属性。这比使用valueForKey:得到一个不可变集合对象更有效，创建一个修改了内容的可变集合对象，然后使用setValue:forKey:消息将其存储回对象。在许多情况下, 它也比直接使用可变属性更有效。这些方法提供了对集合对象中保存的对象保持键值观察遵从性的额外好处 (有关详细信息，请参阅Key-Value Observing Programming Guide。 由于笔者水平有限，文中如果有错误的地方，或者有更好的方法，还望大神指出。附上本文的所有 demo 下载链接，【GitHub】。如果你看完后觉得对你有所帮助，还望在 GitHub 上点个 star。赠人玫瑰，手有余香。]]></content>
      <categories>
        <category>iOS文档</category>
      </categories>
      <tags>
        <tag>文档翻译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KVC官方文档-键值编码指南第二部分1]]></title>
    <url>%2F2018%2F09%2F18%2FKVC%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3-%E9%94%AE%E5%80%BC%E7%BC%96%E7%A0%81%E6%8C%87%E5%8D%97%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%861%2F</url>
    <content type="text"><![CDATA[Key-Value Coding Programming Guide 官方文档第二部分第1节2018.9.20 第一次修正 iOS-KVC官方文档第二部分第1节 Key-Value Coding Fundamatals–Accessing Object Properties 键值编码基础– 访问对象属性 访问对象属性对象通常在其接口声明中指定属性, 这些属性属于以下几种类别之一: 属性. 指简单值, 例如标量(scalars)、字符串或布尔值。值对象(如NSNumber)和其他不可变类型(如NSColor) 也被视为属性。 一对一关系. 指具有自己属性的可变对象。对象的属性可以在对象本身不变的情况下更改。例如，银行帐户对象(bank account object)可能具有owner属性，该属性是Person对象的实例，该Person对象具有address属性。owner的address可能会更改，而不会更改银行帐户持有的owner。银行帐户的owner没有变更。只有Person的address 发生改变。 一对多关系. 指集合对象。你通常使用NSArray或NSSet保存此类集合的实例，但也可以使用自定义集合类。 清单 2-1中声明的BankAccount对象演示了每种类型的属性。 清单 2-1BankAccount对象的属性 @interface BankAccount : NSObject @property (nonatomic) NSNumber* currentBalance; // An attribute @property (nonatomic) Person* owner; // A to-one relation @property (nonatomic) NSArray* transactions; // A to-many relation @end 为了保持封装，对象通常为其接口上的属性提供访问器方法。对象的作者可以显式地编写这些方法，也可以依赖编译器自动合成它们。无论哪种方式，使用这些访问器之一的代码的作者必须在编译之前将属性名称写入代码中。访问器方法的名称成为使用它的代码的静态部分。例如，给定清单2-1中声明的BankAccount对象，编译器会合成一个可以为myAccount实例调用的setter ： [myAccount setCurrentBalance:@(100.0)]; 这是直接的，但缺乏灵活性。另一方面，符合键值编码的对象提供了使用字符串标识符访问对象属性的更通用机制。 使用Keys 和 Key Paths标识对象的属性键(key)是标识特定属性的字符串。通常, 按照惯例, 表示属性的键(key)是代码中显示的属性名。键(key)必须使用 ASCII 编码, 不能包含空格, 并且通常以小写字母开头 (尽管有例外, 如在许多类中的URL属性)。 由于清单 2-1中的BankAccount类是符合键值编码的, 所以它能识别键(即它的属性的名称)owner、currentBalance和transactions 。您也可以通过其键来设置值, 而不是调用setCurrentBalance:方法: [myAccount setValue:@(100.0) forKey:@"currentBalance"]; 实际上, 您可以使用不同的键参数通过相同方法来设置myAccount对象的所有属性。因为参数是字符串类型, 所以它可以在运行时操作变量。 键路径Key path是一个用点操作符.来分隔键的字符串, 用于指定要遍历的对象属性序列。序列中第一个键的属性是相对于接收者的, 每个后续键相对于上一个属性的值进行计算。键路径(Key path)对于使用单个方法深入调用对象的层次结构很有用。 例如, 应用于银行帐户实例的键路径owner.address.street是指存储在银行帐户所有者地址中的街道字符串的值, 假设Person和Address类也符合的键值编码。 注意在 Swift 中, 您可以使用#keyPath表达式, 而不是使用字符串来指示键或键路径。这提供了编译时检查的优点, 详见Using Swift with Cocoa and Objective-C (Swift 4.2) 中的Keys and Key Paths章节。 使用键获取属性值对象在遵循NSKeyValueCoding协议时符合键值编码。继承自的对象（NSObject提供协议的基本方法的默认实现）会自动采用此协议的某些默认行为。这样的对象至少实现了以下基于键的基本getter： valueForKey: - 返回由key参数指定的属性的值。如果根据访问者搜索模式中描述的规则无法找到key命名的属性，则该对象会向自身发送valueForUndefinedKey:消息。valueForUndefinedKey:引发的默认实现抛出NSUndefinedKeyException异常，但是子类可以覆盖此方法并更优雅地处理这种情况。 valueForKeyPath: - 返回相对于接收器的指定键路径的值。keyPath序列中的任何对象都不符合特定key的键值编码 - 即，默认实现valueForKey:无法找到访问器方法 - -那么就会接收valueForUndefinedKey:消息。 dictionaryWithValuesForKeys: - 返回相对于接收器的一组键所对应的值。该方法为数组中的每个键调用valueForKey:。返回的NSDictionary包含数组中所有键的值。 注意集合对象 (如NSArray、 NSSet和NSDictionary) 不能包含nil的值。而是使用NSNull对象表示nil值。NSNull提供一个表示对象属性的nil值的单个实例。dictionaryWithValuesForKeys:的默认实现和相关的setValuesForKeysWithDictionary:会在NSNull (在字典参数中) 和nil(在存储的属性中)之间进行自动转换 。 当您使用KeyPath来寻址属性时, 如果键路径中的最后一个键是一对多关系 (即引用集合), 则在多对键的右侧,返回的值是一个包含键的所有值的集合。例如, 请求键路径 “transactions.payee“ 的值返回包含所有transaction对象中payee对象的数组。这也适用于KeyPath中的多个数组。KeyPath accounts.transactions.payee返回一个数组，其中包含所有帐户中所有交易的所有收款人对象。 使用键设置属性值与 getter一样, 符合键值编码的对象也提供了一小组通用setter，其默认行为基于以下NSKeyValueCoding协议的实现NSObject: setValue:forKey: - 将指定键设置为给定值。setValue:forKey:的默认实现会自动对表示标量和结构体的NSNumber和NSValue对象执行解包操作，并将它们设置到相应的属性中。有关包装(warp)和解包(unwarp)语义的详细信息，请参阅Representing Non-Object Values。 如果接收setter调用的对象中没有对应指定键的属性，该对象将给自己发送一个[setValue:forUndefinedKey:]消息。setValue:forUndefinedKey:的默认实现将抛出NSUndefinedKeyException异常。但是, 子类可以重写此方法以自定义方式处理请求。 setValue:forKeyPath: 在相对于接收者的指定键路径上设置给定值。键路径序列中指定键所对应的对象如果不是键值编码兼容的，将会收到setValue:forUndefinedKey:消息。 setValuesForKeysWithDictionary: 将指定字典中的值设置到接收者的属性中, 使用字典键标识属性。默认实现调用每个键值对的setValue:forKey: , 根据需要用nil替换NSNull对象。 在默认实现中, 当您尝试将非对象属性设置为nil值时, 符合键值编码兼容对象将自己发送一个setNilValueForKey:消息。setNilValueForKey:的默认实现将抛出[NSInvalidArgumentException]异常, 但对象可以重写此方法以替换默认值或标记值, 详见处理非对象值。 使用键简化对象访问想知道基于key的 getter 和 setter 如何简化代码, 请查看下面的示例。在 macOS 中, NSTableView和NSOutlineView对象的标识符字符串与每个它们的列相关联。如果表的模型对象不是符合键值编码的, 则表的数据源方法将强制检查每个列标识符, 依次查找要返回的正确属性, 如清单 2-2所示。此外, 在将来, 当您向模型中添加另一个属性时, 在本例中为Person 对象, 还必须重新访问数据源方法, 添加另一个条件来测试新属性并返回相关值. 清单 2-2 不基于键值编码的数据源方法的实现 - (id)tableView:(NSTableView *)tableview objectValueForTableColumn:(id)column row:(NSInteger)row { id result = nil; Person *person = [self.people objectAtIndex:row]; if ([[column identifier] isEqualToString:@"name"]) { result = [person name]; } else if ([[column identifier] isEqualToString:@"age"]) { result = @([person age]); // Wrap age, a scalar, as an NSNumber } else if ([[column identifier] isEqualToString:@"favoriteColor"]) { result = [person favoriteColor]; } // And so on... return result; } 另一方面,清单 2-3展示了相同数据源的方法的一个更紧凑的实现, 该数据源方法使用的是键值编码兼容的Person对象。仅使用valueForKey: getter, 数据源方法将使用列标识符作为键返回适当的值。除了更短的时间外, 它还更通用, 因为在以后添加新列时, 只要列标识符始终与模型对象的属性名称匹配, 它就会继续保持不变。 清单 2-3基于键值编码的数据源方法的实现 - (id)tableView:(NSTableView *)tableview objectValueForTableColumn:(id)column row:(NSInteger)row { return [[self.people objectAtIndex:row] valueForKey:[column identifier]]; } 由于笔者水平有限，文中如果有错误的地方，或者有更好的方法，还望大神指出。附上本文的所有 demo 下载链接，【GitHub】。如果你看完后觉得对你有所帮助，还望在 GitHub 上点个 star。赠人玫瑰，手有余香。]]></content>
      <categories>
        <category>iOS文档</category>
      </categories>
      <tags>
        <tag>文档翻译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KVC官方文档-键值编码指南第一部分]]></title>
    <url>%2F2018%2F09%2F18%2FKVC%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3-%E9%94%AE%E5%80%BC%E7%BC%96%E7%A0%81%E6%8C%87%E5%8D%97%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%2F</url>
    <content type="text"><![CDATA[Key-Value Coding Programming Guide 官方文档第一部分2018.9.20 第一次修正 iOS-KVC官方文档第一部分 Key-Value Coding Programming Guide - Getting Started 键值编码编程指南-入门 该文档苹果官方已不再更新。有关Apple SDK的最新信息，请访问文档网站。 关于键值编码补充: key-value coding 翻译为 键值编码 , 简称KVC. 键值编码是一种由NSKeyValueCoding非正式协议启用的机制，对象采用该机制提供对其属性的间接访问。当对象符合键值编码时，其属性可通过字符串参数通过简洁，统一的消息传递接口寻址。这种间接访问机制补充了实例变量及其相关访问器方法提供的直接访问。 您通常使用访问器方法来访问对象的属性。get访问器（或getter）返回属性的值。set访问器（或setter）设置属性的值。在Objective-C中，您还可以直接访问属性的基础实例变量。以任何这些方式访问对象属性都很简单，但需要调用特定于属性的方法或变量名称。随着属性列表的增长或变化，访问这些属性的代码也必须如此。相反，符合键值编码的对象提供了一个简单的消息传递接口，该接口在其所有属性中都是一致的。 键值编码是一个基本概念，是许多其他Cocoa技术的基础，例如键值观察(key-value observing)，Cocoa绑定(Cocoa bindings)，Core Data和AppleScript-ability。在某些情况下，键值编码还有助于简化代码。 使用键值编码兼容对象对象通常在NSObject（直接或间接）继承时采用键值编码，它们都采用NSKeyValueCoding协议并为基本方法提供默认实现。这样的对象通过紧凑的消息传递接口使其他对象能够执行以下操作： 访问对象属性。该协议指定方法，例如getter valueForKey: 和setter setValue:forKey:，用于通过名称或键访问对象属性，参数为字符串。这些和相关方法的默认实现使用键来定位基础数据并与其交互，如Accessing Object Properties。 操纵集合属性。访问方法的默认实现和对象的集合属性（如NSArray对象）一样，也和任何其他属性一样。此外，如果对象定义属性的集合访问器方法，则它允许对集合内容进行键值访问。这通常比直接访问更有效，并允许您通过标准化界面使用自定义集合对象，如Accessing Collection Properties。 在集合对象上调用集合运算符。在符合键值编码的对象中访问集合属性时，可以将集合运算符插入到键字符串中，如Using Collection Operators。集合运算符根据默认的NSKeyValueCodinggetter实现对集合执行操作，然后返回集合的新的过滤版本或表示集合的某些特征的单个值。 访问非对象属性。协议默认实现检测非对象属性，包括标量和结构体，并自动将它们包装和解包为协议接口上使用的对象，如Representing Non-Object Values。此外，该协议声明了一种方法，该方法允许兼容对象nil通过键值编码接口在非对象属性上设置值时为该情况提供合适的作用。 key path访问属性。如果具有符合键值编码的对象层次结构，则可以使用基于key path的方法调用，使用单个调用在层次结构内深入查看，获取或设置值。 采用对象的键值编码为了使您自己的对象键值编码符合要求，您需要确保它们采用NSKeyValueCoding非正式协议并实现相应的方法，例如作为valueForKey: 通用getter和setValue:forKey: 通用setter。幸运的是，如上所述，NSObject 采用此协议并为这些和其他基本方法提供默认实现。因此，如果您从NSObject（或其许多子类中的任何一个）派生对象，那么大部分工作已经完成。 为了使默认方法完成其工作，您需要确保对象的访问器方法和实例变量遵循某些明确定义的模式。这允许默认实现找到对象的属性以响应键值编码消息。然后，您可以选择通过提供验证方法和处理某些特殊情况来扩展和自定义键值编码。 使用Swift进行键值编码NSObject从其子类或其子类之一 继承的Swift对象默认情况下是符合其属性的键值编码。而在Objective-C中，属性的访问器和实例变量必须遵循某些模式，Swift中的标准属性声明会自动保证这一点。另一方面，协议的许多功能要么不相关，要么使用Objective-C中不存在的本机Swift构造或技术来更好地处理。例如，因为所有Swift属性都是对象，所以您永远不会使用默认实现对非对象属性的特殊处理。 因此，虽然键值编码协议方法直接转换为Swift，但本指南主要关注Objective-C，您需要做更多工作以确保合规性，以及键值编码通常最有用的地方。整个指南中都提到了需要在Swift中采用明显不同方法的情况。 有关使用Swift和Cocoa技术的更多信息，请阅读将Swift与Cocoa和Objective-C一起使用（Swift 3）。有关Swift的完整描述，请阅读Swift编程语言（Swift 3）。 使用键值编码的其他Cocoa技术符合键值编码的对象可以参与依赖于此类访问的各种Cocoa技术，包括： 键值观察(Key-value observing)。此机制使对象能够注册异步通知监听另一个对象属性的改变，如“ Key-Value Observing Programming。 Cocoa绑定(Cocoa bindings)。这一系列技术完全实现了Model-View-Controller范例，其中模型(Model)用于封装应用程序数据，视图(View)用于显示和编辑数据，控制器(Controller)在两者之间进行调解。阅读Cocoa Bindings Programming Topics以了解有关Cocoa绑定的更多信息。 核心数据(Core Data)。该框架为与对象生命周期和对象图形化管理相关的常见任务（包括持久性）提供通用和自动化解决方案。您可以在Core Data Programming Guide阅读Core Data 。 AppleScript。这种脚本语言可以直接控制脚本化应用程序和macOS的许多部分。Cocoa的脚本支持利用键值编码来获取和设置脚本化对象中的信息。NSScriptKeyValueCoding非正式协议中的方法提供了使用键值编码的附加功能，包括通过多值键中的索引获取和设置键值，以及将键值强制（或转换）为适当的数据类型。AppleScript Overview提供了AppleScript及其相关技术的高级概述。 由于笔者水平有限，文中如果有错误的地方，或者有更好的方法，还望大神指出。附上本文的所有 demo 下载链接，【GitHub】。如果你看完后觉得对你有所帮助，还望在 GitHub 上点个 star。赠人玫瑰，手有余香。]]></content>
      <categories>
        <category>iOS文档</category>
      </categories>
      <tags>
        <tag>文档翻译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UITableView的分割线设置及不能全屏原因]]></title>
    <url>%2F2018%2F09%2F17%2FUITableView%E7%9A%84%E5%88%86%E5%89%B2%E7%BA%BF%E8%AE%BE%E7%BD%AE%E5%8F%8A%E4%B8%8D%E8%83%BD%E5%85%A8%E5%B1%8F%E5%8E%9F%E5%9B%A0%2F</url>
    <content type="text"><![CDATA[一般TableView设置全屏分隔线有下面三种方法 方法1:自定义cell, 手动添加分割线 首先先隐藏系统自带的分割线, 接下来有2种做法 (建议使用做法a) tableView.separatorStyle = UITableViewCellSeparatorStyleNone; 或者 self.tableView.separatorColor = [UIColor clearColor]; 做法a: 可以通过addSubview的方式添加一条分割线 - (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath { UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:cellId forIndexPath:indexPath]; //自定义分割线方法一: 通过addSubview的方式添加一条分割线 //在自定义cell 里面给每个cell添加高度为2的红色分割线 CGFloat cellH = cell.frame.size.height; if(indexPath.row != cars.count - 1){ UIView *line = [[UIView alloc] initWithFrame:CGRectMake(0, cellH-2, self.view.frame.size.width, 2)]; line.backgroundColor = [UIColor redColor]; [cell addSubview:line]; } return cell; } 做法b:也可以自定义cell, cell中重写drawRect: 自绘分割线 // 自绘分割线 - (void)drawRect:(CGRect)rect { CGContextRef context = UIGraphicsGetCurrentContext(); CGContextSetFillColorWithColor(context, [UIColor whiteColor].CGColor); CGContextFillRect(context, rect); CGContextSetStrokeColorWithColor(context, [UIColor greenColor].CGColor); //绘制高度为2绿色分割线 CGContextStrokeRect(context, CGRectMake(0, rect.size.height - 2, rect.size.width, 2)); } 方法2:自定义cell , 重写setFrame方法,cell高度-1,露出tableView背景色 首先隐藏系统分割线, 设置tableView背景颜色. self.tableView.separatorStyle = UITableViewCellSeparatorStyleNone; // 设置tableView背景色 self.tableView.backgroundColor = [UIColor colorWithWhite:215 / 255.0 alpha:1]; 在自定义cell中重写setFrame: - (void)setFrame:(CGRect)frame { frame.size.height -= 1; // 给cellframe赋值 [super setFrame:frame]; } 方法3.利用系统属性设置(separatorInset, layoutMargins), 共需添加三句代码 对tableView的separatorInset, layoutMargins属性的设置 -(void)viewDidLoad { [super viewDidLoad]; //1.调整(iOS7以上)表格分隔线边距 if ([self.tableView respondsToSelector:@selector(setSeparatorInset:)]) { self.tableView.separatorInset = UIEdgeInsetsZero; } //2.调整(iOS8以上)view边距(或者在cell中设置preservesSuperviewLayoutMargins,二者等效) if ([self.tableView respondsToSelector:@selector(setLayoutMargins:)]) { self.tableView.layoutMargins = UIEdgeInsetsZero; } } 对cell的LayoutMargins属性的设置 补充:对cell的设置可以写在cellForRowAtIndexPath里,也可以写在willDisplayCell方法里 -(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath { UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:ID forIndexPath:indexPath]; //2.调整(iOS8以上)tableView边距(与上面第2步等效,二选一即可) if ([cell respondsToSelector:@selector(setPreservesSuperviewLayoutMargins:)]) { cell.preservesSuperviewLayoutMargins = NO; } //3.调整(iOS8以上)view边距 if ([cell respondsToSelector:@selector(setLayoutMargins:)]) { [cell setLayoutMargins:UIEdgeInsetsZero]; } return cell; } 三种方法优缺点比较: 方法1 中做法a比较好用,可以使用系统自带的cell, 但是需要添加一个view,设置背景颜色和frame. 而做法b仅仅为了分隔线却还必须再自定义cell, 重写drawRect,又显得麻烦; 方法2比较取巧,但是也需要自定义cell,在某些情况下不允许改变tableView的背景色,使用场景有限; 方法3不需要自定义cell,对系统(iOS7,iOS8以上)做个简单判断即可.可惜网上很多文章写的不对,很多人不会正确使用,有些会用的人也说不清楚原理,只管复制粘贴.比如网上流传的一般是这样,需要四步,虽然真的管用,但多了一步[cell setSeparatorInset:UIEdgeInsetsZero];而且原理也没讲,估计是某大神写的,根本不屑于过多解释,让我用起来很郁闷,网上流传代码: 首先在viewDidLoad方法中加上如下代码： -(void)viewDidLoad { [super viewDidLoad]; if ([self.tableView respondsToSelector:@selector(setSeparatorInset:)]) { [self.tableView setSeparatorInset:UIEdgeInsetsZero]; } if ([self.tableView respondsToSelector:@selector(setLayoutMargins:)]) { [self.tableView setLayoutMargins:UIEdgeInsetsZero]; } 然后在willDisplayCell方法中加入如下代码： - (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath { if ([cell respondsToSelector:@selector(setSeparatorInset:)]) { [cell setSeparatorInset:UIEdgeInsetsZero]; } if ([cell respondsToSelector:@selector(setLayoutMargins:)]) { [cell setLayoutMargins:UIEdgeInsetsZero]; } } 分割线不能全屏原理解析 其实关于分隔线不能全屏的原理,苹果官方在文件中已经说明了,可以去看一下 在iOS7之前系统默认就是全屏的,iOS7时UITableView多了separatorInset属性,可在UITableView的头文件中查看,如下: @property (nonatomic) UIEdgeInsets separatorInset NS_AVAILABLE_IOS(7_0) UI_APPEARANCE_SELECTOR; // allows customization of the frame of cell separators iOS7时只要设置该属性为UIEdgeInsetsZero就没有问题了. iOS8之后仅仅完成以上设置就不行了,仔细查看后发现iOS8的UIView的头文件里又多了个layoutMargins属性,并有官方注释 @property (nonatomic) UIEdgeInsets layoutMargins NS_AVAILABLE_IOS(8_0); /* -layoutMargins returns a set of insets from the edge of the view&#39;s bounds that denote a default spacing for laying out content. If preservesSuperviewLayoutMargins is YES, margins cascade down the view tree, adjusting for geometry offsets, so that setting the left value of layoutMargins on a superview will affect the left value of layoutMargins for subviews positioned close to the left edge of their superview&#39;s bounds If your view subclass uses layoutMargins in its layout or drawing, override -layoutMarginsDidChange in order to refresh your view if the margins change. */ 大意是说:layoutMargins是view的bounds的边距,用来调整内容默认边距 如果preservesSuperviewLayoutMargins属性是YES,那么设置父控件的layoutMargins边距, 就会影响所有子控件的相对于父控件bounds的layoutMargins边距 如果你的view的子类在布局或者绘图中使用了layoutMargins属性,需要重写-layoutMarginsDidChange 方法, 以便当边距改变时能刷新你的view 正是因为layoutMargins是UIView的新增属性,tablet和cell作为UIView的子类都有这个属性,所以相比较iOS7系统,iOS8之后就多了两步,必须同时再对tableView和cell的layoutMargins属性进行处理,才能让分隔线真正全屏. 同时官方注释中对preservesSuperviewLayoutMargins(意即:维持父控件的布局边距)属性的说明,也正好能说明网上另一种方法不设置self.tableView.layoutMargins = UIEdgeInsetsZero;而是设置cell.preservesSuperviewLayoutMargins = NO;为什么也能起作用 弄清楚了这些原理,就可以更好的记忆和使用这些方法,不用每次都去旧代码查找或者去百度了. 说到了最后,不知道大家有没有觉得影响分隔线全屏的元凶layoutMargins属性 稍微有点眼熟呢?其实它在另一个地方也做了不少恶,就在storyboard中: PS:附效果图如下: 设置之前效果图: 设置完第1步self.tableView.separatorInset = UIEdgeInsetsZero;后效果图: 设置完第2步self.tableView.layoutMargins = UIEdgeInsetsZero;后效果图: 设置完第3步cell.layoutMargins = UIEdgeInsetsZero;后效果图: 由于笔者水平有限，文中如果有错误的地方，或者有更好的方法，还望大神指出。附上本文的所有 demo 下载链接，【GitHub】。如果你看完后觉得对你有所帮助，还望在 GitHub 上点个 star。赠人玫瑰，手有余香。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UITableViewStylePlain和UITableViewStyleGrouped样式的区别及效果处理]]></title>
    <url>%2F2018%2F09%2F15%2FUITableViewStylePlain%E5%92%8CUITableViewStyleGrouped%E6%A0%B7%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%8A%E6%95%88%E6%9E%9C%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[创建UITableView 时, 需要设置TableView样式, 默认有两种样式:UITableViewStylePlain, UITableViewStyleGrouped UITableView *tableView = [[UITableView alloc] initWithFrame:CGRectMake(0, 0, self.view.frame.size.width, self.view.frame.size.height) style: UITableViewStyleGrouped] 下面先介绍下, 这两种样式以及区别: 一. UITableView样式介绍UITableViewStylePlain 介绍在tableView的UITableViewStylePlain中，当一个section的rows有一部分可见时，section的header和footer浮动在内容顶部。plain style的tableView可以有一个section索引，作为一个bar在table的右边(例如A ~ Z)。你可以点击一个特定的标签，跳转到目标section。例如下图： UITableViewStyleGroup 介绍在tableView的UITableViewStyleGroup中，所有单元格拥有一个默认的背景颜色和默认背景视图。背景视图为特定section中的所有cell提供可视分组。例如，一个group可以是一个人的名字和标题，另一个group可以是电话,电子邮件帐户等。可参考iphone“设置”程序。例如下图： Group类型默认设置tableView灰色背景色，cell为白色背景色，section外边缘设置浅灰色边框，cell设置浅灰色间隔线。如下图： 二:区别总结：UITableViewStylePlain使用1.plain类型有多段时，滚动时Section Header 在顶部停留，有些界面比如设置界面，这些新特性将显得多余。（自带效果） 2.plain类型默认section之间没有中间的间距和头部间距（想让plain类型的section之间留有空白，需要在UITableView代理方法中return自定义的headerView和footerView，并在自定义的headerView 和 footerView 里面重写setFrame方法） 解决方案：让plain类型的UITableView的section头部视图不停留（取消粘性效果） 方法一: 网上好多都是这个方法. 这个代码是通过scroll偏移量来监听和改变你的tableView的contentInset 可见很不好（试试就知道） //去掉UItableview headerview黏性(sticky) - (void)scrollViewDidScroll:(UIScrollView *)scrollView { CGFloat sectionHeaderHeight = 30; if (scrollView.contentOffset.y =0) { scrollView.contentInset = UIEdgeInsetsMake(-scrollView.contentOffset.y, 0, 0, 0); } else if (scrollView.contentOffset.y >= sectionHeaderHeight) { scrollView.contentInset = UIEdgeInsetsMake(-sectionHeaderHeight, 0, 0, 0); } } 方法二: 在自定义section的headerView中, 重写setFrame: 方法来重载table的section. 注意:setFrame方法中需要拿到重载的table和section! - (void)setFrame:(CGRect)frame { CGRect sectionRect = [self.tableView rectForSection:self.section]; CGRect newFrame = CGRectMake(CGRectGetMinX(frame), CGRectGetMinY(sectionRect), CGRectGetWidth(frame), CGRectGetHeight(frame)); [super setFrame:newFrame]; } UITableViewStyleGroup 使用解决方案：去掉 UITableViewStyleGroup类型的多余间距 应用场景一: sction的头部视图和尾部视图,无任何内容 此应用场景需要分两步做:第一步: 处理第一个section上边多余间距(2种方法) 方法一: tableView的tableHeaderView属性 注意: 设置tableView头部视图的高度为特小值，但不能为零，若为零的话，iOS会取默认值，就无法消除头部间距了。 - (void)viewDidLoad { //设置代理 tableView.delegate = self; //隐藏UITableViewStyleGrouped上边多余的间隔 tableView.tableHeaderView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 0, CGFLOAT_MIN)]; } 方法二: 设置顶部额滚动区域 tableView.contentInset = UIEdgeInsetsMake(-20, 0, 0, 0); 补充: 属性tableHeaderView和contentInset 结合使用, 可以设置表格第一个cell顶到最顶部 tableView.tableHeaderView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 0, CGFLOAT_MIN)]; tableView.contentInset = UIEdgeInsetsMake(-20, 0, 0, 0); 第二步: 处理每个section下边多余间距(2种方法) Group样式, 默认每一组都会有头部和尾部间距, 这两个间距保留一个就可以了.另一个间距设置为0. 方法一: tableView 属性sectionHeaderHeight 和 属性sectionFooterHeight , 处理多余间距 //设置tableView主间距为20 tableView.sectionHeaderHeight = 0; tableView.sectionFooterHeight = 20; 方法二: 调用tableView的代理方法 , 设置尾部视图的高度， 注意: 去掉的视图, 返回值不能为0，否则系统启用默认值。返回的高度使用极小值CGFLOAT_MIN。 注意2: 调用下面两个tableView代理方法后, sectionHeaderHeight属性和sectionFooterHeight属性设置的值失效. - (CGFloat)tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section{ return 44; } // 注意:return height 为 0，则 height 被设置成默认值 - (CGFloat)tableView:(UITableView *)tableView heightForFooterInSection:(NSInteger)section{ return CGFLOAT_MIN; } 应用场景二: sction有头部标题 尾部标题此应用场景两种方法取其一, 可以同时处理section顶部间距和中间间距 方法一: 设置 tableView 属性sectionHeaderHeight 和 属性sectionFooterHeight , 可同时处理section多余顶部间距和中间间距 tableView.sectionHeaderHeight = 30; tableView.sectionFooterHeight = 0; 方法二:调用tableView的代理方法 , 设置头部视图和尾部视图的高度 //第二步:隐藏UITableViewStyleGrouped下边多余的间隔 - (CGFloat)tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section{ return 30; } // 注意:此时可以设置为0 - (CGFloat)tableView:(UITableView *)tableView heightForFooterInSection:(NSInteger)section{ return 0; } 应用场景三: section自定义头部视图和尾部视图 调用下面tableView代理方法 自定义头部视图和尾部视图后, 不需要做顶部间距处理, 第一个section头部视图会自动顶到最顶部. - (UIView *)tableView:(UITableView *)tableView viewForHeaderInSection:(NSInteger)section{ } - (UIView *)tableView:(UITableView *)tableView viewForFooterInSection:(NSInteger)section{ } 中间间距 只需要通过tableView代理方法, 调整头部视图或者尾部视图各自的高度即可. - (CGFloat)tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section{ return 30; } //注意:此时可以设置为0 - (CGFloat)tableView:(UITableView *)tableView heightForFooterInSection:(NSInteger)section{ return 0; } 三. 在 Storyboard 中 0 代码搞定顶部多余间距没用 Storyboard 的同学使用上面的代码就 OK 了；而在 Storyboard 中可以 0 代码搞定这个事： 首先，在第一个 Section 的上面拖进来一个空 UIView 然后选中这个 UIView 的 Runtime Attributes 栏，添加一个 frame 的 KeyPath 这样头部的间隔就乖乖的不见了： 刨根问底 UITableViewHeader 的猫腻为什么刚才说 0.1 和 CGFLOAT_MIN 是等效的呢？经过研究，这个高度值的影响大概是这样的： 若传入的 height == 0，则 height 被设置成默认值 若 height 小于屏幕半像素对应的高度，这个 header 不在另一个像素渲染 半像素也就是 1.0 / scale / 2.0，如在 @2x 屏上是 0.25直观的感受下，假如这个 height 被设置成 0.5 的样子： 导航栏下面的阴影线看上去宽了 0.5 像素的，Done。 由于笔者水平有限，文中如果有错误的地方，或者有更好的方法，还望大神指出。附上本文的所有 demo 下载链接，【GitHub】。如果你看完后觉得对你有所帮助，还望在 GitHub 上点个 star。赠人玫瑰，手有余香。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[runtime使用示例代码]]></title>
    <url>%2F2018%2F09%2F13%2Fruntime%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[一、runtime简介 RunTime简称运行时。OC就是运行时机制，也就是在运行时候的一些机制，其中最主要的是消息机制。 对于C语言，函数的调用在编译的时候会决定调用哪个函数。 对于OC的函数，属于动态调用过程，在编译的时候并不能决定真正调用哪个函数，只有在真正运行的时候才会根据函数的名称找到对应的函数来调用。 事实证明： 在编译阶段，OC可以调用任何函数，即使这个函数并未实现，只要声明过就不会报错。 在编译阶段，C语言调用未实现的函数就会报错。 二、runtime作用1.发送消息 方法调用的本质，就是让对象发送消息。 objc_msgSend,只有对象才能发送消息，因此以objc开头. 使用消息机制前提，必须导入#import &lt;objc/message.h&gt; 消息机制简单使用 // 创建person对象 Person *p = [[Person alloc] init]; // 调用对象方法 [p eat]; // 本质：让对象发送消息 objc_msgSend(p, @selector(eat)); // 调用类方法的方式：两种 // 第一种通过类名调用 [Person eat]; // 第二种通过类对象调用 [[Person class] eat]; // 用类名调用类方法，底层会自动把类名转换成类对象调用 // 本质：让类对象发送消息 objc_msgSend([Person class], @selector(eat)); 消息机制原理:对象根据方法编号SEL去映射表查找对应的方法实现 2.交换方法 开发使用场景:系统自带的方法功能不够，给系统自带的方法扩展一些功能，并且保持原有的功能。 方式一:继承系统的类，重写方法. 方式二:使用runtime,交换方法. @implementation ViewController - (void)viewDidLoad { [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. // 需求：给imageNamed方法提供功能，每次加载图片就判断下图片是否加载成功。 // 步骤一：先搞个分类，定义一个能加载图片并且能打印的方法+ (instancetype)imageWithName:(NSString *)name; // 步骤二：交换imageNamed和imageWithName的实现，就能调用imageWithName，间接调用imageWithName的实现。 UIImage *image = [UIImage imageNamed:@"123"]; } @end @implementation UIImage (Image) // 加载分类到内存的时候调用 + (void)load { // 交换方法 // 获取imageWithName方法地址 Method imageWithName = class_getClassMethod(self, @selector(imageWithName:)); // 获取imageWithName方法地址 Method imageName = class_getClassMethod(self, @selector(imageNamed:)); // 交换方法地址，相当于交换实现方式 method_exchangeImplementations(imageWithName, imageName); } // 不能在分类中重写系统方法imageNamed，因为会把系统的功能给覆盖掉，而且分类中不能调用super. // 既能加载图片又能打印 + (instancetype)imageWithName:(NSString *)name { // 这里调用imageWithName，相当于调用imageName UIImage *image = [self imageWithName:name]; if (image == nil) { NSLog(@"加载空的图片"); } return image; } @end 交换原理： 交换之前： 交换之后： 3.动态添加方法 开发使用场景：如果一个类方法非常多，加载类到内存的时候也比较耗费资源，需要给每个方法生成映射表，可以使用动态给某个类，添加方法解决。 经典面试题：有没有使用performSelector，其实主要想问你有没有动态添加过方法。 简单使用 @implementation ViewController - (void)viewDidLoad { [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. Person *p = [[Person alloc] init]; // 默认person，没有实现eat方法，可以通过performSelector调用，但是会报错。 // 动态添加方法就不会报错 [p performSelector:@selector(eat)]; } @end @implementation Person // void(*)() // 默认方法都有两个隐式参数， void eat(id self,SEL sel) { NSLog(@"%@ %@",self,NSStringFromSelector(sel)); } // 当一个对象调用未实现的方法，会调用这个方法处理,并且会把对应的方法列表传过来. // 刚好可以用来判断，未实现的方法是不是我们想要动态添加的方法 + (BOOL)resolveInstanceMethod:(SEL)sel { if (sel == @selector(eat)) { // 动态添加eat方法 // 第一个参数：给哪个类添加方法 // 第二个参数：添加方法的方法编号 // 第三个参数：添加方法的函数实现（函数地址） // 第四个参数：函数的类型，(返回值+参数类型) v:void @:对象->self :表示SEL->_cmd class_addMethod(self, @selector(eat), eat, "v@:"); } return [super resolveInstanceMethod:sel]; } @end 4.给分类添加属性 原理：给一个类声明属性，其实本质就是给这个类添加关联，并不是直接把这个值的内存空间添加到类存空间。 @implementation ViewController - (void)viewDidLoad { [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. // 给系统NSObject类动态添加属性name NSObject *objc = [[NSObject alloc] init]; objc.name = @"乔布斯"; NSLog(@"%@",objc.name); } @end // 定义关联的key static const char *key = "name"; @implementation NSObject (Property) - (NSString *)name { // 根据关联的key，获取关联的值。 return objc_getAssociatedObject(self, key); } - (void)setName:(NSString *)name { // 第一个参数：给哪个对象添加关联 // 第二个参数：关联的key，通过这个key获取 // 第三个参数：关联的value // 第四个参数:关联的策略 objc_setAssociatedObject(self, key, name, OBJC_ASSOCIATION_RETAIN_NONATOMIC); } @end 5.字典转模型 设计模型：字典转模型的第一步 模型属性，通常需要跟字典中的key一一对应 问题：一个一个的生成模型属性，很慢？ 需求：能不能自动根据一个字典，生成对应的属性。 解决：提供一个分类，专门根据字典生成对应的属性字符串。 @implementation NSObject (Log) // 自动打印属性字符串 + (void)resolveDict:(NSDictionary *)dict { // 拼接属性字符串代码 NSMutableString *strM = [NSMutableString string]; // 1.遍历字典，把字典中的所有key取出来，生成对应的属性代码 [dict enumerateKeysAndObjectsUsingBlock:^(id _Nonnull key, id _Nonnull obj, BOOL * _Nonnull stop) { // 类型经常变，抽出来 NSString *type; if ([obj isKindOfClass:NSClassFromString(@"__NSCFString")]) { type = @"NSString"; }else if ([obj isKindOfClass:NSClassFromString(@"__NSCFArray")]){ type = @"NSArray"; }else if ([obj isKindOfClass:NSClassFromString(@"__NSCFNumber")]){ type = @"int"; }else if ([obj isKindOfClass:NSClassFromString(@"__NSCFDictionary")]){ type = @"NSDictionary"; } // 属性字符串 NSString *str; if ([type containsString:@"NS"]) { str = [NSString stringWithFormat:@"@property (nonatomic, strong) %@ *%@;",type,key]; }else{ str = [NSString stringWithFormat:@"@property (nonatomic, assign) %@ %@;",type,key]; } // 每生成属性字符串，就自动换行。 [strM appendFormat:@"\n%@\n",str]; }]; // 把拼接好的字符串打印出来，就好了。 NSLog(@"%@",strM); } @end 字典转模型的方式一：KVC @implementation Status + (instancetype)statusWithDict:(NSDictionary *)dict { Status *status = [[self alloc] init]; [status setValuesForKeysWithDictionary:dict]; return status; } @end KVC字典转模型弊端：必须保证，模型中的属性和字典中的key一一对应。 如果不一致，就会调用[&lt;Status 0x7fa74b545d60&gt; setValue:forUndefinedKey:]报key找不到的错。 分析:模型中的属性和字典的key不一一对应，系统就会调用setValue:forUndefinedKey:报错。 解决:重写对象的setValue:forUndefinedKey:,把系统的方法覆盖，就能继续使用KVC，字典转模型了。 - (void)setValue:(id)value forUndefinedKey:(NSString *)key { } 字典转模型的方式二：Runtime 思路：利用运行时，遍历模型中所有属性，根据模型的属性名，去字典中查找key，取出对应的值，给模型的属性赋值。 步骤：提供一个NSObject分类，专门字典转模型，以后所有模型都可以通过这个分类转。 @implementation ViewController - (void)viewDidLoad { [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. // 解析Plist文件 NSString *filePath = [[NSBundle mainBundle] pathForResource:@"status.plist" ofType:nil]; NSDictionary *statusDict = [NSDictionary dictionaryWithContentsOfFile:filePath]; // 获取字典数组 NSArray *dictArr = statusDict[@"statuses"]; // 自动生成模型的属性字符串 // [NSObject resolveDict:dictArr[0][@"user"]]; _statuses = [NSMutableArray array]; // 遍历字典数组 for (NSDictionary *dict in dictArr) { Status *status = [Status modelWithDict:dict]; [_statuses addObject:status]; } // 测试数据 NSLog(@"%@ %@",_statuses,[_statuses[0] user]); } @end @implementation NSObject (Model) + (instancetype)modelWithDict:(NSDictionary *)dict { // 思路：遍历模型中所有属性-》使用运行时 // 0.创建对应的对象 id objc = [[self alloc] init]; // 1.利用runtime给对象中的成员属性赋值 // class_copyIvarList:获取类中的所有成员属性 // Ivar：成员属性的意思 // 第一个参数：表示获取哪个类中的成员属性 // 第二个参数：表示这个类有多少成员属性，传入一个Int变量地址，会自动给这个变量赋值 // 返回值Ivar *：指的是一个ivar数组，会把所有成员属性放在一个数组中，通过返回的数组就能全部获取到。 /* 类似下面这种写法 Ivar ivar; Ivar ivar1; Ivar ivar2; // 定义一个ivar的数组a Ivar a[] = {ivar,ivar1,ivar2}; // 用一个Ivar *指针指向数组第一个元素 Ivar *ivarList = a; // 根据指针访问数组第一个元素 ivarList[0]; */ unsigned int count; // 获取类中的所有成员属性 Ivar *ivarList = class_copyIvarList(self, &count); for (int i = 0; i < count; i++) { // 根据角标，从数组取出对应的成员属性 Ivar ivar = ivarList[i]; // 获取成员属性名 NSString *name = [NSString stringWithUTF8String:ivar_getName(ivar)]; // 处理成员属性名->字典中的key // 从第一个角标开始截取 NSString *key = [name substringFromIndex:1]; // 根据成员属性名去字典中查找对应的value id value = dict[key]; // 二级转换:如果字典中还有字典，也需要把对应的字典转换成模型 // 判断下value是否是字典 if ([value isKindOfClass:[NSDictionary class]]) { // 字典转模型 // 获取模型的类对象，调用modelWithDict // 模型的类名已知，就是成员属性的类型 // 获取成员属性类型 NSString *type = [NSString stringWithUTF8String:ivar_getTypeEncoding(ivar)]; // 生成的是这种@"@\"User\"" 类型 -》 @"User" 在OC字符串中 \" -> "，\是转义的意思，不占用字符 // 裁剪类型字符串 NSRange range = [type rangeOfString:@"\""]; type = [type substringFromIndex:range.location + range.length]; range = [type rangeOfString:@"\""]; // 裁剪到哪个角标，不包括当前角标 type = [type substringToIndex:range.location]; // 根据字符串类名生成类对象 Class modelClass = NSClassFromString(type); if (modelClass) { // 有对应的模型才需要转 // 把字典转模型 value = [modelClass modelWithDict:value]; } } // 三级转换：NSArray中也是字典，把数组中的字典转换成模型. // 判断值是否是数组 if ([value isKindOfClass:[NSArray class]]) { // 判断对应类有没有实现字典数组转模型数组的协议 if ([self respondsToSelector:@selector(arrayContainModelClass)]) { // 转换成id类型，就能调用任何对象的方法 id idSelf = self; // 获取数组中字典对应的模型 NSString *type = [idSelf arrayContainModelClass][key]; // 生成模型 Class classModel = NSClassFromString(type); NSMutableArray *arrM = [NSMutableArray array]; // 遍历字典数组，生成模型数组 for (NSDictionary *dict in value) { // 字典转模型 id model = [classModel modelWithDict:dict]; [arrM addObject:model]; } // 把模型数组赋值给value value = arrM; } } if (value) { // 有值，才需要给模型的属性赋值 // 利用KVC给模型中的属性赋值 [objc setValue:value forKey:key]; } } return objc; } @end]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[const,static,extern区别]]></title>
    <url>%2F2018%2F09%2F12%2Fconst-static-extern%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[一、const与宏的区别（面试题）: const简介:之前常用的字符串常量，一般是抽成宏，但是苹果不推荐我们抽成宏，推荐我们使用const常量。 执行时刻:宏是预编译（编译之前处理），const是编译阶段。 编译检查:宏不做检查，不会报编译错误，只是替换，const会编译检查，会报编译错误。 宏的好处:宏能定义一些函数，方法。 const不能。 宏的坏处:使用大量宏，容易造成编译时间久，每次都需要重新替换。 注意:很多Blog都说使用宏，会消耗很多内存，我这验证并不会生成很多内存，宏定义的是常量，常量都放在常量区，只会生成一份内存。 //常见常量: 抽成宏 #define SKAccount @"account123" //字符串变量 static NSString *const account = @"account123"; @interface ViewController () @end @implementation ViewController - (void)viewDidLoad { [super viewDidLoad]; NSString *str = SKAccount; NSString *str2 = SKAccount; NSLog(@"%p %p", str, str2); //打印结果 0x10c7ba068 0x10c7ba068 } // 常见的常量：抽成宏 #define Account @"account" #define UserDefault [NSUserDefaults standardUserDefaults] // 字符串常量 static NSString * const account = @"account"; - (void)viewDidLoad { [super viewDidLoad]; // 偏好设置存储 // 使用宏 [UserDefault setValue:@"123" forKey:Account]; // 使用const常量 [[NSUserDefaults standardUserDefaults] setValue:@"123" forKey:account]; } 二、const作用：限制类型* 1.const仅仅用来修饰右边的变量（基本数据变量p，指针变量*p） * 2.被const修饰的变量是只读的。 const基本使用 - (void)viewDidLoad { [super viewDidLoad]; // 定义变量 int a = 1; // 允许修改值 a = 20; // const两种用法 // const:修饰基本变量b // 这两种写法是一样的，const只修饰右边的基本变量b const int b = 20; // b:只读变量 int const b = 20; // b:只读变量 // 不允许修改值 b = 1; // const:修饰指针变量*p，带*的变量，就是指针变量. // 定义一个指向int类型的指针变量，指向a的地址 int *p = &a; int c = 10; p = &c; // 允许修改p指向的地址， // 允许修改p访问内存空间的值 *p = 20; // const修饰指针变量访问的内存空间，修饰的是右边*p1， // 两种方式一样 const int *p1; // *p1：常量 p1:变量 int const *p1; // *p1：常量 p1:变量 // const修饰指针变量p1 int * const p1; // *p1:变量 p1:常量 // 第一个const修饰*p1 第二个const修饰 p1 // 两种方式一样 const int * const p1; // *p1：常量 p1：常量 int const * const p1; // *p1：常量 p1：常量 } 三、const开发中使用场景:* 1.需求1:提供一个方法，这个方法的参数是地址，里面只能通过地址读取值,不能通过地址修改值 * 2.需求2:提供一个方法，这个方法的参数是地址，里面不能修改参数的地址。 @implementation ViewController // const放*前面约束参数，表示*a只读 // 只能修改地址a,不能通过a修改访问的内存空间 - (void)test:(const int * )a { // *a = 20; } // const放*后面约束参数，表示a只读 // 不能修改a的地址，只能修改a访问的值 - (void)test1:(int * const)a { int b; // 会报错 a = &b; *a = 2; } - (void)viewDidLoad { [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. int a = 10; // 需求1:提供一个方法，这个方法的参数是地址，里面只能通过地址读取值,不能通过地址修改值。 // 这时候就需要使用const，约束方法的参数只读. [self test:&a]; // 需求2:提供一个方法，这个方法的参数是地址，里面不能修改参数的地址。 [self test1:&a]; } @end 四、static和extern简单使用(要使用一个东西，先了解其作用) static作用: 修饰局部变量： 1.延长局部变量的生命周期,程序结束才会销毁。 2.局部变量只会生成一份内存,只会初始化一次。 3.改变局部变量的作用域。 修饰全局变量 1.只能在本文件中访问,修改全局变量的作用域,生命周期不会改 2.避免重复定义全局变量 extern作用: 只是用来获取全局变量(包括全局静态变量)的值，不能用于定义变量 extern工作原理: 先在当前文件查找有没有全局变量，没有找到，才会去其他文件查找。 // 全局变量：只有一份内存，所有文件共享，与extern联合使用。 int a = 20; // static修饰全局变量 static int age = 20; - (void)test { // static修饰局部变量 static int age = 0; age++; NSLog(@"%d",age); } - (void)viewDidLoad { [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. [self test]; [self test]; extern int age; NSLog(@"%d",age); } 五、static与const联合使用 static与const作用:声明一个只读的静态变量 开发使用场景:在一个文件中经常使用的字符串常量，可以使用static与const组合 // 开发中常用static修饰全局变量,只改变作用域 // 为什么要改变全局变量作用域，防止重复声明全局变量。 // 开发中声明的全局变量，有些不希望外界改动，只允许读取。 // 比如一个基本数据类型不希望别人改动 // 声明一个静态的全局只读常量 static const int a = 20; // staic和const联合的作用:声明一个静态的全局只读常量 // iOS中staic和const常用使用场景，是用来代替宏，把一个经常使用的字符串常量，定义成静态全局只读变量. // 开发中经常拿到key修改值，因此用const修饰key,表示key只读，不允许修改。 static NSString * const key = @"name"; // 如果 const修饰 *key1,表示*key1只读，key1还是能改变。 static NSString const *key1 = @"name"; 六、extern与const联合使用 开发中使用场景:在多个文件中经常使用的同一个字符串常量，可以使用extern与const组合。 原因: static与const组合：在每个文件都需要定义一份静态全局变量。 extern与const组合:只需要定义一份全局变量，多个文件共享。 全局常量正规写法:开发中便于管理所有的全局变量，通常搞一个GlobeConst文件，里面专门定义全局变量，统一管理，要不然项目文件多不好找。 GlobeConst.h /*******************************首页****************************/ extern NSString * const nameKey = @&quot;name&quot;; /*******************************首页****************************/ GlobeConst.m #import &lt;Foundation/Foundation.h&gt; /*******************************首页****************************/ NSString * const nameKey = @&quot;name&quot;; /*******************************首页****************************/]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS面试题24--补充]]></title>
    <url>%2F2018%2F09%2F12%2FiOS%E9%9D%A2%E8%AF%95%E9%A2%9824-%E8%A1%A5%E5%85%85%2F</url>
    <content type="text"><![CDATA[UML 统一建模语言（UML，UnifiedModelingLanguage）是面向对象软件的标准化建模语言。UML因其简单、统一的特点，而且能表达软件设计中的动态和静态信息，目前已成为可视化建模语言的工业标准。在软件无线电系统的开发过程中，统一建模语言可以在整个设计周期中使用，帮助设计者缩短设计时间，减少改进的成本，使软硬件分割最优。 用例图 静态图 行为图 交互图 实现图 如果设计一个交易平台，流程如下：A用户在平台P发现B用户有东西出售，P平台的业务逻辑是需要A先付款到P得中间账户，等到A确认收货后，P向B付款，你能尝试某种表示方式来让程序员，产品设计，美术设计明白这个流程么？从1-n个五序列的数字中排序的算法有哪些，简单代码实现一个并写出时间复杂度有一个6克和21克的砝码，怎样称量三次将420克的糖分成270克和150克一桌子人，每个人额头上都贴有标签，绿色和红色，绿色至少1个，大家都能看到别人头上的标签，看不到自己头上的标签，然后开始闭眼游戏，大家觉得自己头上是绿色标签就拍一下手掌，第一次闭眼没人拍掌，第二次，第三次也同样没有人拍掌，第四次有一个人拍掌了，请问绿色标签有几张是否使用过coreImage和coreText?如果使用过，说说你的体验 coreImage是IOS5中新加入的一个Objective-c的框架，提供了强大高效的图像处理功能，用来对基于像素的图像进行操作与分析。 写一个单项链表逆序什么是OpenGL?具体使用开启一个其他线程来计算1+1 并且把结果用主线程显示在label上更新UIffmpeg框架静态链接库init和initwithobject区别（语法）？什么是OOP？为NSString扩展一个方法，方法能判断字符串是否是Url地址（即判断字符串是否以“http://”），放回BOOL值类型写一个iphone程序，有2屏，可以通过滑动切换，第二屏有一个webview，读取本地的html文件，Html文件中会加载一个本地xml文件，获取xml文件中的数据内容并显示。（可选：html中加载的js文件）.如何避免json解析出现内存泄露，内存泄露后怎么解决什么情况下会发生内存泄漏和内存溢出？有方法查看当前系统内存使用情况吗？ 静态分析 ：通过静态分析我们可以最初步的了解到代码的一些不规范的地方或者是存在的内存泄漏，这是我们第一步对内存泄漏的检测。当然有一些警告并不是我们关心的可以略过。 通过instruments来检查内存泄漏 这个方法能粗略的定位我们在哪里发生了内存泄漏。方法是完成一个循环操作，如果内存增长为0就证明我们程序在该次循环操作中不存在内存泄漏，如果内存增长不为0那证明有可能存在内存泄漏，当然具体问题需要具体分析。 代码测试内存泄漏 在做这项工作之前我们要注意一下，在dealloc的方法中我们是否已经释放了该对象所拥有的所有对象。观察对象的生成和销毁是否配对。准确的说就是init（创建对象的方法）和dealloc是否会被成对触发（简单说来就是走一次创建对象就有走一次dealloc该对象）。 下面是自己遇到的一些比较隐秘的造成内存泄漏的情况： 1.两个对象互相拥有：也就是说对象a里面retain/addSubview了b对象，b对象同时也retain/addSubView了a对象。注意：delegate不要用retain属性，要用assign属性也会导致互相拥有。 2.有时候需要用removeFromSuperView来释放：具体说明，也许我的a对象拥有一个b对象，b对象add到了c对象上，而在我们的设计中b对象的生命周期应该和a对象相同；这时候只一句[b release]/self.b = nil是不能把b对象释放掉的（一般情况下release会使其retainCount－1,[super dealloc]会再次将所有subView的retainCount－1,而b并不是a的subView，所有最后的一次－1没有了）；所以我们需要在之前加上[b removeFromSuperView]。 写一个贪吃蛇的算法请写一个类似于NSMutableArray的类，可以添加，删除，以及如何以最快的速度查找某个元素？给一个数字，判断从左读和从右读是否是一致的？例如12321和4444给一个数组[1、3、2、4、8]排序后[1、2、3、4、8]？怎么用下面的类？北京品科艺科技有限公司 NSuserDefault NSMange Object Context NSPredict 怎么从xib文件加载成UIview？OAuth2.0授权的过程，是否用过1.0？id是编译时还是运行时蓝牙、CFNetwork基于啥？逻辑运算跟位运算的区别？三维动画的旋转的原理？底层怎么实现？点与点 用距阵变换实现的。NSFileManager/NSFileHandle为什么不用文件加载而用数据库？uikit基于什么？默写二分查找算法？设计一个忽略大小写比较两个字符串的算法？怎么过滤一段既有字符串又有数字的，让他只剩数字？支付功能。微信支付 支付宝支付友盟分享 报错假设某一个生物每B年繁殖一次，一次繁殖N个只，寿命是M年，编写程序起初有X只生物，求T年之后生物的总数是多少？=有个不相同的数，从中随机取N个数，要求N个数互不相同。//（已经有随机函数int getRand（int min，int max）表示获取从最小值到最大值的随机整数） { return min + (max – min) *rand()/RAND_MAX; } 什么是消息推送？已知二叉树后序遍历序列是dabec，中序遍历序列是debac，它的前在iPhone中怎么写入C++程序，详细写下来远程推送；本地消息和原地推送的区别苹果怎么实现安全机制 设备控制和保护:支持用户从一系列密码设计策略中根据安全需求来进行选择，包括超时设定、密码长度以及密码更新周期等 数据保护。256位AES硬件加密算法。远程信息擦除，本地信息擦除 安全网络通信，VPN SSL WAP/WAP2认证方式接入wifi 安全的iOS平台。运行时保护-沙盒机制，应用之间不能相互访问，系统资源与用户程序隔离。强制前面。安全认证框架 极光推送原理（第三方框架），怎么用的？遇到什么问题？怎么解决的？微信的附近功能怎么实现的？怎么实现第三方登陆autolayout？sizeclassHealthKit是什么？2014年6月2日召开的年度开发者大会上，苹果发布了一款新的移动应用平台，可以收集和分析用户的健康数据，这是苹果计划为其计算和移动软件推出的一系列新功能的一部分该移动应用平台被命名为“Healthkit ”，苹果高管告诉开发者，它可以整合iPhone或iPad上其它健康应用收集的数据，如血压和体重等。 HealthKit框架提供了一个结构，应用可以使用它来分享健康和健身数据。HealthKit管理从不同来源获得的数据，并根据用户的偏好设置，自动将不同来源的所有数据合并起来。应用还可以获取每个来源的原始数据，然后执行自己的数据合并。 HealthKit也可以直接与健康和健身设备一起工作。在iOS8.0中，系统可以自动将兼容的低功耗蓝牙心率仪的数据直接保存在 HealthKit存储中。如果有M7运动协处理器，系统还可以自动导入计步数据。其他的设备和数据源必须要有配套的应用才可以获取数据并保存在HealthKit中。 HealthKit另外提供了一个应用来帮助管理用户的健康数据。健康应用为用户展示HealthKit的数据。用户可以使用健康应用来查看、添加、删除或者管理其全部的健康和健身数据。用户还可以编辑每种数据类型的分享权限。 HealthKit和健康应用在iPad上都不可用。HealthKit框架不能用于应用扩展。 HomeKit是什么？HomeKit，是苹果2014年发布的智能家居平台。HomeKit库是用来沟通和控制家庭自动化配件的，这些家庭自动化配件都支持苹果的HomeKit Accessory Protocol。HomeKit应用程序可让用户发现兼容配件并配置它们。用户可以创建一些action来控制智能配件（例如恒温或者光线强弱），对其进行分组，并且可以通过Siri触发。HomeKit对象被存储在用户iOS设备的数据库中，并且通过iCloud还可以同步到其他iOS设备。HomeKit支持远程访问智能配件，并支持多个用户设备和多个用户。HomeKit 还对用户的安全和隐私做了处理。 iCloud是什么包含了哪些技术与服务？iCloud是苹果公司所提供的云端服务，2011年6月6日苹果公司执行长乔布斯（Steve Jobs）抱病主持全球开发者大会（WWDC），正式发表云端服务iCloud, iOS 5 以及 OS X Lion.其中iCloud的功能是存储内容，包括购买的音乐、应用、电子书等推送到所有设备,iCloud是一系列服务的技术封装,使用者可以免费储存5GB资料。可以备份存放照片、音乐、通讯录、短信、文档等内容，在你需要的时候以无线方式将他们推送到你所有的设备上。自行执行。轻松自如、运作流畅，它就是这么管用。可与亲朋好友共享体验的完整平台。它不仅安全，而且可提供丰富的社交体验，从任何计算机或设备均可随时方便地进行访问。iCloud上所提供的应用程序包括办公生产率、开发工具、媒体和窗口小部件等。随着时间的推移，还将通过易于使用的市场空间和应用程序开发工具箱提供范围更广的应用程序。 服务:应用软件、电子书与备份、Documents in the Cloud、Photo Stream（照片流）、iTunes Match、Mobile Me CoreData：中多线程中处理大量数据同步时的操作 CoreData:是CoCoa中处理数据绑定数据的关键特性，提供完整的对象持久化存储方案。如果你使用sqlite3厌倦了敲打sql语句，CoreData正解决了你这烦恼。sqlite3是CoreData处理的数据类型之一，当你将CoreData和sqlite的结合起来使用的话，你将能开发出强大的数据库应用。 CoreData与多线程操作:为了在查询数据的时候不让界面停滞，使用多线程是不可避免，一般我们会用thread，串行线程或者并发线程。coredata与多线程交互的时候，每个线程都必须拥有一个manager context对象，一般有两种方式： 1.每一个线程使用私有的manager context，共享一个 persistent store coordinator 2.每个线程使用私有的manager context和私有的persistent store coordinator 对于这两种方式，我们比较推荐使用第一钟方式，因为使用第二种方式的会消耗我们更多的内存，所以推荐使用第一种。 注意:CoreData里面还带有一个通知NSManagedObjectContextDidSaveNotification，主要监NSManagedObjectContext的数据是否改变，并合并数据改变到相应context 请解释一下Handoff是什么，并简述它是如何实现iOS、Mac/网页应用互通的 开发指南Handoff英译是用手推开某人，在计算机领域是CDMA术语，表示切换的意思。OSX 10.10 Yosemite新增了一个酷炫的功能“HandOff”，打开这个功能之后，用户可以在Mac上对iPad和iPhone进行操作，比如能够编写iPhone上未完成的邮件，并且可以在Mac上打开iPhone的热点等等，Mac的Hand Off功能只能识别Mac周围的iPhone手机。 Handoff的核心思想就是：用户在一个应用里所做的任何操作都包含着一个activity，一个activity可以和一个特定用户的多台设备关联起来。用行话来说，抽象出这种activity的类叫做NSUserActivity，大部分时间我们都会和这个类打交道。需要一提的是，所有的设备都必须靠近（靠近是指两台设备的蓝牙能够彼此连接），这样Handoff才能正常工作。而且还有两个先决条件得满足：第一个条件是得有一个能正常使用的iCloud账号，而且用户应该在每台准备使用Handoff的设备上登陆这个iCloud账号。事实上，当在不同的设备上切换时，为了保证正在进行的activity不被中断而且被关联到同一个用户，应该尽可能地在所有设备上使用同一个iCloud账号。第二个条件是当两个或两个以上不同的应用想要在同一个用户activity进行Handoff的操作时需要具备的，在这种情况下，所有涉及到的应用必须使用Xcode里相同的团队标识（TeamID）签名。 当编写一个支持Handoff的应用时，需要关注以下三个交互事件： 1.为将在另一台设备上继续做的事创建一个新的用户activity。 2.当需要时，用新的数据更新已有的用户activity。 3.把一个用户activity传递到另一台设备。 需要注意的是Handoff相关的测试只能在真实设备上进行，所以你得有至少两台运行着iOS 8.0或以上系统的设备。不管是多台iPhone，多台iPad或者同时拥有iPhone和iPad都可以。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS面试题23--通知与推送]]></title>
    <url>%2F2018%2F09%2F12%2FiOS%E9%9D%A2%E8%AF%95%E9%A2%9823-%E9%80%9A%E7%9F%A5%E4%B8%8E%E6%8E%A8%E9%80%81%2F</url>
    <content type="text"><![CDATA[本地通知和远程推送通知对基本概念和用法？image 本地通知和远程推送通知都可以向不在前台运行的应用发送消息,这种消息既可能是即将发生的事件,也可能是服务器的新数据.不管是本地通知还是远程通知,他们在程序界面的显示效果相同,都可能显示为一段警告信息或应用程序图标上的微章. 本地通知和远程推送通知的基本目的都是让应用程序能够通知用户某些事情, 而且不需要应用程序在前台运行.二者的区别在于本地通知由本应用负责调用,只能从当前设备上的iOS发出, 而远程通知由远程服务器上的程序发送到APNS,再由APNS把消息推送至设备上的程序 iOS允许最近本地通知数最大是多少（c）A.16 B.32 C.64 D.128 把程序自己关掉和程序进入后台,远程推送的区别 关掉后不执行任何代码, 不能处理事件 应用程序进入后台状态不久后转入挂起状态。在这种状态下，应用程序不执行任何代码，并有可能在任意时候从内存中删除。只有当用户再次运行此应用，应用才会从挂起状态唤醒，代码得以继续执行 或者进入后台时开启多任务状态，保留在内存中，这样就可以执行系统允许的动作 远程推送是由远程服务器上的程序发送到APNS,再由APNS把消息推送至设备上的程序,当应用程序收到推送的消息会自动调用特定的方法执行事先写好的代码 本地通知和远程推送通知对基本概念和用法？ 本地通知和远程推送通知都可以向不在前台运行的应用发送消息,这种消息既可能是即将发生的事件,也可能是服务器的新数据.不管是本地通知还是远程通知,他们在程序界面的显示效果相同,都可能显示为一段警告信息或应用程序图标上的微章. 本地通知和远程推送通知的基本目的都是让应用程序能够通知用户某些事情, 而且不需要应用程序在前台运行.二者的区别在于本地通知由本应用负责调用,只能从当前设备上的iOS发出, 而远程通知由远程服务器上的程序发送到APNS,再由APNS把消息推送至设备上的程序 Push Notification 是如何工作的？ 推送通知分为两种,一个是本地推送,一个是远程推送 本地推送:不需要联网也可以推送,是开发人员在APP内设定特定的时间来提醒用户干什么 远程推送:需要联网,用户的设备会于苹果APNS服务器形成一个长连接,用户设备会发送uuid和Bundle idenidentifier给苹果服务器,苹果服务器会加密生成一个deviceToken给用户设备,然后设备会将deviceToken发送给APP的服务器,服务器会将deviceToken存进他们的数据库,这时候如果有人发送消息给我,服务器端就会去查询我的deviceToken,然后将deviceToken和要发送的信息发送给苹果服务器,苹果服务器通过deviceToken找到我的设备并将消息推送到我的设备上,这里还有个情况是如果APP在线,那么APP服务器会于APP产生一个长连接,这时候APPF服务器会直接通过deviceToken将消息推送到设备上 为什么 NotificationCenter 要 removeObserver? 如何实现自动 remove? 如果不移除的话,万一注册通知的类被销毁以后又发了通知,程序会崩溃.因为向野指针发送了消息 实现自动remove:通过自释放机制,通过动态属性将remove转移给第三者,解除耦合,达到自动实现remove 是否可以把比较耗时的操作放在NSNotificationCenter中 如果在异步线程发的通知，那么可以执行比较耗时的操作； 如果在主线程发的通知，那么就不可以执行比较耗时的操作]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS面试题22--性能优化]]></title>
    <url>%2F2018%2F09%2F12%2FiOS%E9%9D%A2%E8%AF%95%E9%A2%9822-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[文字是以前收集的，国外大牛写的，忘记原文链接了。 入门级 用ARC管理内存 在正确的地方使用 reuseIdentifier 尽量把views设置为透明 避免过于庞大的XIB 不要阻塞主线程 在Image Views中调整图片大小。如果要在UIImageView中显示一个来自bundle的图片，你应保证图片的大小和UIImageView的大小相同。在运行中缩放图片是很耗费资源的，特别是UIImageView嵌套在UIScrollView中的情况下。如果图片是从远端服务加载的你不能控制图片大小，比如在下载前调整到合适大小的话，你可以在下载完成后，最好是用background thread，缩放一次，然后在UIImageView中使用缩放后的图片。 选择正确的Collection。 Arrays: 有序的一组值。使用index来lookup很快，使用value lookup很慢， 插入/删除很慢。 Dictionaries: 存储键值对。 用键来查找比较快。 Sets: 无序的一组值。用值来查找很快，插入/删除很快。 打开gzip压缩。app可能大量依赖于服务器资源，问题是我们的目标是移动设备，因此你就不能指望网络状况有多好。减小文档的一个方式就是在服务端和你的app中打开gzip。这对于文字这种能有更高压缩率的数据来说会有更显著的效用。 iOS已经在NSURLConnection中默认支持了gzip压缩，当然AFNetworking这些基于它的框架亦然。 中级 重用和延迟加载(lazy load) Views 更多的view意味着更多的渲染，也就是更多的CPU和内存消耗，对于那种嵌套了很多view在UIScrollView里边的app更是如此。 这里我们用到的技巧就是模仿UITableView和UICollectionView的操作: 不要一次创建所有的subview，而是当需要时才创建，当它们完成了使命，把他们放进一个可重用的队列中。这样的话你就只需要在滚动发生时创建你的views，避免了不划算的内存分配。 Cache, Cache, 还是Cache! 一个极好的原则就是，缓存所需要的，也就是那些不大可能改变但是需要经常读取的东西。 我们能缓存些什么呢？一些选项是，远端服务器的响应，图片，甚至计算结果，比如UITableView的行高。 NSCache和NSDictionary类似，不同的是系统回收内存的时候它会自动删掉它的内容。 权衡渲染方法.性能能还是要bundle保持合适的大小。 处理内存警告.移除对缓存，图片object和其他一些可以重创建的objects的strong references. 重用大开销对象 一些objects的初始化很慢，比如NSDateFormatter和NSCalendar。然而，你又不可避免地需要使用它们，比如从JSON或者XML中解析数据。想要避免使用这个对象的瓶颈你就需要重用他们，可以通过添加属性到你的class里或者创建静态变量来实现。 避免反复处理数据.在服务器端和客户端使用相同的数据结构很重要。 选择正确的数据格式.解析JSON会比XML更快一些，JSON也通常更小更便于传输。从iOS5起有了官方内建的JSON deserialization 就更加方便使用了。但是XML也有XML的好处，比如使用SAX 来解析XML就像解析本地文件一样，你不需像解析json一样等到整个文档下载完成才开始解析。当你处理很大的数据的时候就会极大地减低内存消耗和增加性能。 正确设定背景图片 全屏背景图，在view中添加一个UIImageView作为一个子View 只是某个小的view的背景图，你就需要用UIColor的colorWithPatternImage来做了，它会更快地渲染也不会花费很多内存： 减少使用Web特性。想要更高的性能你就要调整下你的HTML了。第一件要做的事就是尽可能移除不必要的javascript，避免使用过大的框架。能只用原生js就更好了。尽可能异步加载例如用户行为统计script这种不影响页面表达的javascript。注意你使用的图片，保证图片的符合你使用的大小。 Shadow Path 。Core Animation不得不先在后台得出你的图形并加好阴影然后才渲染，这开销是很大的。使用shadowPath的话就避免了这个问题。使用shadow path的话iOS就不必每次都计算如何渲染，它使用一个预先计算好的路径。但问题是自己计算path的话可能在某些View中比较困难，且每当view的frame变化的时候你都需要去update shadow path. 优化Table View 正确使用reuseIdentifier来重用cells 尽量使所有的view opaque，包括cell自身 避免渐变，图片缩放，后台选人 缓存行高 如果cell内现实的内容来自web，使用异步加载，缓存请求结果 使用shadowPath来画阴影 减少subviews的数量 尽量不适用cellForRowAtIndexPath:，如果你需要用到它，只用一次然后缓存结果 使用正确的数据结构来存储数据 使用rowHeight, sectionFooterHeight 和 sectionHeaderHeight来设定固定的高，不要请求delegate 选择正确的数据存储选项 NSUserDefaults的问题是什么？虽然它很nice也很便捷，但是它只适用于小数据，比如一些简单的布尔型的设置选项，再大点你就要考虑其它方式了 XML这种结构化档案呢？总体来说，你需要读取整个文件到内存里去解析，这样是很不经济的。使用SAX又是一个很麻烦的事情。 NSCoding？不幸的是，它也需要读写文件，所以也有以上问题。 在这种应用场景下，使用SQLite 或者 Core Data比较好。使用这些技术你用特定的查询语句就能只加载你需要的对象。 在性能层面来讲，SQLite和Core Data是很相似的。他们的不同在于具体使用方法。 Core Data代表一个对象的graph model，但SQLite就是一个DBMS。 Apple在一般情况下建议使用Core Data，但是如果你有理由不使用它，那么就去使用更加底层的SQLite吧。 如果你使用SQLite，你可以用FMDB这个库来简化SQLite的操作，这样你就不用花很多经历了解SQLite的C API了。 高级 加速启动时间。快速打开app是很重要的，特别是用户第一次打开它时，对app来讲，第一印象太太太重要了。你能做的就是使它尽可能做更多的异步任务，比如加载远端或者数据库数据，解析数据。避免过于庞大的XIB，因为他们是在主线程上加载的。所以尽量使用没有这个问题的Storyboards吧！一定要把设备从Xcode断开来测试启动速度 使用Autorelease Pool。NSAutoreleasePool`负责释放block中的autoreleased objects。一般情况下它会自动被UIKit调用。但是有些状况下你也需要手动去创建它。假如你创建很多临时对象，你会发现内存一直在减少直到这些对象被release的时候。这是因为只有当UIKit用光了autorelease pool的时候memory才会被释放。消息是你可以在你自己的@autoreleasepool里创建临时的对象来避免这个行为。 选择是否缓存图片。常见的从bundle中加载图片的方式有两种，一个是用imageNamed，二是用imageWithContentsOfFile，第一种比较常见一点。 避免日期格式转换。如果你要用NSDateFormatter来处理很多日期格式，应该小心以待。就像先前提到的，任何时候重用NSDateFormatters都是一个好的实践。如果你可以控制你所处理的日期格式，尽量选择Unix时间戳。你可以方便地从时间戳转换到NSDate: - (NSDate*)dateFromUnixTimestamp:(NSTimeInterval)timestamp { return[NSDate dateWithTimeIntervalSince1970:timestamp]; } 这样会比用C来解析日期字符串还快！需要注意的是，许多web API会以微秒的形式返回时间戳，因为这种格式在javascript中更方便使用。记住用dateFromUnixTimestamp之前除以1000就好了。 平时你是如何对代码进行性能优化的？ 利用性能分析工具检测，包括静态 Analyze 工具，以及运行时 Profile 工具，通过Xcode工具栏中Product-&gt;Profile可以启动,启动后界面如下: image 比如测试程序启动运行时间，当点击Time Profiler应用程序开始运行后.就能获取到整个应用程序运行消耗时间分布和百分比.为了保证数据分析在统一使用场景真实需要注意一定要使用真机,因为此时模拟器是运行在Mac上，而Mac上的CPU往往比iOS设备要快。 为了防止一个应用占用过多的系统资源，开发iOS的苹果工程师门设计了一个“看门狗”的机制。在不同的场景下，“看门狗”会监测应用的性能。如果超出了该场景所规定的运行时间，“看门狗”就会强制终结这个应用的进程。开发者们在crashlog里面，会看到诸如0x8badf00d这样的错误代码。 优化Table View 正确使用reuseIdentifier来重用cells 尽量使所有的view opaque，包括cell自身 如果cell内现实的内容来自web，使用异步加载，缓存请求结果 减少subviews的数量 尽量不适用cellForRowAtIndexPath:，如果你需要用到它，只用一次然后缓存结果 使用rowHeight, sectionFooterHeight和 sectionHeaderHeight来设定固定的高，不要请求delegate UIImage加载图片性能问题 imagedNamed初始化 imageWithContentsOfFile初始化 imageNamed默认加载图片成功后会内存中缓存图片,这个方法用一个指定的名字在系统缓存中查找并返回一个图片对象.如果缓存中没有找到相应的图片对象,则从指定地方加载图片然后缓存对象，并返回这个图片对象. imageWithContentsOfFile则仅只加载图片,不缓存. 加载一张大图并且使用一次，用imageWithContentsOfFile是最好,这样CPU不需要做缓存节约时间. 使用场景需要编程时，应该根据实际应用场景加以区分，UIimage虽小，但使用元素较多问题会有所凸显. 不要在viewWillAppear 中做费时的操作：viewWillAppear: 在view显示之前被调用，出于效率考虑，方法中不要处理复杂费时操作；在该方法设置 view 的显示属性之类的简单事情，比如背景色，字体等。否则，会明显感觉到 view 有卡顿或者延迟。 在正确的地方使用reuseIdentifier：table view用 tableView:cellForRowAtIndexPath:为rows分配cells的时候，它的数据应该重用自UITableViewCell。 尽量把views设置为透明：如果你有透明的Views你应该设置它们的opaque属性为YES。系统用一个最优的方式渲染这些views。这个简单的属性在IB或者代码里都可以设定。 避免过于庞大的XIB：尽量简单的为每个Controller配置一个单独的XIB，尽可能把一个View Controller的view层次结构分散到单独的XIB中去, 当你加载一个引用了图片或者声音资源的nib时，nib加载代码会把图片和声音文件写进内存。 不要阻塞主线程：永远不要使主线程承担过多。因为UIKit在主线程上做所有工作，渲染，管理触摸反应，回应输入等都需要在它上面完成,大部分阻碍主进程的情形是你的app在做一些牵涉到读写外部资源的I/O操作，比如存储或者网络。 dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ // 选择一个子线程来执行耗时操作 dispatch_async(dispatch_get_main_queue(), ^{ // 返回主线程更新UI }); }); 在Image Views中调整图片大小 如果要在UIImageView中显示一个来自bundle的图片，你应保证图片的大小和UIImageView的大小相同。在运行中缩放图片是很耗费资源的. 讲讲你用Instrument优化动画性能的经历吧（别问我什么是Instrument）Apple的instrument为开发者提供了各种template去优化app性能和定位问题。很多公司都在赶feature，并没有充足的时间来做优化，导致不少开发者对instrument不怎么熟悉。但这里面其实涵盖了非常完整的计算机基础理论知识体系，memory，disk，network，thread，cpu，gpu等等，顺藤摸瓜去学习，是一笔巨大的知识财富。动画性能只是其中一个template，重点还是理解上面问题当中CPU GPU如何配合工作的知识。 facebook启动时间优化1.瘦身请求依赖 2.UDP启动请求先行缓存 3.队列串行化处理启动响应]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS面试题21--Runtime]]></title>
    <url>%2F2018%2F09%2F12%2FiOS%E9%9D%A2%E8%AF%95%E9%A2%9821-Runtime%2F</url>
    <content type="text"><![CDATA[Runtime是什么Runtime 又叫运行时，是一套底层的 C 语言 API，其为 iOS 内部的核心之一，我们平时编写的 OC 代码，底层都是基于它来实现的。比如： [receiver message]; // 底层运行时会被编译器转化为： objc_msgSend(receiver, selector) // 如果其还有参数比如： [receiver message:(id)arg...]; // 底层运行时会被编译器转化为： objc_msgSend(receiver, selector, arg1, arg2, ...) 为什么需要Runtime Objective-C 是一门动态语言，它会将一些工作放在代码运行时才处理而并非编译时。也就是说，有很多类和成员变量在我们编译的时是不知道的，而在运行时，我们所编写的代码会转换成完整的确定的代码运行。 因此，编译器是不够的，我们还需要一个运行时系统(Runtime system)来处理编译后的代码。 Runtime 基本是用 C 和汇编写的，由此可见苹果为了动态系统的高效而做出的努力。苹果和 GNU 各自维护一个开源的 Runtime 版本，这两个版本之间都在努力保持一致。 Runtime 的作用OC 在三种层面上与 Runtime 系统进行交互： 1.通过 Objective-C 源代码 只需要编写 OC 代码，Runtime 系统自动在幕后搞定一切，调用方法，编译器会将 OC 代码转换成运行时代码，在运行时确定数据结构和函数。 2.通过 Foundation 框架的 NSObject 类定义的方法 Cocoa 程序中绝大部分类都是 NSObject 类的子类，所以都继承了 NSObject 的行为。(NSProxy 类时个例外，它是个抽象超类) 一些情况下，NSObject 类仅仅定义了完成某件事情的模板，并没有提供所需要的代码。例如 - description方法，该方法返回类内容的字符串表示，该方法主要用来调试程序。NSObject类并不知道子类的内容，所以它只是返回类的名字和对象的地址，NSObject的子类可以重新实现。 还有一些NSObject的方法可以从Runtime系统中获取信息，允许对象进行自我检查。例如： -class方法返回对象的类； -isKindOfClass: 和 -isMemberOfClass: 方法检查对象是否存在于指定的类的继承体系中(是否是其子类或者父类或者当前类的成员变量)； -respondsToSelector: 检查对象能否响应指定的消息； -conformsToProtocol:检查对象是否实现了指定协议类的方法； -methodForSelector: 返回指定方法实现的地址。 3.通过对 Runtime 库函数的直接调用 Runtime 系统是具有公共接口的动态共享库。头文件存放于/usr/include/objc目录下，这意味着我们使用时只需要引入objc/Runtime.h头文件即可。 许多函数可以让你使用纯 C 代码来实现 Objc 中同样的功能。除非是写一些 Objc 与其他语言的桥接或是底层的 debug 工作，你在写 Objc 代码时一般不会用到这些 C 语言函数。 Runtime的相关术语1.SEL 它是selector在 Objc 中的表示(Swift 中是 Selector 类)。selector 是方法选择器，其实作用就和名字一样，日常生活中，我们通过人名辨别谁是谁，注意 Objc 在相同的类中不会有命名相同的两个方法。selector 对方法名进行包装，以便找到对应的方法实现。它的数据结构是： typedef struct objc_selector *SEL; 我们可以看出它是个映射到方法的 C 字符串，你可以通过 Objc 编译器器命令@selector() 或者 Runtime 系统的 sel_registerName 函数来获取一个 SEL 类型的方法选择器。 注意：不同类中相同名字的方法所对应的 selector 是相同的，由于变量的类型不同，所以不会导致它们调用方法实现混乱。 2.id id 是一个参数类型，它是指向某个类的实例的指针。定义如下： typedef struct objc_object *id; struct objc_object { Class isa; }; 以上定义，看到 objc_object 结构体包含一个 isa 指针，根据 isa 指针就可以找到对象所属的类。 注意：isa 指针在代码运行时并不总指向实例对象所属的类型，所以不能依靠它来确定类型，要想确定类型还是需要用对象的 -class 方法。PS:KVO 的实现机理就是将被观察对象的 isa 指针指向一个中间类而不是真实类型。 3.Class typedef struct objc_class *Class; Class 其实是指向 objc_class 结构体的指针。objc_class 的数据结构如下： struct objc_class { Class isa OBJC_ISA_AVAILABILITY; #if !__OBJC2__ Class super_class OBJC2_UNAVAILABLE; const char *name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list *ivars OBJC2_UNAVAILABLE; struct objc_method_list **methodLists OBJC2_UNAVAILABLE; struct objc_cache *cache OBJC2_UNAVAILABLE; struct objc_protocol_list *protocols OBJC2_UNAVAILABLE; #endif } OBJC2_UNAVAILABLE; 从 objc_class 可以看到，一个运行时类中关联了它的父类指针、类名、成员变量、方法、缓存以及附属的协议。 其中 objc_ivar_list 和 objc_method_list 分别是成员变量列表和方法列表： // 成员变量列表 struct objc_ivar_list { int ivar_count OBJC2_UNAVAILABLE; #ifdef __LP64__ int space OBJC2_UNAVAILABLE; #endif /* variable length structure */ struct objc_ivar ivar_list[1] OBJC2_UNAVAILABLE; } OBJC2_UNAVAILABLE; // 方法列表 struct objc_method_list { struct objc_method_list *obsolete OBJC2_UNAVAILABLE; int method_count OBJC2_UNAVAILABLE; #ifdef __LP64__ int space OBJC2_UNAVAILABLE; #endif /* variable length structure */ struct objc_method method_list[1] OBJC2_UNAVAILABLE; } 由此可见，我们可以动态修改 *methodList 的值来添加成员方法，这也是 Category 实现的原理，同样解释了 Category 不能添加属性的原因。 objc_ivar_list 结构体用来存储成员变量的列表，而 objc_ivar 则是存储了单个成员变量的信息；同理，objc_method_list 结构体存储着方法数组的列表，而单个方法的信息则由 objc_method 结构体存储。 值得注意的时，objc_class 中也有一个 isa 指针，这说明 Objc 类本身也是一个对象。为了处理类和对象的关系，Runtime 库创建了一种叫做 Meta Class(元类) 的东西，类对象所属的类就叫做元类。Meta Class 表述了类对象本身所具备的元数据。 我们所熟悉的类方法，就源自于 Meta Class。我们可以理解为类方法就是类对象的实例方法。每个类仅有一个类对象，而每个类对象仅有一个与之相关的元类。 当你发出一个类似 [NSObject alloc](类方法) 的消息时，实际上，这个消息被发送给了一个类对象(Class Object)，这个类对象必须是一个元类的实例，而这个元类同时也是一个根元类(Root Meta Class)的实例。所有元类的 isa 指针最终都指向根元类。 所以当 [NSObject alloc] 这条消息发送给类对象的时候，运行时代码 objc_msgSend() 会去它元类中查找能够响应消息的方法实现，如果找到了，就会对这个类对象执行方法调用。 最后 objc_class 中还有一个 objc_cache ，缓存，它的作用很重要，后面会提到。 4.Method Method 代表类中某个方法的类型 typedef struct objc_method *Method; struct objc_method { SEL method_name OBJC2_UNAVAILABLE; char *method_types OBJC2_UNAVAILABLE; IMP method_imp OBJC2_UNAVAILABLE; } objc_method 存储了方法名，方法类型和方法实现： 方法名类型为 SEL 方法类型 method_types 是个 char 指针，存储方法的参数类型和返回值类型 method_imp 指向了方法的实现，本质是一个函数指针 Ivar Ivar 是表示成员变量的类型。 typedef struct objc_ivar *Ivar; struct objc_ivar { char *ivar_name OBJC2_UNAVAILABLE; char *ivar_type OBJC2_UNAVAILABLE; int ivar_offset OBJC2_UNAVAILABLE; #ifdef __LP64__ int space OBJC2_UNAVAILABLE; #endif } 其中 ivar_offset 是基地址偏移字节 5.IMP IMP在objc.h中的定义是： typedef id (*IMP)(id, SEL, ...); 它就是一个函数指针，这是由编译器生成的。当你发起一个 ObjC 消息之后，最终它会执行的那段代码，就是由这个函数指针指定的。而 IMP 这个函数指针就指向了这个方法的实现。 如果得到了执行某个实例某个方法的入口，我们就可以绕开消息传递阶段，直接执行方法，这在后面 Cache 中会提到。 你会发现 IMP 指向的方法与 objc_msgSend 函数类型相同，参数都包含 id 和 SEL 类型。每个方法名都对应一个 SEL 类型的方法选择器，而每个实例对象中的 SEL 对应的方法实现肯定是唯一的，通过一组 id和 SEL 参数就能确定唯一的方法实现地址。 而一个确定的方法也只有唯一的一组 id 和 SEL 参数。 6.Cache Cache 定义如下： typedef struct objc_cache *Cache struct objc_cache { unsigned int mask /* total = mask + 1 */ OBJC2_UNAVAILABLE; unsigned int occupied OBJC2_UNAVAILABLE; Method buckets[1] OBJC2_UNAVAILABLE; }; Cache 为方法调用的性能进行优化，每当实例对象接收到一个消息时，它不会直接在 isa 指针指向的类的方法列表中遍历查找能够响应的方法，因为每次都要查找效率太低了，而是优先在 Cache 中查找。 Runtime 系统会把被调用的方法存到 Cache 中，如果一个方法被调用，那么它有可能今后还会被调用，下次查找的时候就会效率更高。就像计算机组成原理中 CPU 绕过主存先访问 Cache 一样。 7.Property typedef struct objc_property *Property; typedef struct objc_property *objc_property_t;//这个更常用 可以通过class_copyPropertyList 和 protocol_copyPropertyList 方法获取类和协议中的属性： objc_property_t *class_copyPropertyList(Class cls, unsigned int *outCount) objc_property_t *protocol_copyPropertyList(Protocol *proto, unsigned int *outCount) 注意： 返回的是属性列表，列表中每个元素都是一个 objc_property_t 指针 #import &lt;Foundation/Foundation.h&gt; @interface Person : NSObject /** 姓名 */ @property (strong, nonatomic) NSString *name; /** age */ @property (assign, nonatomic) int age; /** weight */ @property (assign, nonatomic) double weight; @end 以上是一个 Person 类，有3个属性。让我们用上述方法获取类的运行时属性。 unsigned int outCount = 0; objc_property_t *properties = class_copyPropertyList([Person class], &amp;outCount); NSLog(@&quot;%d&quot;, outCount); for (NSInteger i = 0; i &lt; outCount; i++) { NSString *name = @(property_getName(properties[i])); NSString *attributes = @(property_getAttributes(properties[i])); NSLog(@&quot;%@--------%@&quot;, name, attributes); } 打印结果如下： test[2321:451525] 3 test[2321:451525] name--------T@&quot;NSString&quot;,&amp;,N,V_name test[2321:451525] age--------Ti,N,V_age test[2321:451525] weight--------Td,N,V_weight property_getName 用来查找属性的名称，返回 c 字符串。property_getAttributes 函数挖掘属性的真实名称和 @encode 类型，返回 c 字符串。 objc_property_t class_getProperty(Class cls, const char *name) objc_property_t protocol_getProperty(Protocol *proto, const char *name, BOOL isRequiredProperty, BOOL isInstanceProperty) class_getProperty 和 protocol_getProperty 通过给出属性名在类和协议中获得属性的引用。 Runtime与消息 一些 Runtime 术语讲完了，接下来就要说到消息了。体会苹果官方文档中的 messages aren’t bound to method implementations until Runtime。消息直到运行时才会与方法实现进行绑定。 这里要清楚一点，objc_msgSend 方法看清来好像返回了数据，其实objc_msgSend 从不返回数据，而是你的方法在运行时实现被调用后才会返回数据。下面详细叙述消息发送的步骤： 首先检测这个 selector 是不是要忽略。比如 Mac OS X 开发，有了垃圾回收就不理会 retain，release 这些函数。 检测这个 selector 的 target 是不是 nil，Objc 允许我们对一个 nil 对象执行任何方法不会 Crash，因为运行时会被忽略掉。 如果上面两步都通过了，那么就开始查找这个类的实现 IMP，先从 cache 里查找，如果找到了就运行对应的函数去执行相应的代码。 如果 cache 找不到就找类的方法列表中是否有对应的方法。 如果类的方法列表中找不到就到父类的方法列表中查找，一直找到 NSObject 类为止。 如果还找不到，就要开始进入动态方法解析了，后面会提到。 在消息的传递中，编译器会根据情况在 objc_msgSend ， objc_msgSend_stret ， objc_msgSendSuper ， objc_msgSendSuper_stret 这四个方法中选择一个调用。如果消息是传递给父类，那么会调用名字带有 Super 的函数，如果消息返回值是数据结构而不是简单值时，会调用名字带有 stret 的函数。 方法中的隐藏参数疑问： 我们经常用到关键字 self ，但是 self 是如何获取当前方法的对象呢？ 其实，这也是 Runtime 系统的作用，self 实在方法运行时被动态传入的。 当 objc_msgSend 找到方法对应实现时，它将直接调用该方法实现，并将消息中所有参数都传递给方法实现，同时，它还将传递两个隐藏参数： 接受消息的对象(self 所指向的内容，当前方法的对象指针) 方法选择器(_cmd 指向的内容，当前方法的 SEL 指针) 因为在源代码方法的定义中，我们并没有发现这两个参数的声明。它们时在代码被编译时被插入方法实现中的。尽管这些参数没有被明确声明，在源代码中我们仍然可以引用它们。 这两个参数中， self更实用。它是在方法实现中访问消息接收者对象的实例变量的途径。 这时我们可能会想到另一个关键字 super ，实际上 super 关键字接收到消息时，编译器会创建一个 objc_super 结构体： struct objc_super { id receiver; Class class; }; 这个结构体指明了消息应该被传递给特定的父类。 receiver 仍然是 self 本身，当我们想通过 [super class] 获取父类时，编译器其实是将指向 self 的 id 指针和 class 的 SEL 传递给了 objc_msgSendSuper 函数。只有在 NSObject 类中才能找到 class 方法，然后 class 方法底层被转换为 object_getClass()， 接着底层编译器将代码转换为 objc_msgSend(objc_super-&gt;receiver, @selector(class))，传入的第一个参数是指向 self 的 id 指针，与调用 [self class] 相同，所以我们得到的永远都是 self 的类型。因此你会发现： // 这句话并不能获取父类的类型，只能获取当前类的类型名 NSLog(@&quot;%@&quot;, NSStringFromClass([super class])); 获取方法地址 NSObject 类中有一个实例方法：methodForSelector，你可以用它来获取某个方法选择器对应的 IMP ，举个例子： void (*setter)(id, SEL, BOOL); int i; setter = (void (*)(id, SEL, BOOL))[target methodForSelector:@selector(setFilled:)]; for ( i = 0 ; i &lt; 1000 ; i++ ) setter(targetList[i], @selector(setFilled:), YES); 当方法被当做函数调用时，两个隐藏参数也必须明确给出，上面的例子调用了1000次函数，你也可以尝试给 target 发送1000次 setFilled: 消息会花多久。 虽然可以更高效的调用方法，但是这种做法很少用，除非时需要持续大量重复调用某个方法的情况，才会选择使用以免消息发送泛滥。 注意： methodForSelector:方法是由 Runtime 系统提供的，而不是 Objc 自身的特性 动态方法解析 你可以动态提供一个方法实现。如果我们使用关键字 @dynamic 在类的实现文件中修饰一个属性，表明我们会为这个属性动态提供存取方法，编译器不会再默认为我们生成这个属性的 setter 和 getter 方法了，需要我们自己提供。 @dynamic propertyName; 这时，我们可以通过分别重载 resolveInstanceMethod: 和 resolveClassMethod: 方法添加实例方法实现和类方法实现。 当 Runtime 系统在 Cache 和类的方法列表(包括父类)中找不到要执行的方法时，Runtime 会调用 resolveInstanceMethod: 或 resolveClassMethod: 来给我们一次动态添加方法实现的机会。我们需要用 class_addMethod 函数完成向特定类添加特定方法实现的操作： void dynamicMethodIMP(id self, SEL _cmd) { // implementation .... } @implementation MyClass + (BOOL)resolveInstanceMethod:(SEL)aSEL { if (aSEL == @selector(resolveThisMethodDynamically)) { class_addMethod([self class], aSEL, (IMP) dynamicMethodIMP, &quot;v@:&quot;); return YES; } return [super resolveInstanceMethod:aSEL]; } @end 上面的例子为 resolveThisMethodDynamically 方法添加了实现内容，就是 dynamicMethodIMP 方法中的代码。其中 &quot;v@:&quot; 表示返回值和参数，这个符号表示的含义见：Type Encoding 注意： 动态方法解析会在消息转发机制侵入前执行，动态方法解析器将会首先给予提供该方法选择器对应的 IMP 的机会。如果你想让该方法选择器被传送到转发机制，就让 resolveInstanceMethod: 方法返回 NO。 消息转发1.重定向 消息转发机制执行前，Runtime 系统允许我们替换消息的接收者为其他对象。通过 - (id)forwardingTargetForSelector:(SEL)aSelector 方法。 - (id)forwardingTargetForSelector:(SEL)aSelector { if(aSelector == @selector(mysteriousMethod:)){ return alternateObject; } return [super forwardingTargetForSelector:aSelector]; } 如果此方法返回 nil 或者 self，则会计入消息转发机制(forwardInvocation:)，否则将向返回的对象重新发送消息。 2.转发 当动态方法解析不做处理返回 NO 时，则会触发消息转发机制。这时 forwardInvocation: 方法会被执行，我们可以重写这个方法来自定义我们的转发逻辑： - (void)forwardInvocation:(NSInvocation *)anInvocation { if ([someOtherObject respondsToSelector: [anInvocation selector]]) [anInvocation invokeWithTarget:someOtherObject]; else [super forwardInvocation:anInvocation]; } 唯一参数是个 NSInvocation 类型的对象，该对象封装了原始的消息和消息的参数。我们可以实现 forwardInvocation: 方法来对不能处理的消息做一些处理。也可以将消息转发给其他对象处理，而不抛出错误。 注意：参数 anInvocation 是从哪来的？ 在 forwardInvocation: 消息发送前，Runtime 系统会向对象发送methodSignatureForSelector: 消息，并取到返回的方法签名用于生成 NSInvocation 对象。所以重写 forwardInvocation: 的同时也要重写 methodSignatureForSelector: 方法，否则会抛异常。 当一个对象由于没有相应的方法实现而无法相应某消息时，运行时系统将通过 forwardInvocation: 消息通知该对象。每个对象都继承了 forwardInvocation: 方法。但是， NSObject 中的方法实现只是简单的调用了 doesNotRecognizeSelector:。通过实现自己的 forwardInvocation: 方法，我们可以将消息转发给其他对象。 forwardInvocation: 方法就是一个不能识别消息的分发中心，将这些不能识别的消息转发给不同的接收对象，或者转发给同一个对象，再或者将消息翻译成另外的消息，亦或者简单的“吃掉”某些消息，因此没有响应也不会报错。这一切都取决于方法的具体实现。 注意： forwardInvocation:方法只有在消息接收对象中无法正常响应消息时才会被调用。所以，如果我们向往一个对象将一个消息转发给其他对象时，要确保这个对象不能有该消息的所对应的方法。否则，forwardInvocation:将不可能被调用。 转发和多继承 转发和继承相似，可用于为 Objc 编程添加一些多继承的效果。就像下图那样，一个对象把消息转发出去，就好像它把另一个对象中的方法接过来或者“继承”过来一样。 这使得在不同继承体系分支下的两个类可以实现“继承”对方的方法，在上图中 Warrior 和 Diplomat 没有继承关系，但是 Warrior 将 negotiate 消息转发给了 Diplomat 后，就好似 Diplomat 是 Warrior 的超类一样。 消息转发弥补了 Objc 不支持多继承的性质，也避免了因为多继承导致单个类变得臃肿复杂。 转发与继承虽然转发可以实现继承的功能，但是 NSObject 还是必须表面上很严谨，像 respondsToSelector: 和 isKindOfClass: 这类方法只会考虑继承体系，不会考虑转发链。 Warrior 对象被问到是否能响应 negotiate消息： if ( [aWarrior respondsToSelector:@selector(negotiate)] ) ... 回答当然是 NO， 尽管它能接受 negotiate 消息而不报错，因为它靠转发消息给 Diplomat 类响应消息。 如果你就是想要让别人以为 Warrior 继承到了 Diplomat 的 negotiate 方法，你得重新实现 respondsToSelector: 和 isKindOfClass: 来加入你的转发算法： - (BOOL)respondsToSelector:(SEL)aSelector { if ( [super respondsToSelector:aSelector] ) return YES; else { /* Here, test whether the aSelector message can * * be forwarded to another object and whether that * * object can respond to it. Return YES if it can. */ } return NO; } 除了 respondsToSelector: 和 isKindOfClass: 之外，instancesRespondToSelector: 中也应该写一份转发算法。如果使用了协议，conformsToProtocol: 同样也要加入到这一行列中。 如果一个对象想要转发它接受的任何远程消息，它得给出一个方法标签来返回准确的方法描述 methodSignatureForSelector:，这个方法会最终响应被转发的消息。从而生成一个确定的 NSInvocation 对象描述消息和消息参数。这个方法最终响应被转发的消息。它需要像下面这样实现： - (NSMethodSignature*)methodSignatureForSelector:(SEL)selector { NSMethodSignature* signature = [super methodSignatureForSelector:selector]; if (!signature) { signature = [surrogate methodSignatureForSelector:selector]; } return signature; } 健壮的实例变量(Non Fragile ivars)在 Runtime 的现行版本中，最大的特点就是健壮的实例变量了。当一个类被编译时，实例变量的内存布局就形成了，它表明访问类的实例变量的位置。实例变量一次根据自己所占空间而产生位移： 上图左是 NSObject 类的实例变量布局。右边是我们写的类的布局。这样子有一个很大的缺陷，就是缺乏拓展性。哪天苹果更新了 NSObject 类的话，就会出现问题： 我们自定义的类的区域和父类的区域重叠了。只有苹果将父类改为以前的布局才能拯救我们，但这样导致它们不能再拓展它们的框架了，因为成员变量布局被固定住了。在脆弱的实例变量(Fragile ivar)环境下，需要我们重新编译继承自 Apple 的类来恢复兼容。如果是健壮的实例变量的话，如下图： 在健壮的实例变量下，编译器生成的实例变量布局跟以前一样，但是当 Runtime 系统检测到与父类有部分重叠时它会调整你新添加的实例变量的位移，那样你再子类中新添加的成员变量就被保护起来了。 注意： 在健壮的实例变量下，不要使用 siof(SomeClass)，而是用 class_getInstanceSize([SomeClass class]) 代替；也不要使用 offsetof(SomeClass, SomeIvar)，而要使用 ivar_getOffset(class_getInstanceVariable([SomeClass class], &quot;SomeIvar&quot;)) 来代替。 总结 我们让自己的类继承自 NSObject 不仅仅是因为基类有很多复杂的内存分配问题，更是因为这使得我们可以享受到 Runtime 系统带来的便利。 虽然平时我们很少会考虑一句简单的调用方法，发送消息底层所做的复杂的操作，但深入理解 Runtime 系统的细节使得我们可以利用消息机制写出功能更强大的代码。 runtime实现的机制是什么,怎么用，一般用于干嘛. 你还能记得你所使用的相关的头文件或者某些方法的名称吗？ 需要导入&lt;objc/message.h&gt;&lt;objc/runtime.h&gt; runtime，运行时机制，它是一套C语言库 实际上我们编写的所有OC代码，最终都是转成了runtime库的东西，比如类转成了runtime库里面的结构体等数据类型，方法转成了runtime库里面的C语言函数，平时调方法都是转成了objc_msgSend函数（所以说OC有个消息发送机制） 因此，可以说runtime是OC的底层实现，是OC的幕后执行者 有了runtime库，能做什么事情呢？runtime库里面包含了跟类、成员变量、方法相关的API，比如获取类里面的所有成员变量，为类动态添加成员变量，动态改变类的方法实现，为类动态添加新的方法等 因此，有了runtime，想怎么改就怎么改 Objective-C 如何对已有的方法，添加自己的功能代码以实现类似记录日志这样的功能？这题目主要考察的是runtime如何交换方法。先在分类中添加一个方法,注意不能重写系统方法,会覆盖 +(NSString *)myLog { // 这里写打印行号,什么方法,哪个类调用等等 } // 加载分类到内存的时候调用 +(void)load { // 获取imageWithName方法地址 Method description = class_getClassMethod(self, @selector(description)); // 获取imageWithName方法地址 Method myLog = class_getClassMethod(self, @selector(myLog)); // 交换方法地址，相当于交换实现方式 method_exchangeImplementations(description, myLog); } 如何让 Category 支持属性？使用runtime可以实现 头文件 @interface NSObject (test) @property (nonatomic, copy) NSString *name; @end .m文件 @implementation NSObject (test) // 定义关联的key static const char *key = &quot;name&quot;; -(NSString *)name { // 根据关联的key，获取关联的值。 return objc_getAssociatedObject(self, key); } -(void)setName:(NSString *)name { // 第一个参数：给哪个对象添加关联 // 第二个参数：关联的key，通过这个key获取 // 第三个参数：关联的value // 第四个参数:关联的策略 objc_setAssociatedObject(self, key, name, OBJC_ASSOCIATION_RETAIN_NONATOMIC); } Toll-Free Bridging 是什么？什么情况下会使用？ Toll-Free Bridging用于在Foundation对象与Core Foundation对象之间交换数据,俗称桥接 在ARC环境下,Foundation对象转成 Core Foundation对象 使用__bridge桥接以后ARC会自动管理2个对象 使用__bridge_retained桥接需要手动释放Core Foundation对象 在ARC环境下, Core Foundation对象转成 Foundation对象 使用__bridge桥接,如果Core Foundation对象被释放,Foundation对象也同时不能使用了,需要手动管理Core Foundation对象 使用__bridge_transfer桥接,系统会自动管理2个对象 performSelector:withObject:afterDelay: 内部大概是怎么实现的，有什么注意事项么？ 创建一个定时器,时间结束后系统会使用runtime通过方法名称(Selector本质就是方法名称)去方法列表中找到对应的方法实现并调用方法 注意事项 调用performSelector:withObject:afterDelay:方法时,先判断希望调用的方法是否存在respondsToSelector: 这个方法是异步方法,必须在主线程调用,在子线程调用永远不会调用到想调用的方法 什么是 Method Swizzle（黑魔法），什么情况下会使用？ 在没有一个类的实现源码的情况下，想改变其中一个方法的实现，除了继承它重写、和借助类别重名方法暴力抢先之外，还有更加灵活的方法Method Swizzle。 Method swizzling指的是改变一个已存在的选择器对应的实现的过程。OC中方法的调用能够在运行时通过改变——通过改变类的调度表（dispatch table）中选择器到最终函数间的映射关系。 在OC中调用一个方法，其实是向一个对象发送消息，查找消息的唯一依据是selector的名字。利用OC的动态特性，可以实现在运行时偷换selector对应的方法实现。 每个类都有一个方法列表，存放着selector的名字和方法实现的映射关系。IMP有点类似函数指针，指向具体的Method实现。 我们可以利用 method_exchangeImplementations 来交换2个方法中的IMP， 我们可以利用 class_replaceMethod 来修改类， 我们可以利用 method_setImplementation 来直接设置某个方法的IMP， 归根结底，都是偷换了selector的IMP 能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？- 不能向编译后得到的类中增加实例变量； - 能向运行时创建的类中添加实例变量； 解释如下： 因为编译后的类已经注册在 runtime 中，类结构体中的 objc_ivar_list 实例变量的链表 和 instance_size 实例变量的内存大小已经确定，同时runtime 会调用 class_setIvarLayout 或 class_setWeakIvarLayout 来处理 strong weak 引用。所以不能向存在的类中添加实例变量； 运行时创建的类是可以添加实例变量，调用 class_addIvar 函数。但是得在调用 objc_allocateClassPair 之后，objc_registerClassPair 之前，原因同上。 为什么其他语言里叫函数调用， objective c里则是给对象发消息（或者谈下对runtime的理解）先来看看怎么理解发送消息的含义： [receiver message]会被编译器转化为： objc_msgSend(receiver, selector) 如果消息含有参数，则为： objc_msgSend(receiver, selector, arg1, arg2, ...) 如果消息的接收者能够找到对应的selector，那么就相当于直接执行了接收者这个对象的特定方法；否则，消息要么被转发，或是临时向接收者动态添加这个selector对应的实现内容，要么就干脆玩完崩溃掉。 现在可以看出[receiver message]真的不是一个简简单单的方法调用。因为这只是在编译阶段确定了要向接收者发送message这条消息，而receive将要如何响应这条消息，那就要看运行时发生的情况来决定了。 OC 的 Runtime 铸就了它动态语言的特性，Objc Runtime使得C具有了面向对象能力，在程序运行时创建，检查，修改类、对象和它们的方法。可以使用runtime的一系列方法实现。 顺便附上OC中一个类的数据结构 /usr/include/objc/runtime.h struct objc_class { Class isa OBJC_ISA_AVAILABILITY; //isa指针指向Meta Class，因为Objc的类的本身也是一个Object，为了处理这个关系，runtime就创造了Meta Class，当给类发送[NSObject alloc]这样消息时，实际上是把这个消息发给了Class Object #if !__OBJC2__ Class super_class OBJC2_UNAVAILABLE; // 父类 const char *name OBJC2_UNAVAILABLE; // 类名 long version OBJC2_UNAVAILABLE; // 类的版本信息，默认为0 long info OBJC2_UNAVAILABLE; // 类信息，供运行期使用的一些位标识 long instance_size OBJC2_UNAVAILABLE; // 该类的实例变量大小 struct objc_ivar_list *ivars OBJC2_UNAVAILABLE; // 该类的成员变量链表 struct objc_method_list **methodLists OBJC2_UNAVAILABLE; // 方法定义的链表 struct objc_cache *cache OBJC2_UNAVAILABLE; // 方法缓存，对象接到一个消息会根据isa指针查找消息对象，这时会在method Lists中遍历，如果cache了，常用的方法调用时就能够提高调用的效率。 struct objc_protocol_list *protocols OBJC2_UNAVAILABLE; // 协议链表 #endif } OBJC2_UNAVAILABLE; OC中一个类的对象实例的数据结构（/usr/include/objc/objc.h）: typedef struct objc_class *Class; /// Represents an instance of a class. struct objc_object { Class isa OBJC_ISA_AVAILABILITY; }; /// A pointer to an instance of a class. typedef struct objc_object *id; 向object发送消息时，Runtime库会根据object的isa指针找到这个实例object所属于的类，然后在类的方法列表以及父类方法列表寻找对应的方法运行。id是一个objc_object结构类型的指针，这个类型的对象能够转换成任何一种对象。 然后再来看看消息发送的函数：objc_msgSend函数 在引言中已经对objc_msgSend进行了一点介绍，看起来像是objc_msgSend返回了数据，其实objc_msgSend从不返回数据而是你的方法被调用后返回了数据。下面详细叙述下消息发送步骤： 检测这个 selector 是不是要忽略的。比如 Mac OS X 开发，有了垃圾回收就不理会 retain,release 这些函数了。 检测这个 target 是不是 nil 对象。ObjC 的特性是允许对一个 nil 对象执行任何一个方法不会 Crash，因为会被忽略掉。 如果上面两个都过了，那就开始查找这个类的 IMP，先从 cache 里面找，完了找得到就跳到对应的函数去执行。 如果 cache 找不到就找一下方法分发表。 如果分发表找不到就到超类的分发表去找，一直找，直到找到NSObject类为止。 如果还找不到就要开始进入动态方法解析了，后面会提到。 后面还有： 动态方法解析resolveThisMethodDynamically 消息转发forwardingTargetForSelector runtime如何实现weak属性？• 通过关联属性来实现： • // 声明一个weak属性，这里假设delegate，其实weak关键字可以不使用， • // 因为我们重写了getter/setter方法 • @property (nonatomic, weak) id delegate; • • - (id)delegate { • return objc_getAssociatedObject(self, @&quot;__delegate__key&quot;); • } • • // 指定使用OBJC_ASSOCIATION_ASSIGN，官方注释是： • // Specifies a weak reference to the associated object. • // 也就是说对于对象类型，就是weak了 • - (void)setDelegate:(id)delegate { • objc_setAssociatedObject(self, @&quot;__delegate__key&quot;, delegate, OBJC_ASSOCIATION_ASSIGN); • } • 通过objc_storeWeak函数来实现，不过这种方式几乎没有遇到有人这么使用过，因为这里不细说了。 runtime如何通过selector找到对应的IMP地址？ 每个selector都与对应的IMP是一一对应的关系，通过selector就可以直接找到对应的IMP： objc_msgForward函数是做什么的，直接调用它将会发生什么？_objc_msgForward是IMP类型，用于消息转发的：当向一个对象发送一条消息，但它并没有实现的时候，_objc_msgForward会尝试做消息转发。 IMP msgForward = _objc_msgForward; 如果手动调用objcmsgForward，将跳过查找IMP的过程，而是直接触发“消息转发”，进入如下流程： • 第一步：+ (BOOL)resolveInstanceMethod:(SEL)sel实现方法，指定是否动态添加方法。若返回NO，则进入下一步，若返回YES，则通过class_addMethod函数动态地添加方法，消息得到处理，此流程完毕。 • 第二步：在第一步返回的是NO时，就会进入- (id)forwardingTargetForSelector:(SEL)aSelector方法，这是运行时给我们的第二次机会，用于指定哪个对象响应这个selector。不能指定为self。若返回nil，表示没有响应者，则会进入第三步。若返回某个对象，则会调用该对象的方法。 • 第三步：若第二步返回的是nil，则我们首先要通过- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector指定方法签名，若返回nil，则表示不处理。若返回方法签名，则会进入下一步。 • 第四步：当第三步返回方法方法签名后，就会调用- (void)forwardInvocation:(NSInvocation *)anInvocation方法，我们可以通过anInvocation对象做很多处理，比如修改实现方法，修改响应对象等 • 第五步：若没有实现- (void)forwardInvocation:(NSInvocation *)anInvocation方法，那么会进入- (void)doesNotRecognizeSelector:(SEL)aSelector方法。若我们没有实现这个方法，那么就会crash，然后提示打不到响应的方法。到此，动态解析的流程就结束了。 runtime如何实现weak变量的自动置nil？runtime对注册的类会进行布局，对于weak对象会放入一个hash表中。 用weak指向的对象内存地址作为key，当此对象的引用计数为0的时候会dealloc。假如weak指向的对象内存地址是a，那么就会以a为键，在这个 weak 表中搜索，找到所有以a为键的weak对象，从而设置为nil。 weak修饰的指针默认值是nil（在Objective-C中向nil发送消息是安全的） 动态绑定 在运行时确定要调用的方法,动态绑定将调用方法的确定也推迟到运行时。在编译时，方法的调用并不和代码绑定在一起，只有在消实发送出来之后，才确定被调用的代码。通过动态类型和动态绑定技术，代码每次执行都可以得到不同的结果。运行时因子负责确定消息的接收者和被调用的方法。运行时的消息分发机制为动态绑定提供支持。当向一个动态类型确定了的对象发送消息时，运行环境系统会通过接收者的isa指针定位对象的类，并以此为起点确定被调用的方法，方法和消息是动态绑定的。而且，不必在Objective-C 代码中做任何工作，就可以自动获取动态绑定的好处。在每次发送消息时，特别是当消息的接收者是动态类型已经确定的对象时，动态绑定就会例行而透明地发生]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS面试题20--安全机制]]></title>
    <url>%2F2018%2F09%2F12%2FiOS%E9%9D%A2%E8%AF%95%E9%A2%9820-%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[苹果的安全机制有哪些 没经过用户同意，你不能随便获取用户信息。 所有的程序都在沙盒里运行，B程序不能进入A程序的运行范围。 如果跟钱有关，比如说支付宝，这些底层的实现都是保密的，只提供接口供开发者调用，这样的话安全性得到保障。 如果要防止代码被反编译，可以将自己的代码中的.m文件封装成静态库（.a文件）或者是framework文件，只提供给其它人.h文件。这样就保证了个人代码的安全性。 网络登录的话跟用户名跟密码相关要发送POST请求，如果是GET请求的话密码会直接在URL中显示。然后同时要对帐号密码采用加密技术，加一句：我们公司用的是MD5，但是现在MD5有一个专门的网站来破解，为了防止这个，可以采用加盐技术。 iOS 的签名机制大概是怎样的？ 假设，我们有一个APP需要发布，为了防止中途篡改APP内容，保证APP的完整性，以及APP是由指定的私钥发的。首先，先将APP内容通过摘要算法，得到摘要，再用私钥对摘要进行加密得到密文，将源文本、密文、和私钥对应的公钥一并发布即可。 那么如何验证呢？ 验证方首先查看公钥是否是私钥方的，然后用公钥对密文进行解密得到摘要，将APP用同样的摘要算法得到摘要，两个摘要进行比对，如果相等那么一切正常。这个过程只要有一步出问题就视为无效。 客户端安全性处理方式？1&gt; 网络数据传输(敏感数据[账号\密码\消费数据\银行卡账号], 不能明文发送) 2&gt; 协议的问题(自定义协议, 游戏代练) 3&gt; 本地文件存储(游戏的存档) 4&gt; 源代码(混淆) 如何进行数据加密?常见的加密算法:MD5 \ SHA \ DES \ 3DES \ RC2和RC4 \ RSA \ IDEA \ DSA \ AES 加密算法的选择:一般公司都会有一套自己的加密方案，按照公司接口文档的规定去加密 MD5的特点: （1）输入两个不同的明文不会得到相同的输出值 （2）根据输出值，不能得到原始的明文，即其过程不可逆 现在的MD5已不再是绝对安全，对此，可以对MD5稍作改进，以增加解密的难度 加盐（Salt）：在明文的固定位置插入随机串，然后再进行MD5 先加密，后乱序：先对明文进行MD5，然后对加密得到的MD5串的字符进行乱序 总之宗旨就是：黑客就算攻破了数据库，也无法解密出正确的明文]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS面试题19--设计模式]]></title>
    <url>%2F2018%2F09%2F12%2FiOS%E9%9D%A2%E8%AF%95%E9%A2%9819-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[从设计模式的角度分析Delegate、Notification、KVO的区别三者优缺点： delegate的优势： 1.非常严格的语法。所有将听到的事件必须是在delegate协议中有清晰的定义。 2.如果delegate中的一个方法没有实现那么就会出现编译警告/错误 3.协议必须在controller的作用域范围内定义 4.在一个应用中的控制流程是可跟踪的并且是可识别的； 5.在一个控制器中可以定义定义多个不同的协议，每个协议有不同的delegates 6.没有第三方对象要求保持/监视通信过程。 7.能够接收调用的协议方法的返回值。这意味着delegate能够提供反馈信息给controller 8.经常被用在存在父子关系的对象之间通信，例如控制器和控制器的view（自己加的理解） 缺点： 1.需要定义很多代码：1.协议定义；2.controller的delegate属性；3.在delegate本身中实现delegate方法定义 2.在释放代理对象时，需要小心的将delegate改为nil。一旦设定失败，那么调用释放对象的方法将会出现内存crash 3.在一个controller中有多个delegate对象，并且delegate是遵守同一个协议，但还是很难告诉多个对象同一个事件，不过有可能。 4.经常用在一对一的通信。（不知道是缺点还是优点，只能算是特点）（自己加的理解） notification的优势： 1.不需要编写多少代码，实现比较简单 2.对于一个发出的通知，多个对象能够做出反应，即一对多的方式实现简单 3.controller能够传递context对象（dictionary），context对象携带了关于发送通知的自定义的信息 缺点： 1.在编译期不会检查通知是否能够被观察者正确的处理； 2.在释放注册的对象时，需要在通知中心取消注册； 3.在调试的时候应用的工作以及控制过程难跟踪； 4.需要第三方对象来管理controller与观察者对象之间的联系； 5.controller和观察者需要提前知道通知名称、UserInfo dictionary keys。如果这些没有在工作区间定义，那么会出现不同步的情况； 6.通知发出后，controller不能从观察者获得任何的反馈信息（相比较delegate）。 KVO的优势： 1.能够提供一种简单的方法实现两个对象间的同步。例如：model和view之间同步； 2.能够对非我们创建的对象，即内部对象的状态改变作出响应，而且不需要改变内部对象（SKD对象）的实现； 3.能够提供观察的属性的最新值以及先前值； 4.用key paths来观察属性，因此也可以观察嵌套对象； 5.完成了对观察对象的抽象，因为不需要额外的代码来允许观察值能够被观察 6.可以一对多。 缺点： 1.我们观察的属性必须使用strings来定义。因此在编译器不会出现警告以及检查； 2.对属性重构将导致我们的观察代码不再可用； 3.复杂的“IF”语句要求对象正在观察多个值。这是因为所有的观察代码通过一个方法来指向； 4.当释放观察者时不需要移除观察者。 效率 肯定是delegate比NSNotification高。 delegate方法比notification更加直接，最典型的特征是，delegate方法往往需要关注返回值， 也就是delegate方法的结果。比如-windowShouldClose:，需要关心返回的是yes还是no。所以delegate方法往往包含 should这个很传神的词。也就是好比你做我的delegate，我会问你我想关闭窗口你愿意吗？你需要给我一个答案，我根据你的答案来决定如何做下一 步。相反的，notification最大的特色就是不关心接受者的态度， 我只管把通告放出来，你接受不接受就是你的事情，同时我也不关心结果。所以notification往往用did这个词汇，比如 NSWindowDidResizeNotification，那么NSWindow对象放出这个notification后就什么都不管了也不会等待接 受者的反应。 2、KVO和NSNotification的区别 ： 和delegate一样，KVO和NSNotification的作用也是类与类之间的通信，与delegate不同的是1）这两个都是负责发出通知，剩下的事情就不管了，所以没有返回值；2）delegate只是一对一，而这两个可以一对多。这两者也有各自的特点。 总结： 从上面的分析中可以看出3中设计模式都有各自的优点和缺点。在这三种模式中，我认为KVO有最清晰的使用案例，而且针对某个需求有清晰的实用性。而另外两种模式有比较相似的用处，并且经常用来给controller间进行通信。那么我们在什么情况使用其中之一呢？ 根据我开发iOS应用的经历，我发现有些过分的使用通知模式。我个人不是很喜欢使用通知中心。我发现用通知中心很难把握应用的执行流程。Userlnfo dictionaries的keys到处传递导致失去了同步，而且在公共空间需要定义太多的常量。对于一个工作于现有的项目的开发者来说，如果过分的使用通知中心，那么很难理解应用的流程。 我觉得使用命名规则好的协议和协议方法定义对于清晰的理解controllers间的通信是很容易的。努力的定义这些协议方法将增强代码的可读性，以及更好的跟踪你的app。代理协议发生改变以及实现都可通过编译器检查出来，如果没有将会在开发的过程中至少会出现crash，而不仅仅是让一些事情异常工作。甚至在同一事件通知多控制器的场景中，只要你的应用在controller层次有着良好的结构，消息将在该层次上传递。该层次能够向后传递直至让所有需要知道事件的controllers都知道。当然会有delegation模式不适合的例外情况出现，而且notification可能更加有效。例如：应用中所有的controller需要知道一个事件。然而这些类型的场景很少出现。另外一个例子是当你建立了一个架构而且需要通知该事件给正在运行中应用。 根据经验，如果是属性层的事件，不管是在不需要编程的对象还是在紧紧绑定一个view对象的model对象，我只使用观察。对于其他的事件，我都会使用delegate模式。如果因为某种原因我不能使用delegate，首先我将估计我的app架构是否出现了严重的错误。如果没有错误，然后才使用notification。 什么是设计模式 设计模式是为特定场景下的问题而定制的解决方案。特定场景指问题所在的重复出现的场景，问题指特定环境下你想达成的目标。同样的问题在不同的环境下会有不同的限制和挑战。定制的解决方案是指在特定环境下克服了问题的限制条件而达成目标的一种设计。 设计模式的分类 设计模式分为三种类型，共23种。 创建型模式：单例模式、抽象工厂模式、建造者模式、工厂模式、原型模式。 结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。 行为型模式：模版方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式（Interpreter模式）、状态模式、策略模式、职责链模式(责任链模式)、访问者模式。 类工厂方法是什么？ 类工厂方法的实现是为了向客户提供方便，它们将分配和初始化合在一个步骤中， 返回被创建的对象，并 进行自动释放处理。 这些方法的形式是+ (type)className…（其中 className不包括任何前缀）。 工厂方法可能不仅仅为了方便使用。它们不但可以将分配和初始化合在一起，还可以为初始化过程提供对 象的分配信息。 类工厂方法的另一个目的是使类（比如NSWorkspace）提供单例。虽 然init…方法可以确认一 个类在每次程序运行过程只存在一个实例，但它需要首先分配一个“生的”实例，然后还必须释放该实例。工厂方法则可以避免为可能没有用的对象盲目分配内存。 单例是什么？单例模式的意思就是只有一个实例。单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。这个类称为单例类。 单例模式的要点： 显然单例模式的要点有三个；一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。 单例模式的优点： 实例控制：Singleton 会阻止其他对象实例化其自己的 Singleton 对象的副本，从而确保所有对象都访问唯一实例。 灵活性：因为类控制了实例化过程，所以类可以更加灵活修改实例化过程 手写一下单例方法(或者单例模式的设计：GCD 方式和同步锁方式的区别在哪里？unlock 呢？GCD 是怎么保证单例的？)image 简要描述观察者模式，并运用此模式编写一段代码？ 观察者模式（Observer）是指一个或多个对象对另一个对象进行观察，当被观察对象发生变化时，观察者可以直接或间接地得到通知，从而能自动地更新观察者的数据，或者进行一些操作。 具体到iOS的开发中，实现观察者模式常用的方式有KVO和Notification两种。 两者的不同在于，KVO是被观察者主动向观察者发送消息；Notification是被观察者向NotificationCenter发送消息，再由NotificationCenter post通知到每个注册的观察者。 谈谈你对MVC的理解?为什么要用MVC?在Cocoa中MVC是怎么实现的?你还熟悉其他的OC设计模式或别的设计模式吗? MVC就是Model-View-Controller的缩写,M指的是业务模型,V指的是用户页面,C指的是控制器。MVC是架构模式,是讲M和V的代码分离,从而使同那个一个程序可以使用不同的表现形式。 单例,代理,观察者,工厂模式等 单例模式:上面有详细说明 代理模式:代理模式给某一个对象提供一个代理对象,并由代理对象控制对源对象的引用.比如一个工厂生产了产品,并不想直接卖给用户,而是搞了很多代理商,用户可以直接找代理商买东西,代理商从工厂进货.常见的如QQ的自动回复就属于代理拦截,代理模式在iphone中得到广泛应用. MVC优点不正确的是A 低耦合性 B 高重用性和可适用性 C 较低的生命周期成本 D 代码高效率 参考答案：D 理由：MVC只是一种设计模式，它的出现有比较久的历史了。Model-Controller-View是在开发中最常见到的设计模式，通过将Model、View、Controller三者相互联系，以Model作为数据加工厂，以Controller作为桥梁，处理业务，而View只是数据展示层，理应与业务无关。MVC设计模式降低了耦合性，提供了重用性和适用性，可有效地提高开发效率。 如何理解MVVM框架，它的优点和缺点在哪？运用此框架编写一段代码，建议采用ReactiveCocoa库实现； MVVM框架相对于传统的MVC来说，主要区别在于把原本在C中（ViewController）的业务逻辑、网络请求、数据存储等操作和表现逻辑，分离到ViewModel中，从而使ViewController得到精简 MVC中，Controller同时操作Model和View；MVVM中，ViewModel作为一个过渡，Model的数据获取和加工由ViewModel负责，得到适合View的数据，利用绑定机制，使得View得以自动更新。 优点： 层次更加分明清晰 代码简洁优雅 减少VC的复杂性 代码和界面完全分离 方便测试 缺点： MVVM需要使用数据绑定机制，对于OS X 开发，可以直接使用Coocoa Binding，对于iOS，没有太好的数据绑定方法，可以使用KVO，但如果需要绑定的属性太多的话，需要编写大量的selector代码。 ReactiveCocoa提供了一种很方便优雅的绑定机制。 ReactiveCocoa RAC具有函数式编程和响应式编程的特性 试图解决以下问题 传统iOS开发过程中，状态以及状态之间依赖过多的问题 传统MVC架构的问题：Controller比较复杂，可测试性差 提供统一的消息传递机制 哪些途径可以让 ViewController 瘦下来？ 把 Data Source 和其他 Protocols 分离出来(将UITableView或者UICollectionView的代码提取出来放在其他类中) 将业务逻辑移到 Model 中(和模型有关的逻辑全部在model中写) 把网络请求逻辑移到 Model 层(网络请求依靠模型) 把 View 代码移到 View 层(自定义View) 你在你的项目中用到了哪些设计模式？项目中使用了很多的设计模式，我相信面试官最好听到的不仅仅是设计模式的名字，更想听到的是这些设计模式在项目中如何应用。因此，笔者认为这个问题隐式地说明了应该回答设计模式及其在项目中的应用。 参考答案： • 单例设计模式：在项目中，单例是必不可少的。比如UIApplication、NSUserDefaults就是苹果提供的单例。在项目中经常会将用户数据管理封装成一个单例类，因此用户的信息需要全局使用。 • MVC设计模式：现在绝大部分项目都是基于MVC设计模式的，现在有一部分开发者采用MVVM、MVP等模式。 • 通知(NSNotification)模式：通知在开发中是必不可少的，对于跨模块的类交互，需要使用通知；对于多对多的关系，使用通知更好实现。 • 工厂设计模式：在我的项目中使用了大量的工厂设计模式，特别是生成控件的API，都已经封装成一套，全部是扩展的类方法，可简化很多的代码。 • KVC/KVO设计模式：有的时候需要监听某个类的属性值的变化而做出相应的改变，这时候会使用KVC/KVO设计模式。在项目中，我需要监听model中的某个属性值的变化，当变化时，需要更新UI显示，这时候使用KVC/KVO设计模式就很方便了。 就说这么多吧，还有很多的设计模式，不过其它并不是那么常用。 如何实现单例，单例会有什么弊端？单例在项目中的是必不可少的，它可以使我们全局都可共享我们的数据。这只是简单的问题，大家根据自己的情况回答。 参考答案： • 首先，单例写法有好几种，通常的写法是基于线程安全的写法，结合dispatch_once来使用，保证单例对象只会被创建一次。如果不小心销毁了单例，再调用单例生成方法是不会再创建的。 • 其次，由于单例是约定俗成的，因此在实际开发中通常不会去重写内存管理方法。 单例确实给我们带来的便利，但是它也会有代价的。单例一旦创建，整个App使用过程都不会释放，这会占用内存，因此不可滥用单例。 你在你的项目中用到了哪些设计模式？ 设计模式有很多,面试官肯定不想听你把项目里的设计模式名字报给他,他想听得肯定是你是怎么去用这些设计模式的 参考答案: MVC:这个设计模型大部分应用应该都在用,介绍下MVC就好 单例:单例在项目中用的还是蛮多的,像登录界面,对一些第三方框架二次封装等等 KVC/KVO:这个用的应该也很多,KVC用来替换掉系统的tabbar,用KVO来监听偏移量来完成下拉刷新,改变导航条背景颜色这些 工厂方法:这个用的更多了,设置一些自定义View肯定要用到这个设计模式 如何实现单例，单例会有什么弊端？ 这个问题还是蛮简单的,说下单例是怎么写的,单例的缺点就好 参考答案: // OC版 +(instancetype)sharedInstance { static id sharedInstance = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ sharedInstance = [[self alloc] init]; }); return sharedInstance; } // Swift版 static let sharedInstance : &lt;#SingletonClass#&gt; = &lt;#SingletonClass#&gt;() 单例的缺点也就是会一直占着这块内存,不会被释放 单例书写 伪单例 1、 获取单例对象的方法 + (DataHandle *)sharedDataHandle; // 创建单例对象的方法。类方法 命名规则： shared + 类名 2、 方法的实现 // 因为实例是全局的 因此要定义为全局变量，且需要存储在静态区，不释放。不能存储在栈区。 static DataHandle *handle = nil; // 伪单例 和 完整的单例。 以及线程的安全。 // 一般使用伪单例就足够了 每次都用 sharedDataHandle 创建对象。 + (DataHandle *)sharedDataHandle { // 添加同步锁，一次只能一个线程访问。如果有多个线程访问，等待。一个访问结束后下一个。 @synchronized(self){ if (nil == handle) { handle = [[DataHadle alloc] init]; } } return handle; } 完整单例 完整的单例 完整的单例要求比较高，不仅要求我们通过方法获取的对象是单例，如果有 对该对象进行copy mutableCopy copyWithZone 等操作时，也是同一份对象。这就要求我们必须重写这些方法，在这些方法内部做一些操作。 完整的单例要做到四个方面： 为单例对象实现一个静态实例,然后设置成nil， 构造方法检查静态实例是否为nil，是则新建并返回一个实例， 重写allocWithZone方法，用来保证其他人直接使用alloc和init试图获得一个新实例的时候不会产生一个新实例， 适当实现copyWithZone，,retain,retainCount,release和autorelease 等方法 1、 获取单例对象的方法 + (DataHandle *)sharedDataHandle; // 创建单例对象的方法。类方法 命名规则： shared + 类名 2、 方法的实现 @synchronized(self){ if (nil == handle) { handle = [[super allocWithZone:nil] init]; // 避免死循环 // 如果 在单例类里面重写了 allocWithZone 方法 ，在创建单例对象时 使用 [[DataHandle alloc] init] 创建，会死循环。 } } return handle; 3、 重写 allocWithZone copy mutableCopy copyWithZone 防止外界拷贝造成多个实例， 保证实例的唯一性。 注意：如果自己重写了 allocWithZone 就不要再调用自身的 alloc 方法，否则会出现死循环。 + (instancetype)allocWithZone:(struct _NSZone *)zone { return [DataHandle sharedDataHandle]; } - (id)copy { return self; } - (id)mutableCopy { return self; } + (id)copyWithZone:(struct _NSZone *)zone { return self; } 4、 重写 alloc retain release autorelease retainCount + (instancetype)alloc { return [DataHandle sharedDataHandle]; } // 因为只有一个实例， 一直不释放，所以不增加引用计数。无意义。 - (instancetype)retain { return self; } - (oneway void)release { // nothing } - (instancetype)autorelease { return self; } - (NSUInteger)retainCount { return NSUIntegerMax; // 返回整形最大值。 }]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS面试题18--多媒体]]></title>
    <url>%2F2018%2F09%2F12%2FiOS%E9%9D%A2%E8%AF%95%E9%A2%9818-%E5%A4%9A%E5%AA%92%E4%BD%93%2F</url>
    <content type="text"><![CDATA[iPhone OS主要提供了几种播放音频的方法？SystemSound Services AVAudioPlayer 类 Audio Queue Services OpenAL 使用AVAudioPlayer类调用哪个框架、使用步骤？AVFoundation.framework 步骤：配置 AVAudioPlayer 对象； 实现 AVAudioPlayer 类的委托方法； 控制 AVAudioPlayer 类的对象； 监控音量水平； 回放进度和拖拽播放。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS面试题17--多线程]]></title>
    <url>%2F2018%2F09%2F12%2FiOS%E9%9D%A2%E8%AF%95%E9%A2%9817-%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[你们项目中为什么多线程用GCD而不用NSOperation呢? 你有没有发现国外的大牛他们多线程都是用NSOperation? 你能告诉我他们这样做的理由吗?关系: ①:先搞清两者的关系,NSOpertaionQueue用GCD构建封装的，是GCD的高级抽象! ②:GCD仅仅支持FIFO队列，而NSOperationQueue中的队列可以被重新设置优先级，从而实现不同操作的执行顺序调整。GCD不支持异步操作之间的依赖关系设置。如果某个操作的依赖另一个操作的数据（生产者-消费者模型是其中之一），使用NSOperationQueue能够按照正确的顺序执行操作。GCD则没有内建的依赖关系支持。 ③:NSOperationQueue支持KVO，意味着我们可以观察任务的执行状态。 了解以上不同，我们可以从以下角度来回答 性能:①:GCD更接近底层，而NSOperationQueue则更高级抽象，所以GCD在追求性能的底层操作来说，是速度最快的。这取决于使用Instruments进行代码性能分析，如有必要的话 ②:从异步操作之间的事务性，顺序行，依赖关系。GCD需要自己写更多的代码来实现，而NSOperationQueue已经内建了这些支持 ③:如果异步操作的过程需要更多的被交互和UI呈现出来，NSOperationQueue会是一个更好的选择。底层代码中，任务之间不太互相依赖，而需要更高的并发能力，GCD则更有优势 最后的一句话:别忘了高德纳的教诲：“在大概97%的时间里，我们应该忘记微小的性能提升。过早优化是万恶之源。”只有Instruments显示有真正的性能提升时才有必要用低级的GCD。 详解GCD死锁unix上进程怎么通信？ UNIX主要支持三种通信方式： 基本通信：主要用来协调进程间的同步和互斥 锁文件通信:通信的双方通过查找特定目录下特定类型的文件(称锁文件)来完成进程间 对临界资源访问时的互斥；例如进程p1访问一个临界资源，首先查看是否有一个特定类型文件，若有，则等待一段时间再查找锁文件。 记录锁文件 管道通信：适应大批量的数据传递 IPC ：适应大批量的数据传递 列举几种进程的同步机制、进程的通信途径、死锁及死锁的处理方法。 进程的同步机制原子操作 信号量机制 自旋锁 管程，会合，分布式系统 进程之间通信的途径：共享存储系统消息传递系统管道：以文件系统为基础 进程死锁的原因：资源竞争及进程推进顺序非法 死锁的4个必要条件：互斥、请求保持、不可剥夺、环路 死锁的处理：鸵鸟策略、预防策略、避免策略、检测与解除死锁 线程与进程的区别和联系? 线程是进程的基本单位。 进程和线程都是由操作系统所产生的程序运行的基本单元,系统利用该基本单元实现系统对应用的并发性。 进程和线程的主要差别在于它们是不同的操作系统资源管理方式。 进程有独立的地址空间,一个进程崩溃后,在保护模式下 不会对其它进程产生影响。 线程只是一个进程中的不同执行路径。 线程有自己的堆栈和局部变量,但线程之间没有单独的地址空间,一个线程死掉就等于整个进程死掉,所以多进程的程序要比多线程的程序健壮,但在进程切换时,耗费资源较大,效率要差一些。 但对于一些要求同时进行并且又要共享某些变量的并发操作,只能用线程,不能用进程。 iOS线程间怎么通信？ performSelector:onThread:withObject:waitUntilDone: NSMachPort (基本机制：A线程（父线程）创建NSMachPort对象，并加入A线程的runloop。当创建B线程（辅助线程）时，将创建的NSMachPort对象传递到主体入口点，B线程（辅助线程）就可以使用相同的端口对象将消息传回A线程（父线程）。) iOS多线程的底层实现？ 首先搞清楚什么是线程、什么是多线程 Mach是第一个以多线程方式处理任务的系统，因此多线程的底层实现机制是基于Mach的线程 开发中很少用Mach级的线程，因为Mach级的线程没有提供多线程的基本特征，线程之间是独立的 开发中实现多线程的方案 C语言的POSIX接口：#include &lt;pthread.h&gt; OC的NSThread C语言的GCD接口（性能最好，代码更精简） OC的NSOperation和NSOperationQueue（基于GCD） 谈谈多线程安全问题的几种解决方案?何为线程同步,如何实现的?分线程回调主线程方法是什么,有什么作用? 解决方案: 使用锁: 锁是线程编程同步工具的基础。锁可以让你很容易保护代码中一大块区域以便你可以确保代码的正确性。 使用POSIX互斥锁; 使用NSLock类; 使用@synchronized指令等。 回到主线程的方法: dispatch_async(dispatch_get_main_queue(), ^{ }); 作用: 主线程是显示UI界面,子线程多数是进行数据处理 使用atomic一定是线程安全的吗？不是的。 atomic原子操作，系统会为setter方法加锁。 具体使用 @synchronized(self){//code } nonatomic不会为setter方法加锁。 atomic：线程安全，需要消耗大量系统资源来为属性加锁 nonatomic：非线程安全，适合内存较小的移动设备 使用atomic并不能保证绝对的线程安全，对于要绝对保证线程安全的操作，还需要使用更高级的方式来处理，比如NSSpinLock、@syncronized等 谈谈你对多线程开发的理解(多线程的好处，多线程的作用)？ios中有几种实现多线程的方法？ 好处： 使用线程可以把占据时间长的程序中的任务放到后台去处理 用户界面可以更加吸引人，这样比如用户点击了一个按钮去触发某些事件的处理，可以弹出一个进度条来显示处理的进度 程序的运行效率可能提高 在一些等待的任务实现上如用户输入、文件读写和网络收发数据等，线程就比较有用了。 缺点： 如果有大量的线程,会影响性能,因为操作系统需要在它们之间切换。 更多的线程需要更多的内存空间。 线程的中止需要考虑其对程序运行的影响。 通常块模型数据是在多个线程间共享的，需要防止线程死锁情况的发生。 实现多线程的方法： NSObject的类方法 // -(void)performSelectornBackground/OnMainThread:(SEL)aSelector withObject:(id)arg NSThread NSOperation GCD OC中异步使用的哪种事件模型,iOS中异步实现机制 异步非阻塞 I/O（AIO） 详细谈谈GCD 推出的时间 iOS4 目的是用来取代NSThread（ios2.0推出）的，是 C语言框架，它能够自动利用更多CPU的核数，并且会自动管理线程的生命周期。 CGD的两个核心概念：任务， 队列 任务：记为在block中执行的代码。 队列：用来存放任务的。 注意事项： 队列 != 线程。队列中存放的任务最后都要由线程来执行!。队列的原则:先进先出,后进后出(FIFO/ First In First Out) 队列又分为四种种：1 串行队列 2 并发队列 3 主队列 4 全局队列 串行队列： 任务一个接一个的执行。 并发队列： 队列中的任务并发执行。 主队列： 跟主线程相关的队列，主队列里面的内容都会在主线程中执行（我们一般在主线程中刷新UI）。 全局队列： 一个特殊的并发队列。 并发队列与全局队列的区别： 并发队列有名称,可以跟踪错误。全局队列没有 在ARC中两个队列不需要考虑释放内存,但是在MRC中并发队列是创建出来的需要release操作，而全局队列只有一个不需要。 一般在开发过程中我们使用全局队列。 执行任务的两个函数 ‘同步’执行任务:dispatch_sync(&lt;#dispatch_queue_t queue#&gt;, &lt;#^(void)block#&gt;) ‘异步’执行任务:dispatch_async(dispatch_queue_t queue, &lt;#^(void)block#&gt;) “同步”和”异步”的区别: “同步”: 只能在’当前’线程中执行任务,不具备开启新线程的能力. “异步”: 可以在’新’的线程中执行任务,具备开启新线程的能力. 各个队列的执行效果： 串行队列同步执行，既在当前线程中顺序执行 串行队列异步执行，开辟一条新的线程，在该线程中顺序执行 并行队列同步执行，不开辟线程，在当前线程中顺序执行 并行队列异步执行，开辟多个新的线程，并且线程会重用，无序执行 主队列异步执行，不开辟新的线程，顺序执行 主队列同步执行，会造成死锁（’主线程’和’主队列’相互等待,卡住主线程） 线程间通讯：经典案例：子线程进行耗时操作（例如下载更新等）主线程进行UI刷新。 经典用法(子线程下载(耗时操作),主线程刷新UI): dispatch_async(dispatch_get_global_queue(0, 0), ^{ // 执行耗时的异步操作... dispatch_async(dispatch_get_main_queue(), ^{ // 回到主线程，执行UI刷新操作 延迟操作 调用 NSObject 方法:[self performSelector:@selector(run) withObject:nil afterDelay:2.0]; // 2秒后再调用self的run方法 GCD函数实现延时执行:dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{ // 2秒后执行这里的代码… 在哪个线程执行，跟队列类型有关 队列组的使用： 项目需求:首先:分别异步执行两个耗时操作;其次:等两次耗时操作都执行完毕后,再回到主线程执行操作.使用队列组(dispatch_group_t)快速,高效的实现上述需求. dispatch_group_t group = dispatch_group_create(); // 队列组 dispatch_queue_t queue = dispatch_get_global_queue(0, 0); // 全局并发队列 dispatch_group_async(group, queue, ^{// 异步执行操作1 // longTime1 }); dispatch_group_async(group, queue, ^{ // 异步执行操作2 // longTime2 }); dispatch_group_notify(group, dispatch_get_main_queue(), ^{ // 在主线程刷新数据 // reload Data }); GCD内部怎么实现的 iOS和OS X的核心是XNU内核，GCD是基于XNU内核实现的 GCD的API全部在libdispatch库中 GCD的底层实现主要有Dispatch Queue和Dispatch Source Dispatch Queue ：管理block(操作) Dispatch Source ：处理事件(MACH端口发送,MACH端口接收,检测与进程相关事件等10种事件) GCD的queue、main queue中执行的代码一定是在main thread么？• 对于queue中所执行的代码不一定在main thread中。如果queue是在主线程中创建的，那么所执行的代码就是在主线程中执行。如果是在子线程中创建的，那么就不会在main thread中执行。 • 对于main queue就是在主线程中的，因此一定会在主线程中执行。获取main queue就可以了，不需要我们创建，获取方式通过调用方法dispatchgetmain_queue来获取。 如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）使用Dispatch Group追加block到Global Group Queue,这些block如果全部执行完毕，就会执行Main Dispatch Queue中的结束处理的block。 dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, ); dispatch_group_t group = dispatch_group_create(); dispatch_group_async(group, queue, ^{ /*加载图片1 */ }); dispatch_group_async(group, queue, ^{ /*加载图片2 */ }); dispatch_group_async(group, queue, ^{ /*加载图片3 */ }); dispatch_group_notify(group, dispatch_get_main_queue(), ^{ // 合并图片 }); 有a、b、c、d 4个异步请求，如何判断a、b、c、d都完成执行？如果需要a、b、c、d顺序执行，该如何实现？1. 对于这四个异步请求，要判断都执行完成最简单的方式就是通过GCD的group来实现： 2. dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); 3. dispatch_group_t group = dispatch_group_create(); 4. dispatch_group_async(group, queue, ^{ /*任务a */ }); 5. dispatch_group_async(group, queue, ^{ /*任务b */ }); 6. dispatch_group_async(group, queue, ^{ /*任务c */ }); 7. dispatch_group_async(group, queue, ^{ /*任务d */ }); 8. 9. dispatch_group_notify(group, dispatch_get_main_queue(), ^{ 10. // 在a、b、c、d异步执行完成后，会回调这里 11. }); 当然，我们还可以使用非常老套的方法来处理，通过四个变量来标识a、b、c、d四个任务是否完成，然后在runloop中让其等待，当完成时才退出run loop。但是这样做会让后面的代码得不到执行，直到Run loop执行完毕。 要求顺序执行，那么可以将任务放到串行队列中，自然就是按顺序来异步执行了 发送10个网络请求，然后再接收到所有回应之后执行后续操作，如何实现？从题目分析可知，10个请求要全部完成后，才执行某一功能。比如，下载10图片后合成一张大图，就需要异步全部下载完成后，才能合并成大图。 做法：通过dispatch_group_t来实现，将每个请求放入到Group中，将合并成大图的操作放在dispatch_group_notify中实现。 dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); dispatch_group_t group = dispatch_group_create(); dispatch_group_async(group, queue, ^{ /*加载图片1 */ }); dispatch_group_async(group, queue, ^{ /*加载图片2 */ }); dispatch_group_async(group, queue, ^{ /*加载图片3 */ }); dispatch_group_notify(group, dispatch_get_main_queue(), ^{ // 合并图片 }); 苹果为什么要废弃dispatch_get_current_queue？ dispatch_get_current_queue容易造成死锁。详情点击该API查看官方注释。 如果让你来实现 dispatch_once，你会怎么做？ http://www.dreamingwish.com/article/gcd-guide-dispatch-once-2.html（超级详细解析） 个人觉得说出实现的思路即可，无锁的线程同步编程，每一处的线程竞争都考虑到并妥善处理 线程A执行Block时，任何其它线程都需要等待。 线程A执行完Block应该立即标记任务完成状态，然后遍历信号量链来唤醒所有等待线程。 线程A遍历信号量链来signal时，任何其他新进入函数的线程都应该直接返回而无需等待。 线程A遍历信号量链来signal时，若有其它等待线程B仍在更新或试图更新信号量链，应该保证此线程B能正确完成其任务：a.直接返回 b.等待在信号量上并很快又被唤醒。 线程B构造信号量时，应该考虑线程A随时可能改变状态（“等待”、“完成”、“遍历信号量链”）。 线程B构造信号量时，应该考虑到另一个线程C也可能正在更新或试图更新信号量链，应该保证B、C都能正常完成其任务：a.增加链节并等待在信号量上 b.发现线程A已经标记“完成”然后直接销毁信号量并退出函数。 关于NSOperation: NSOperation: 抽象类,不能直接使用,需要使用其子类.(类似的类还有核心动画) 两个常用子类: NSInvocationOperation(调用) 和 NSBlockOperation(块); 两者没有本质区别,后者使用 Block 的形式组织代码,使用相对方便. NSInvocationOperation在调用start方法后，不会开启新的线程只会在当前线程中执行。 NSBlockOperation 在调用start方法后，如果封装的操作数&gt;1会开辟多条线程执行 =1 只会在当前线程执行. NSOperationQueue 创建的操作队列默认为全局队列，队列中的操作执行顺序是无序的，如果需要让它有序执行需要添加依赖关系。 // 操作op3依赖于操作op2 [op3 addDependency:op2]; // 操作op2依赖于操作op1 [op2 addDependency:op1]; 同时可以设置最大并发数 NSOperationQueue NSOperation支持 取消暂停的操作 但是正在进行的的操作并不能取消，这一旦取消不可恢复. NSOperationQueue支持KVO，可以监测operation是否正在执行（isExecuted）、是否结束（isFinished），是否取消（isCanceld） NSOperation queue? 存放NSOperation的集合类。不能说队列，不是严格的先进先出 NSOperation与GCD的区别 GCD GCD是iOS4.0推出的，主要针对多核cpu做了优化，是纯c语言的技术。 GCD是将任务（block）添加到队列（串行、并行、全局、主队列），并且以同步/异步的方式执行任务的函数。 GCD提供了一些NSOperation不具备的功能 一次性执行 延迟执行 调度组 GCD 是严格的队列，先进先出 FIFO； NSOperation NSOperation是iOS2.0推出的，iOS4.0以后又重写了NSOperation NSOperation是将操作（异步的任务）添加到队列（并发队列），就会执行指定的函数 NSOperation提供的方便操作 最大并发数 队列的暂停和继续 取消所有的操作 指定操作之间的依赖关系依赖关系，可以让异步任务同步执行. 将KVO用于NSOperation中，监听一个operation是否完成。 能够设置NSOperation的优先级，能够使同一个并行队列中的任务区分先后地执行 对NSOperation进行继承，在这之上添加成员变量与成员方法，提高整个代码的复用度 GCD与NSThread的区别 NSThread 通过 @selector 指定要执行的方法，代码分散 GCD 通过 block 指定要执行的代码，代码集中, 所有的代码写在一起的，让代码更加简单，易于阅读和维护 使用 GCD 不需要管理线程的创建/销毁/复用的过程！程序员不用关心线程的生命周期 如果要开多个线程 NSThread 必须实例化多个线程对象 NSThread 靠 NSObject 的分类方法实现的线程间通讯， 为什么要取消/恢复队列呢？ 一般在内存警告后取消队列中的操作。 为了保证scorllView在滚动的时候流畅 通常在滚动开始时，暂停队列中的所有操作，滚动结束后，恢复操作。 Object C中创建线程的方法是什么?如果在主线程中执行代码，方法是什么?如果想延时执行代码、方法又是什么?线程创建有三种方法：使用NSThread创建、使用GCD的dispatch、使用子类化的NSOperation,然后将其加入NSOperationQueue; NSThread创建线程的三种方法： NSThread *thread = [[NSThread alloc]initWithTarget:self selector:@selector(run:) object:@&quot;nil&quot;]; [NSThread detachNewThreadSelector:@selector(run:) toTarget:self withObject:@&quot;我是分离出来的子线程&quot;]; [self performSelectorInBackground:@selector(run:) withObject:@&quot;我是后台线程&quot;]; 在主线程执行代码，就调用performSelectorOnMainThread方法。 如果想延时执行代码可以调用performSelector:onThread:withObject:waitUntilDone:方法； GCD： 利用异步函数dispatch_async()创建子线程。 在主线程执行代码，dispatch_async(dispatch_get_main_queue(), ^{}); 延迟执行代码（延迟·可以控制代码在哪个线程执行）： dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{}); NSOperationQueue： 使用NSOperation的子类封装操作，再将操作添加到NSOperationQueue创建的队列中，实现多线程。 在主线程执行代码，只要将封装代码的NSOperation对象添加到主队列就可以了。 下面关于线程管理错误的是A. GCD所用的开销要比NSThread大 B. 可以在子线程中修改UI元素 C. NSOperationQueue是比NSthread更高层的封装 D. GCD可以根据不同优先级分配线程 参考答案：B 理由：首先，UI元素的更新必须在主线程。GCD与Block配合使用，block需要自动捕获上下文变量信息等，因此需要更多的资源，故比NSThread开销要大一些。NSOperationQueue与NSOperation配合使用，比NSThread更易于操作线程。GCD提供了多个优先级，我们可以根据设置优先级，让其自动为我们分配线程。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS面试题16--WebView与JS交互]]></title>
    <url>%2F2018%2F09%2F12%2FiOS%E9%9D%A2%E8%AF%95%E9%A2%9816-WebView%E4%B8%8EJS%E4%BA%A4%E4%BA%92%2F</url>
    <content type="text"><![CDATA[iOS中调用HTML 1. 加载网页 NSURL *url = [[NSBundle mainBundle] URLForResource:@&quot;index&quot; withExtension:@&quot;html&quot;]; NSURLRequest *request = [NSURLRequest requestWithURL:url]; [self.webView loadRequest:request]; 2. 删除 NSString *str1 = @&quot;var word = document.getElementById(&#39;word&#39;);&quot;; NSString *str2 = @&quot;word.remove();&quot;; [webView stringByEvaluatingJavaScriptFromString:str1]; [webView stringByEvaluatingJavaScriptFromString:str2]; 3. 更改 NSString *str3 = @&quot;var change = document.getElementsByClassName(&#39;change&#39;)[0];&quot; &quot;change.innerHTML = &#39;好你的哦!&#39;;&quot;; [webView stringByEvaluatingJavaScriptFromString:str3]; 4. 插入 NSString *str4 =@&quot;var img = document.createElement(&#39;img&#39;);&quot; &quot;img.src = &#39;img_01.jpg&#39;;&quot; &quot;img.width = &#39;160&#39;;&quot; &quot;img.height = &#39;80&#39;;&quot; &quot;document.body.appendChild(img);&quot;; [webView stringByEvaluatingJavaScriptFromString:str4]; 5. 改变标题 NSString *str1 = @&quot;var h1 = document.getElementsByTagName(&#39;h1&#39;)[0];&quot; &quot;h1.innerHTML=&#39;简书啊啊啊啊&#39;;&quot;; [webView stringByEvaluatingJavaScriptFromString:str1]; 6. 删除尾部 NSString *str2 =@&quot;document.getElementById(&#39;footer&#39;).remove();&quot;; [webView stringByEvaluatingJavaScriptFromString:str2]; 7. 拿出所有的网页内容 NSString *str3 = @&quot;document.body.outerHTML&quot;; NSString *html = [webView stringByEvaluatingJavaScriptFromString:str3]; NSLog(@&quot;%@&quot;, html); 在HTML中调用OC-(BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType{ NSString *str = request.URL.absoluteString; NSRange range = [str rangeOfString:@&quot;ZJY://&quot;]; if (range.location != NSNotFound) { NSString *method = [str substringFromIndex:range.location + range.length]; SEL sel = NSSelectorFromString(method); [self performSelector:sel]; } return YES; } // 访问相册 - (void)getImage{ UIImagePickerController *pickerImg = [[UIImagePickerController alloc]init]; pickerImg.sourceType = UIImagePickerControllerSourceTypePhotoLibrary; [self presentViewController:pickerImg animated:YES completion:nil]; } JavaScriptCore 使用 JavaScriptCore是webkit的一个重要组成部分，主要是对JS进行解析和提供执行环境。iOS7后苹果在iPhone平台推出，极大的方便了我们对js的操作。我们可以脱离webview直接运行我们的js。iOS7以前我们对JS的操作只有webview里面一个函数stringByEvaluatingJavaScriptFromString，JS对OC的回调都是基于URL的拦截进行的操作。大家用得比较多的是WebViewJavascriptBridge和EasyJSWebView这两个开源库，很多混合都采用的这种方式。 #import &quot;JSContext.h&quot; #import &quot;JSValue.h&quot; #import &quot;JSManagedValue.h&quot; #import &quot;JSVirtualMachine.h&quot; #import &quot;JSExport.h&quot; JSContext:JS执行的环境，同时也通过JSVirtualMachine管理着所有对象的生命周期，每个JSValue都和JSContext相关联并且强引用context。 JSValue:JS对象在JSVirtualMachine中的一个强引用，其实就是Hybird对象。我们对JS的操作都是通过它。并且每个JSValue都是强引用一个context。同时，OC和JS对象之间的转换也是通过它，相应的类型转换如下： Objective-C type JavaScript type nil undefined NSNull null NSString string NSNumber number, boolean NSDictionary Object object NSArray Array object NSDate Date object NSBlock (1) Function object (1) id (2) Wrapper object (2) Class (3) Constructor object (3) JSManagedValue:JS和OC对象的内存管理辅助对象。由于JS内存管理是垃圾回收，并且JS中的对象都是强引用，而OC是引用计数。如果双方相互引用，势必会造成循环引用，而导致内存泄露。我们可以用JSManagedValue保存JSValue来避免。 JSVirtualMachine:JS运行的虚拟机，有独立的堆空间和垃圾回收机制。 JSExport:一个协议，如果JS对象想直接调用OC对象里面的方法和属性，那么这个OC对象只要实现这个JSExport协议就可以了。 Objective-C -&gt; JavaScript self.context = [[JSContext alloc] init]; NSString *js = @&quot;function add(a,b) {return a+b}&quot;; [self.context evaluateScript:js]; JSValue *n = [self.context[@&quot;add&quot;] callWithArguments:@[@2, @3]]; NSLog(@&quot;---%@&quot;, @([n toInt32]));//---5 JavaScript -&gt; Objective-C.JS调用OC有两个方法：block和JSExport protocol。 block(JS function): self.context = [[JSContext alloc] init]; self.context[@&quot;add&quot;] = ^(NSInteger a, NSInteger b) { NSLog(@&quot;---%@&quot;, @(a + b)); }; [self.context evaluateScript:@&quot;add(2,3)&quot;]; 我们定义一个block，然后保存到context里面，其实就是转换成了JS的function。然后我们直接执行这个function，调用的就是我们的block里面的内容了。 JSExport protocol: //定义一个JSExport protocol @protocol JSExportTest &lt;JSExport&gt; - (NSInteger)add:(NSInteger)a b:(NSInteger)b; @property (nonatomic, assign) NSInteger sum; @end //建一个对象去实现这个协议： @interface JSProtocolObj : NSObject&lt;JSExportTest&gt; @end @implementation JSProtocolObj @synthesize sum = _sum; //实现协议方法 - (NSInteger)add:(NSInteger)a b:(NSInteger)b { return a+b; } //重写setter方法方便打印信息， - (void)setSum:(NSInteger)sum { NSLog(@&quot;--%@&quot;, @(sum)); _sum = sum; } @end //在VC中进行测试 @interface ViewController () &lt;JSExportTest&gt; @property (nonatomic, strong) JSProtocolObj *obj; @property (nonatomic, strong) JSContext *context; @end @implementation ViewController - (void)viewDidLoad { [super viewDidLoad]; //创建context self.context = [[JSContext alloc] init]; //设置异常处理 self.context.exceptionHandler = ^(JSContext *context, JSValue *exception) { [JSContext currentContext].exception = exception; NSLog(@&quot;exception:%@&quot;,exception); }; //将obj添加到context中 self.context[@&quot;OCObj&quot;] = self.obj; //JS里面调用Obj方法，并将结果赋值给Obj的sum属性 [self.context evaluateScript:@&quot;OCObj.sum = OCObj.addB(2,3)&quot;]; } demo很简单，还是定义了一个两个数相加的方法，还有一个保存结果的变量。在JS中进行调用这个对象的方法，并将结果赋值sum。唯一要注意的是OC的函数命名和JS函数命名规则问题。协议中定义的是add: b:，但是JS里面方法名字是addB(a,b)。可以通过JSExportAs这个宏转换成JS的函数名字。 内存管理:现在来说说内存管理的注意点，OC使用的ARC，JS使用的是垃圾回收机制，并且所有的引用是都强引用，不过JS的循环引用，垃圾回收会帮它们打破。JavaScriptCore里面提供的API，正常情况下，OC和JS对象之间内存管理都无需我们去关心。不过还是有几个注意点需要我们去留意下。 1、不要在block里面直接使用context，或者使用外部的JSValue对象。 //错误代码： self.context[@&quot;block&quot;] = ^(){ JSValue *value = [JSValue valueWithObject:@&quot;aaa&quot; inContext:self.context]; }; 这个代码，不用自己看了，编译器都会提示你的。这个block里面使用self，很容易就看出来了。 //一个比较隐蔽的 JSValue *value = [JSValue valueWithObject:@&quot;ssss&quot; inContext:self.context]; self.context[@&quot;log&quot;] = ^(){ NSLog(@&quot;%@&quot;,value); }; 这个是block里面使用了外部的value，value对context和它管理的JS对象都是强引用。这个value被block所捕获，这边同样也会内存泄露，context是销毁不掉的。 //正确的做法，str对象是JS那边传递过来。 self.context[@&quot;log&quot;] = ^(NSString *str){ NSLog(@&quot;%@&quot;,str); }; 2、OC对象不要用属性直接保存JSValue对象，因为这样太容易循环引用了。 看个demo，把上面的示例改下： //定义一个JSExport protocol @protocol JSExportTest &lt;JSExport&gt; //用来保存JS的对象 @property (nonatomic, strong) JSvalue *jsValue; @end //建一个对象去实现这个协议： @interface JSProtocolObj : NSObject&lt;JSExportTest&gt; @end @implementation JSProtocolObj @synthesize jsValue = _jsValue; @end //在VC中进行测试 @interface ViewController () &lt;JSExportTest&gt; @property (nonatomic, strong) JSProtocolObj *obj; @property (nonatomic, strong) JSContext *context; @end @implementation ViewController - (void)viewDidLoad { [super viewDidLoad]; //创建context self.context = [[JSContext alloc] init]; //设置异常处理 self.context.exceptionHandler = ^(JSContext *context, JSValue *exception) { [JSContext currentContext].exception = exception; NSLog(@&quot;exception:%@&quot;,exception); }; //加载JS代码到context中 [self.context evaluateScript: @&quot;function callback (){}; function setObj(obj) { this.obj = obj; obj.jsValue=callback; }&quot;]; //调用JS方法 [self.context[@&quot;setObj&quot;] callWithArguments:@[self.obj]]; } 上面的例子很简单，调用JS方法，进行赋值，JS对象保留了传进来的obj，最后，JS将自己的回调callback赋值给了obj，方便obj下次回调给JS；由于JS那边保存了obj，而且obj这边也保留了JS的回调。这样就形成了循环引用。 怎么解决这个问题？我们只需要打破obj对JSValue对象的引用即可。当然，不是我们OC中的weak。而是之前说的内存管理辅助对象JSManagedValue。 JSManagedValue 本身就是我们需要的弱引用。用官方的话来说叫garbage collection weak reference。但是它帮助我们持有JSValue对象必须同时满足一下两个条件（不翻译了，翻译了怪怪的！）： The JSManagedValue&#39;s JavaScript value is reachable from JavaScript The owner of the managed reference is reachable in Objective-C. Manually adding or removing the managed reference in the JSVirtualMachine determines reachability. 意思很简单，JSManagedValue 帮助我们保存JSValue，那里面保存的JS对象必须在JS中存在，同时 JSManagedValue 的owner在OC中也存在。我们可以通过它提供的两个方法``` + (JSManagedValue )managedValueWithValue:(JSValue )value; (JSManagedValue )managedValueWithValue:(JSValue )value andOwner:(id)owner创建JSManagedValue对象。通过JSVirtualMachine的方法- (void)addManagedReference:(id)object withOwner:(id)owner来建立这个弱引用关系。通过- (void)removeManagedReference:(id)object withOwner:(id)owner``` 来手动移除他们之间的联系。 把刚刚的代码改下： //定义一个JSExport protocol @protocol JSExportTest &lt;JSExport&gt; //用来保存JS的对象 @property (nonatomic, strong) JSValue *jsValue; @end //建一个对象去实现这个协议： @interface JSProtocolObj : NSObject&lt;JSExportTest&gt; //添加一个JSManagedValue用来保存JSValue @property (nonatomic, strong) JSManagedValue *managedValue; @end @implementation JSProtocolObj @synthesize jsValue = _jsValue; //重写setter方法 - (void)setJsValue:(JSValue *)jsValue { _managedValue = [JSManagedValue managedValueWithValue:jsValue]; [[[JSContext currentContext] virtualMachine] addManagedReference:_managedValue withOwner:self]; } @end //在VC中进行测试 @interface ViewController () &lt;JSExportTest&gt; @property (nonatomic, strong) JSProtocolObj *obj; @property (nonatomic, strong) JSContext *context; @end @implementation ViewController - (void)viewDidLoad { [super viewDidLoad]; //创建context self.context = [[JSContext alloc] init]; //设置异常处理 self.context.exceptionHandler = ^(JSContext *context, JSValue *exception) { [JSContext currentContext].exception = exception; NSLog(@&quot;exception:%@&quot;,exception); }; //加载JS代码到context中 [self.context evaluateScript: @&quot;function callback (){}; function setObj(obj) { this.obj = obj; obj.jsValue=callback; }&quot;]; //调用JS方法 [self.context[@&quot;setObj&quot;] callWithArguments:@[self.obj]]; } 注：以上代码只是为了突出用 JSManagedValue来保存 JSValue，所以重写了 setter 方法。实际不会写这么搓的姿势。。。应该根据回调方法传进来参数，进行保存 JSValue。 3、不要在不同的 JSVirtualMachine 之间进行传递JS对象。 一个 JSVirtualMachine可以运行多个context，由于都是在同一个堆内存和同一个垃圾回收下，所以相互之间传值是没问题的。但是如果在不同的 JSVirtualMachine传值，垃圾回收就不知道他们之间的关系了，可能会引起异常。 线程:JavaScriptCore 线程是安全的，每个context运行的时候通过lock关联的JSVirtualMachine。如果要进行并发操作，可以创建多个JSVirtualMachine实例进行操作。 与UIWebView的操作 通过上面的demo，应该差不多了解OC如何和JS进行通信。下面我们看看如何对 UIWebView 进行操作，我们不再通过URL拦截，我们直接取 UIWebView 的 context，然后进行对JS操作。 在UIWebView的finish的回调中进行获取 - (void)webViewDidFinishLoad:(UIWebView *)webView { self.context = [webView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;]; } 上面用了私有属性，可能会被苹果给拒了。这边要注意的是每个页面加载完都是一个新的context，但是都是同一个JSVirtualMachine。如果JS调用OC方法进行操作UI的时候，请注意线程是不是主线程。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS面试题15--网络]]></title>
    <url>%2F2018%2F09%2F12%2FiOS%E9%9D%A2%E8%AF%95%E9%A2%9815-%E7%BD%91%E7%BB%9C%2F</url>
    <content type="text"><![CDATA[http请求方式？通常，HTTP的请求方式有3种，分别是：POST、GET、HEAD。POST和GET方法是用于数据发送的。 POST：它将要发送的数据单独放在一个流中进行发送，而不是附加在URL地址后面，这样做的好处是这些数据不会出现在URL地址中。 GET：它将要发送的数据直接添加在URL后面，如：www.sina.com.cn?username=“”&amp;password=””，这样的好处是可以直接将数据加在URL后，而不需在用另外的流来发送这些数据，但是缺点也显而易见，它将用户的信息显示出来了。 HEAD：它是请求资源的元数据方法。在具体的应用中，我暂时还没遇到过，也不去对它进行研究，需要是在学习。 Http定义了与服务器交互的不同方法，最基本的方法有？ URL全称是资源描述符，我们可以这样认为：一个URL地址，它用于描述一个网络上的资源，而HTTP中的GET，POST，PUT，DELETE就对应着对这个资源的查，改，增，删4个操作。 GET一般用于获取/查询资源信息，而POST一般用于更新资源信息。 socket编程简述它是基于TCP/IP协议，Socket就是一个可以连通网络上不同计算机程序之间的管道，把一堆数据从管道的A端扔进去，则会从管道的B端（也许同时还可以从C、D、E、F……端冒出来）。管道的端口由两个因素来唯一确认，即机器的IP地址和程序所使用的端口号。 Socket可以支持数据的发送和接收，它会定义一种称为套接字的变量，发送数据时首先创建套接字，然后使用该套接字的sendto等方法对准某个IP/端口进行数据发送；接收端也首先创建套接字，然后将该套接字绑定到一个IP/端口上，所有发向此端口的数据会被该套接字的recv等函数读出。如同读出文件中的数据一样。 TCP/IP的socket提供下列三种类型套接字。 流式套接字、数据报式套接字、原始式套接字。 客户端编程步骤： 1：加载套接字库，创建套接字(WSAStartup()/socket())； 2：向服务器发出连接请求(connect())； 3：和服务器端进行通信(send()/recv())； 4：关闭套接字，关闭加载的套接字库(closesocket()/WSACleanup())。 常用第三方库：1，Asyncsocket库 asihttp代码原理，异步请求的原理，异步请求最大数目，为什么只能这么多？ ASIHTTPRequest是一个简易使用的类库,通过包装CFNetwork API 来简化 和服务器端的通讯. 它编写的语言是Objective-C 能够应用于Mac OS X and iPhone 平台的应用程序. 异步: 请求通过事件触发-&gt;服务器处理（这是浏览器仍然可以作其他事情）-&gt;处理完毕这个数量是跟cpu有关的,并发性取决于cpu核数,每个核只能同时处理一个任务.4核cpu理论上可以并发处理4个任务,如果按http来算就是4个请求,但是cpu是抢占式资源,所以一般来说并发量是要根据任务的耗时和cpu的繁忙度来计算4个左右只是个经验值你开10个短耗时的任务和几个长耗时任务的效率是不同的。 JSONKit、SBJson、TouchJSON和原生的区别?JSONKit、SBJson、TouchJSON（性能从左到右，越右越差,主要就是性能上的差别） App需要加载超大量的数据，给服务器发送请求，但是服务器卡住了如何解决？1&gt; 设置请求超时 2&gt; 给用户提示请求超时 3&gt; 根据用户操作再次请求数据 HTTP的通信的 发送请求、接收响应 包含哪些内容？OC中是怎样实现的？ 请求：一个请求包含以下内容： 请求行：包含了请求方法、请求资源路径、HTTP协议版本 GET /XXServer/resources/images/1.jpg HTTP/1.1 请求头：包含了对客户端的环境描述、客户端请求的主机地址等信息 Host: 192.168.1.105:8080 // 客户端想访问的服务器主机地址 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.9) Firefox/30.0 // 客户端的类型，客户端的软件环境 Accept: text/html, / // 客户端所能接收的数据类型 Accept-Language: zh-cn // 客户端的语言环境 Accept-Encoding: gzip // 客户端支持的数据压缩格式 请求体：客户端发给服务器的具体数据，比如文件数据 OC中请求NSURLRequest 发送给服务器的请求包含： 请求行： 包含了请求方法、请求资源路径、HTTP协议版本 请求头： 对客户端的环境描述、客户端请求的主机地址等信息 请求体： 客户端发给服务器的具体数据 默认超时时常：60s 响应： 一个响应包括： 状态行：包含了HTTP协议版本、状态码、状态英文名称 HTTP/1.1 200 OK 响应头：包含了对服务器的描述、对返回数据的描述 Server: Apache-Coyote/1.1 // 服务器的类型 Content-Type: image/jpeg // 返回数据的类型 Content-Length: 56811 // 返回数据的长度 Date: Mon, 23 Jun 2014 12:54:52 GMT // 响应的时间 实体内容：服务器返回给客户端的具体数据，比如文件数据 OC中响应用NSURLRespose：返回给客户端的回应包含： 状态行 ： 包含了HTTP协议版本、状态码、状态英文名称 响应头 ： 包含了对服务器的描述、对返回数据的描述 实体内容：服务器返回给客户端的具体二进制数据 常用属性： expectedContentLength （下载时返回文件的长度） suggestedFilename（建议保存的文件名） http 的post与get区别与联系，实践中如何选择它们？ GET POST 用途 从服务器上获取数据 向服务器传送数据提交方式 服务器解析 Request.QueryString获取变量的值 Request.Form获取提交的数据 数据大小 最大1024字节 无限制 安全性 URL中能看到提交的数据 隐藏在请求头中 知道TCP/UDP吗？说说关于UDP/TCP的区别？ UDP: 是用户数据报协议: 主要用在实时性要求高以及对质量相对较弱的地方,但面对现在高质量的线路不是容易丢包除非是一些拥塞条件下, 如流媒体 TCP: 是传输控制协议:是面连接的,那么运行环境必然要求其可靠性不可丢包有良好的拥塞控制机制如http ftp telnet 等 TCP UDP 发送与接收 安全送达 只管发送 建立连接 是（三次握手） 否（有数据包，无需连接） 数据大小 无限制 每个数据报64k 可靠性 可靠 不可靠 速度 慢（三次握手才能完成连接 快（无需连接） 应用 流媒体 qq 什么是三次握手与四次挥手？ 三次握手实现的过程： 第一次握手：建立连接时，客户端发送同步序列编号到服务器，并进入发送状态，等待服务器确认 第二次：服务器收到同步序列编号，确认并同时自己也发送一个同步序列编号+确认标志，此时服务器进入接收状态 第三次：客户端收到服务器发送的包，并向服务器发送确认标志，随后链接成功。 注意：是在链接成功后在进行数据传输。 四次挥手： 第一次： 客户端向服务器发送一个带有结束标记的报文。 第二次：服务器收到报文后，向客户端发送一个确认序号，同时通知自己相应的应用程序：对方要求关闭连接 第三次： 服务器向客户端发送一个带有结束标记的报文。 第四次： 客户端收到报文后，向服务器发送一个确认序号。链接关闭。 分析json、xml的区别?json、xml解析方式的底层是如何处理的? Json与xml的区别: 可读性方面:基本相同,xml的可读性比较好 可扩展性方面:都具有很好的扩展性 编码难度方面:相对而言:JSON的编码比较容易 解码难度:json的解码难度基本为零,xml需要考虑子节点和父节点 数据体积方面:json相对于xml来讲,数据体积小,传递的速度跟快些 数据交互方面:json与JavaScript的交互更加方面,更容易解析处理,更好的数据交互 数据描述方面:xml对数据描述性比较好 传输速度方面:json的速度远远快于xml JSON底层原理: 遍历字符串中的字符,最终根据格式规定的特殊字符,比如{}号,[]号, : 号 等进行区分,{}号是一个字典 的开始,[]号是一个数组的开始, : 号是字典的键和值的分水岭,最终乃是将json数据转化为字典,字典中值可能是字典,数组,或字符串而已。 XML底层原理: XML解析常用的解析方法有两种:DOM解析和SAX解析。 DOM 采用建立树形结构的方式访问 XML 文档,而 SAX 采用的事件模型。 DOM 解析把 XML 文档转化为一个包含其内容的树,并可以对树进行遍历。 使用 DOM 解析器的时候需 要处理整个 XML 文档,所以对性能和内存的要求比较高。 SAX在解析 XML 文档的时候可以触发一系列的事件,当发现给定的tag的时候,它可以激活一个回调方法,告诉该方法制定的标签已经找到。 SAX 对内存的要求通常会比较低,因为它让开发人员自己来决定所要处理的tag。特别是当开发人员只需要处理文档中所包含的部分数据时,SAX 这种扩展能力得到了更好的体现。 (补充)其他解析方式有自定义二进制解析，就是按字节去解析，电话会谈就是如此，还可以是字符串之间用特殊符号连接的数据，将此数据用特殊符号可以分割成所用数据。 http和scoket通信的区别?socket连接相关库,TCP,UDP的连接方法,HTTP的几种常用方式? http和scoket通信的区别: http是客户端用http协议进行请求,发送请求时候需要封装http请求头,并绑定请求的数据,服务器一般有web服务器配合(当然也非绝对)。 http请求方式为客户端主动发起请求,服务器才能给响应,一次请求完毕后则断开连接,以节省资源。服务器不能主动给客户端响应(除非采取http长连接技术)。iphone主要使用类是NSUrlConnection。 scoket是客户端跟服务器直接使用socket“套接字”进行连接,并没有规定连接后断开,所以客户端和服务器可以保持连接通道,双方都可以主动发送数据。一般在游戏开发或股票开发这种要求即时性很强并且保持发送数据量比较大的场合使用。主要使用类是CFSocketRef。 通信底层原理（OSI七层模型） OSI简介：OSI采用了分层的结构化技术，共分七层，物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。 物理层：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输,到达目的地后在转化为1、0，也就是我们常说的数模转换与模数转换）。这一层的数据叫做比特。 数据链路层：定义了如何让格式化数据以进行传输，以及如何让控制对物理介质的访问。这一层通常还提供错误检测和纠正，以确保数据的可靠传输。 网络层：：在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选择。Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的层。 传输层：定义了一些传输数据的协议和端口号（WWW端口80等），如：TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的）。 主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组。常常把这一层数据叫做段。 会话层：通过传输层（端口号：传输端口与接收端口）建立数据传输的通路。主要在你的系统之间发起会话或者接受会话请求（设备之间需要互相认识可以是IP也可以是MAC或者是主机名） 表示层：：可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。例如，PC程序与另一台计算机进行通信，其中一台计算机使用扩展二一十进制交换码（EBCDIC），而另一台则使用美国信息交换标准码（ASCII）来表示相同的字符。如有必要，表示层会通过使用一种通格式来实现多种数据格式之间的转换。 应用层：是最靠近用户的OSI层。这一层为用户的应用程序（例如电子邮件、文件传输和终端仿真）提供网络服务。 all people seem to need date processing这一句话的意思是所有的人似乎都需要处理数据 Application all Presentation people Session seem Transport to Network need Data date Physical processing 设计一套大文件（如上百M的视频）下载方案 NSURLSession 支持断点下载，自动记录停止下载时断点的位置 遵守NSURLSessionDownloadDelegate协议 使用NSURLSession下载大文件，被下载文件会被自动写入沙盒的临时文件夹tmp中 下载完毕，通常需要将已下载文件移动其他位置（tmp文件夹中的数据被定时删除），通常是cache文件夹中 下载步骤： 设置下载任务task的为成员变量 @property (nonatomic, strong) NSURLSessionDownloadTask *task; 获取NSURLSession对象 NSURLSession *session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration] delegate:self delegateQueue:[[NSOperationQueue alloc] init]]; 初始化下载任务任务 self.task = [session downloadTaskWithURL:（此处为下载文件路径URL）]; 实现代理方法 /**每当写入数据到临时文件的时候，就会调用一次该方法，通常在该方法中获取下载进度*/ -(void)URLSession:(NSURLSession *)session downloadTask: (NSURLSessionDownloadTask *)downloadTask didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWritten totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite { // 计算下载进度 CGFloat progress = 1.0 * totalBytesWritten / totalBytesExpectedToWrite; } /**任务终止时调用的方法，通常用于断点下载*/ -(void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didResumeAtOffset:(int64_t)fileOffset expectedTotalBytes:(int64_t)expectedTotalBytes { //fileOffset：下载任务中止时的偏移量 } /**遇到错误的时候调用，error参数只能传递客户端的错误*/ -(void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error { } /**下载完成的时候调用，需要将文件剪切到可以长期保存的文件夹中*/ -(void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didFinishDownloadingToURL:(NSURL *)location { //生成文件长期保存的路径 NSString *file = [[NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject] stringByAppendingPathComponent:downloadTask.response.suggestedFilename]; //获取文件句柄 NSFileManager *fileManager = [NSFileManager defaultManager]; //通过文件句柄，将文件剪切到文件长期保存的路径 [fileManager moveItemAtURL:location toURL:[NSURL fileURLWithPath:file] error:nil]; } 操作任务状态 /**开始/继续下载任务*/ [self.task resume]; /**暂停下载任务*/ [self.task suspend]; HTTP协议的特点，关于HTTP请求GET和POST的区别?HTTP协议的特点: - HTTP超文本传输协议，是短连接，是客户端主动发送请求，服务器做出响应，服务器响应之后，链接断开。HTTP是一个属于应用层面向对象的协议，HTTP有两类报文：请求报文和响应报文。 - HTTP请求报文：一个HTTP请求报文由请求行、请求头部、空行和请求数据4部分组成。 - HTTP响应报文：由三部分组成：状态行、消息报头、响应正文。 即时聊天App不会采用的网络传输方式A UDP B TCP C HTTP D FTP 参考答案：D 理由：FTP是文件传输协议，是File Transfer Protocol的简称，它的作用是用于控制互联网上文件的双向传输，因此一定不会是即时聊天使用的；UDP是面向无连接的传输层协议，数据传输是不可靠的，它只管发，不管收不收得到；TCP是面向连接的，可靠的传输层协议；HTTP是超文本传输协议，对应于应用层，而HTTP是基于TCP的。 在App中混合HTML5开发App如何实现的。在App中使用HTML5的优缺点是什么？在iOS中，通常是用UIWebView来实现，当然在iOS8以后可以使用WKWebView来实现.有以下几种实现方法： 通过实现UIWebView的代理方法来拦截，判断scheme是否是约定好的，然后iOS调用本地相关API来实现： - (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType; 在iOS7以后，可以直接通过JavaScripteCore这个库来实现，通过往JS DOM注入对象，而这个对象对应于我们iOS的某个类的实例。更详细请阅读： OC JavaScriptCore与js交互 WKWebView新特性及JS交互 Swift JavaScriptCore与JS交互 可以通过WebViewJavascriptBridge来实现。具体如何使用，请大家去其它博客搜索吧！ 优缺点： iOS加入H5响应比原生要慢很多，体验不太好，这是缺点。 iOS加入H5可以实现嵌入别的功能入口，可随时更改，不用更新版本就可以上线，这是最大的优点。 介绍一下XMPP?有什么优缺点吗?XMPP(Extensible Messaging and Presence Protocol,前称)是一种以XML为基础的开放式实时通信协议,是 经由互联网工程工作小组(IETF)通过的互联网标准。简单的说,XMPP就是一种协议,一种规定。就是说,在网络上传 东西,要建立连接,TCP/IP连接,建立后再传东西,而XMPP就是规定你传的东西的格式。XMPP是基于XML的协议。 优点 开放: XMPP协议是自由、开放、公开的,并且易于了解。 而且在客户端 、 服务器 、 组件 、 源码库等方面,都已经各自有多种实现。 标准: 互联网工程工作小组( IETF )已经将Jabber的核心XML流协议以XMPP之名,正式列为认可的实时通信及Presence技术。 而XMPP的技术规格已被定义在RFC 3920及RFC 3921 。 任何IM供应商在遵循XMPP协议下,都可与Google Talk实现连接。 证实可用: 第一个Jabber(现在XMPP)技术是Jeremie Miller在1998年开发的,现在已经相当稳定;数以百计的开发者为XMPP技术而努 力。 今日的互联网上有数以万计的XMPP服务器运作着,并有数以百万计的人们使用XMPP实时传讯软件。 分散式: XMPP网络的架构和电子邮件十分相像;XMPP核心协议通信方式是先创建一个stream,XMPP以TCP传递XML数据流,没有 中央主服务器。 任何人都可以运行自己的XMPP服务器,使个人及组织能够掌控他们的实时传讯体验。 安全: 任何XMPP协议的服务器可以独立于公众XMPP网络(例如在企业内部网络中),而使用SASL及TLS等技术的可靠安全性,已自 带于核心XMPP技术规格中。 可扩展: XML 命名空间的威力可使任何人在核心协议的基础上建造定制化的功能;为了维持通透性,常见的扩展由XMPP标准基金会 。 弹性佳: XMPP除了可用在实时通信的应用程序,还能用在网络管理、内容供稿、协同工具、文件共享、游戏、远程系统监控等。 多样性: 用XMPP协议来建造及布署实时应用程序及服务的公司及开放源代码计划分布在各种领域;用XMPP技术开发软件,资源及支持的 来源是多样的,使得使你不会陷于被“绑架”的困境。 缺点 数据负载太重: 随着通常超过70%的XMPP协议的服务器的数据流量的存在和近60%的被重复转发,XMPP协议目前拥有一个大型架空中存在的 数据提供给多个收件人。 新的议定书正在研究,以减轻这一问题。 没有二进制数据: XMPP协议的方式被编码为一个单一的长的XML文件,因此无法提供修改二进制数据。 因此, 文件传输协议一样使用外部的 HTTP。 如果不可避免,XMPP协议还提供了带编码的文件传输的所有数据使用的Base64 。 至于其他二进制数据加密会话 (encrypted conversations)或图形图标(graphic icons)以嵌入式使用相同的方法。 NSURLConnection的几个常用的代理? NSURLConnectionDownloadDelegate :能够实现监听下载进度!但是下载之后,找不到下载好的文件! NSURLConnectionDataDelegate 是针对数据下载提供的方法!需要注意的是,需要自己实现监听进度的业务逻辑! 利用 NSURLConnection 的异步回调进行文件下载: 如果是小文件下载,问题不大! 可以直接使用异步回调进行下载 如果使用异步回调的方法进行大文件下载,则会出现内存暴涨的情况! 内存暴涨的原因: 大文件下载之后,默认是放在内存中的,所以下载的文件越大,越耗费内存. 存在的缺点: 使用异步回调实现文件,无法监听下载进度!并且对于大文件下载,会造成内存暴涨! 基于以上两点,一般,在进行文件下载的时候,使用代理回调监听下载进度!并且在下载文件的时候,手动管理内存! NSURLConnection&amp;NSURLSession的区别? 虽然 NSURLConnection 在 iOS 9.0 中已经被废弃，但是作为资深的 iOS 程序员，必须要了解 NSURLConnection 的细节, NSURLSession: 用于替代 NSURLConnection 支持后台运行的网络任务 暂停、停止、重启网络任务，不再需要 NSOperation 封装 请求可以使用同样的配置容器 不同的 session 可以使用不同的私有存储 block 和代理可以同时起作用 直接从文件系统上传、下载 XML是什么? XML与HTML的区别? XML的简单使其易于在任何应用程序中读写数据，这使XML很快成为数据交换的唯一公共语言，虽然不同的应用软件也支持其它的数据交换格式，但不久之后他们都将支持XML，那就意味着程序可以更容易的与Windows,Mac OS,Linux以及其他平台下产生的信息结合，然后可以很容易加载XML数据到程序中并分析他，并以XML格式输出结果。 XML去掉了之前令许多开发人员头疼的SGML（标准通用标记语言）的随意语法。在XML中，采用了如下的语法： 任何的起始标签都必须有一个结束标签。 可以采用另一种简化语法，可以在一个标签中同时表示起始和结束标签。这种语法是在大于符号之前紧跟一个斜线（/），例如&lt;tag/ &gt;。XML解析器会将其翻译成。 标签必须按合适的顺序进行嵌套，所以结束标签必须按镜像顺序匹配起始标签，例如this is asamplestring。这好比是将起始和结束标签看作是数学中的左右括号：在没有关闭所有的内部括号之前，是不能关闭外面的括号的。 所有的特性都必须有值。 所有的特性都必须在值的周围加上双引号。 XML与HTML的设计区别是：XML的核心是数据，其重点是数据的内容。而HTML 被设计用来显示数据，其重点是数据的显示。 XML和HTML语法区别：HTML的标记不是所有的都需要成对出现，XML则要求所有的标记必须成对出现；HTML标记不区分大小写，XML则 大小敏感,即区分大小写。 网络图片处理问题中怎么解决一个相同的网络地址重复请求的问题？利用字典（图片地址为key，下载操作为value） sip是什么？1&gt; SIP（Session Initiation Protocol），会话发起协议 2&gt; SIP是建立VOIP连接的 IETF 标准，IETF是全球互联网最具权威的技术标准化组织 3&gt; 所谓VOIP，就是网络电话，直接用互联网打电话，不用耗手机话费 TCP/IP四层模型 TCP/IP是一组协议的代名词，它还包括许多协议，组成了TCP/IP协议簇。TCP/IP协议簇分为四层，IP位于协议簇的第二层(对应OSI的第三层)，TCP位于协议簇的第三层(对应OSI的第四层)。 应用层：应用程序间沟通的层，如简单电子邮件传输（SMTP）、文件传输协议（FTP）、网络远程访问协议（Telnet）等。 传输层：在此层中，它提供了节点间的数据传送服务，如传输控制协议（TCP）、用户数据报协议（UDP）等，TCP和UDP给数据包加入传输数据并把它传输到下一层中，这一层负责传送数据，并且确定数据已被送达并接收。 互连网络层：负责提供基本的数据封包传送功能，让每一块数据包都能够到达目的主机（但不检查是否被正确接收），如网际协议（IP）。 网络接口层：对实际的网络媒体的管理，定义如何使用实际网络（如Ethernet、Serial Line等）来传送数据。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS面试题14--Runloop]]></title>
    <url>%2F2018%2F09%2F12%2FiOS%E9%9D%A2%E8%AF%95%E9%A2%9814-Runloop%2F</url>
    <content type="text"><![CDATA[什么是 Runloop？ 从字面上讲就是运行循环。 它内部就是do-while循环，在这个循环内部不断地处理各种任务。 一个线程对应一个RunLoop，主线程的RunLoop默认已经启动，子线程的RunLoop得手动启动（调用run方法） RunLoop只能选择一个Mode启动，如果当前Mode中没有任何Source(Sources0、Sources1)、Timer，那么就直接退出RunLoop 基本的作用就是保持程序的持续运行，处理app中的各种事件。通过runloop，有事运行，没事就休息，可以节省cpu资源，提高程序性能。 Runloop对象iOS中有2套API来访问和使用RunLoop Foundation：NSRunLoop Core Foundation：CFRunLoopRef NSRunLoop和CFRunLoopRef都代表着RunLoop对象 NSRunLoop是基于CFRunLoopRef的一层OC包装，所以要了解RunLoop内部结构，需要多研究CFRunLoopRef层面的API。 Runloop与线程 每条线程都有唯一的一个与之对应的RunLoop对象 主线程的RunLoop已经自动创建好了，子线程的RunLoop需要主动创建 RunLoop在第一次获取时创建，在线程结束时销毁 获得RunLoop对象 Foundation [NSRunLoop currentRunLoop]; // 获得当前线程的RunLoop对象 [NSRunLoop mainRunLoop]; // 获得主线程的RunLoop对象 Core Foundation CFRunLoopGetCurrent(); // 获得当前线程的RunLoop对象 CFRunLoopGetMain(); // 获得主线程的RunLoop对象 RunLoop相关类Core Foundation中关于RunLoop的5个类 CFRunLoopRef CFRunLoopModeRef CFRunLoopSourceRef CFRunLoopTimerRef CFRunLoopObserverRef CFRunLoopModeRefCFRunLoopModeRef代表RunLoop的运行模式。 一个RunLoop包含若干个Mode，每个Mode又包含若干个(set)Source/(array)Timer/(array)Observer 每次RunLoop启动时，只能指定其中一个 Mode，这个Mode被称作CurrentMode 如果需要切换Mode，只能退出Loop，再重新指定一个Mode进入 这样做主要是为了分隔开不同组的Source/Timer/Observer，让其互不影响 mode主要是用来指定事件在运行循环中的优先级的，分为： • NSDefaultRunLoopMode（kCFRunLoopDefaultMode）：默认，空闲状态 • UITrackingRunLoopMode：ScrollView滑动时会切换到该Mode • UIInitializationRunLoopMode：run loop启动时，会切换到该mode • NSRunLoopCommonModes（kCFRunLoopCommonModes）：Mode集合 苹果公开提供的Mode有两个： • NSDefaultRunLoopMode（kCFRunLoopDefaultMode） • NSRunLoopCommonModes（kCFRunLoopCommonModes） CFRunLoopTimerRef CFRunLoopTimerRef是基于时间的触发器 CFRunLoopTimerRef基本上说的就是NSTimer，它受RunLoop的Mode影响 GCD的定时器不受RunLoop的Mode影响 CFRunLoopSourceRefCFRunLoopSourceRef是事件源（输入源） 按照官方文档，Source的分类 Port-Based Sources Custom Input Sources Cocoa Perform Selector Sources 按照函数调用栈，Source的分类 Source0：非基于Port的 Source1：基于Port的，通过内核和其他线程通信，接收、分发系统事件 CFRunLoopObserverRef CFRunLoopObserverRef是观察者，能够监听RunLoop的状态改变 可以监听的时间点有以下几个 kcfRunLoopEntry(即将进入loop)//1 kcfRunLoopBeforeTimers(即将处理timer)//2 kcfRunLoopBeforeSources(即将处理source)//4 kcfRunLoopBeforeWaiting(即将进入休眠)//32 kcfRunLoopAfterWaiting(刚从休眠中唤醒)//64 kcfRunLoopExit(即将退出loop)//128 添加Observer CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(CFAllocatorGetDefault(), kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) { NSLog(@&quot;----监听到RunLoop状态发生改变---%zd&quot;, activity); }); // 添加观察者：监听RunLoop的状态 CFRunLoopAddObserver(CFRunLoopGetCurrent(), observer, kCFRunLoopDefaultMode); // 释放Observer CFRelease(observer); RunLoop处理逻辑 通知Observer:即将进入Loop（1） 通知Observer：将要处理Timer（2） 通知Observer：将要处理Source0（3） 处理Source0（4） 如果有Source0，跳到第9步（5） 通知Observer：线程即将休眠（6） 休眠，等待唤醒：（7） Source0(port)。 timer启动 RunLoop设置的timer已经超时 Runloop被外部手动唤醒 通知Observer：线程将被唤醒（8） 处理未处理的时间（9） 如果用户定义的定时器启动，处理定时器事件并重启Runloop。进入步骤2. 如果输入源启动，传递相应的消息。 如果RunLopp被显式唤醒而且时间还没超时，重启RunLoop，进入步骤2. 通知Observer：即将退出Loop Runloop的应用 NSTimer ImageView显示 PerformSelector 常驻线程 自动释放池 runloop定时源和输入源 image Runloop处理的输入事件有两种不同的来源：输入源（input source）和定时源（timer source） 输入源传递异步消息，通常来自于其他线程或者程序。 定时源则传递同步消息，在特定时间或者一定的时间间隔发生 NSRunLoop的实现机制,及在多线程中如何使用- 实现机制：回答runloop的基本作用，处理逻辑，前面都有。 - 程序创建子线程的时候，才需要手动启动runloop。主线程的runloop已经默认启动。 - 在多线程中，你需要判断是否需要runloop。如果需要runloop，那么你要负责配置runloop并启动。你不需要在任何情况下都去启动runloop。比如，你使用线程去处理一个预先定义好的耗时极长的任务时，你就可以无需启动runloop。Runloop只在你要和线程有交互时才需要 runloop和线程有什么关系？- 主线程的run loop默认是启动的。 iOS的应用程序里面，程序启动后会有一个如下的main()函数 ( argc, * argv[]) { @autoreleasepool { return UIApplicationMain(argc, argv, , NSStringFromClass([AppDelegate class])); } } 重点是UIApplicationMain()函数，这个方法会为main thread设置一个NSRunLoop对象，这就解释了：为什么我们的应用可以在无人操作的时候休息，需要让它干活的时候又能立马响应。 - 对其它线程来说，runloop默认是没有启动的，runloop只在你要和线程有交互时才需要。 - 在任何一个 Cocoa 程序的线程中，都可以通过以下代码来获取到当前线程的 run loop 。 NSRunLoop *runloop = [NSRunLoop currentRunLoop]; autorelease 对象在什么情况下会被释放？ 分两种情况：手动干预释放和系统自动释放 手动干预释放就是指定autoreleasepool,当前作用域大括号结束就立即释放 系统自动去释放:不手动指定autoreleasepool,Autorelease对象会在当前的 runloop 迭代结束时释放 kCFRunLoopEntry(1):第一次进入会自动创建一个autorelease kCFRunLoopBeforeWaiting(32):进入休眠状态前会自动销毁一个autorelease,然后重新创建一个新的autorelease kCFRunLoopExit(128):退出runloop时会自动销毁最后一个创建的autorelease 对于runloop的理解不正确的是A 每一个线程都有其对应的RunLoop B 默认非主线程的RunLoop是没有运行的 C 在一个单独的线程中没有必要去启用RunLoop D 可以将NSTimer添加到runloop中 参考答案：C 理由：说到RunLoop，它可是多线程的法定。通常来说，一个线程一次只能执行一个任务，执行完任务后就会退出线程。但是，对于主线程是不能退出的，因此我们需要让主线程即时任务执行完毕，也可以继续等待是接收事件而不退出，那么RunLoop就是关键法宝了。但是非主线程通常来说就是为了执行某一任务的，执行完毕就需要归还资源，因此默认是不运行RunLoop的。NSRunLoop提供了一个添加NSTimer的方法，这个方法是在应用正常状态下会回调。 runloop的mode作用是什么？mode主要是用来指定事件在运行循环中的优先级的，分为： • NSDefaultRunLoopMode（kCFRunLoopDefaultMode）：默认，空闲状态 • UITrackingRunLoopMode：ScrollView滑动时会切换到该Mode • UIInitializationRunLoopMode：run loop启动时，会切换到该mode • NSRunLoopCommonModes（kCFRunLoopCommonModes）：Mode集合 苹果公开提供的Mode有两个： • NSDefaultRunLoopMode（kCFRunLoopDefaultMode） • NSRunLoopCommonModes（kCFRunLoopCommonModes） 如果我们把一个NSTimer对象以NSDefaultRunLoopMode（kCFRunLoopDefaultMode）添加到主运行循环中的时候, ScrollView滚动过程中会因为mode的切换，而导致NSTimer将不再被调度。当我们滚动的时候，也希望不调度，那就应该使用默认模式。但是，如果希望在滚动时，定时器也要回调，那就应该使用common mode。 请写出NSTimer使用时的注意事项（两项即可）思路和上一题一样，如果想要销毁timer，则必须先将timer置为失效，否则timer就一直占用内存而不会释放。造成逻辑上的内存泄漏。该泄漏不能用xcode及instruments测出来。 另外对于要求必须销毁timer的逻辑处理，未将timer置为失效，若每次都创建一次，则之前的不能得到释放，则会同时存在多个timer的实例在内存中。 参考答案： • 注意timer添加到runloop时应该设置为什么mode • 注意timer在不需要时，一定要调用invalidate方法使定时器失效，否则得不到释放 UITableViewCell上有个UILabel，显示NSTimer实现的秒表时间，手指滚动cell过程中，label是否刷新，为什么？和上一题一样的思路，如果要cell滚动过程中定时器正常回调，UI正常刷新，那么要将timer放入到CommonModes下，因为是NSDefaultRunLoopMode，只有在空闲状态下才会回调。 为什么 UIScrollView 的滚动会导致 NSTimer 失效？ 思路和上一题一样，解决办法有2个,一个是更改mode为NSRunLoopCommonModes(无论runloop运行在哪个mode,都能运行),还有种办法是切换到主线程来更新UI界面的刷新 //将timer添加到NSDefaultRunLoopMode中 [NSTimer scheduledTimerWithTimeInterval: target: selector:@selector(timerTick:) userInfo: repeats:]; //然后再添加到NSRunLoopCommonModes里 NSTimer *timer = [NSTimer timerWithTimeInterval: target: selector:@selector(timerTick:) userInfo: repeats:]; [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes]; 在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？ 思路和上一题一样 在开发中如何使用RunLoop？什么应用场景？ 开启一个常驻线程（让一个子线程不进入消亡状态，等待其他线程发来消息，处理其他事件） 在子线程中开启一个定时器 在子线程中进行一些长期监控 可以控制定时器在特定模式下执行 可以让某些事件（行为、任务）在特定模式下执行 可以添加Observer监听RunLoop的状态，比如监听点击事件的处理（在所有点击事件之前做一些事情）]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS面试题13--数据存储]]></title>
    <url>%2F2018%2F09%2F12%2FiOS%E9%9D%A2%E8%AF%95%E9%A2%9813-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%2F</url>
    <content type="text"><![CDATA[sqlite中插入特殊字符的方法和接收到处理方法。除’其他的都是在特殊字符前面加“/”，而 ‘ -&gt; ‘’ 。方法：keyWord = keyWord.replace(“/“,”//“); 什么是NSManagedObject模型？NSManagedObjcet是NSObject的子类，Core Date的重要组成部分。是一个通用类，实现了Core Date模型层所需的基本功能，用户可以通过NSManagedObjcet建立自己的数据模型。 你实现过多线程的Core Data么？NSPersistentStoreCoordinator，NSManagedObjectContext和NSManagedObject中的哪些需要在线程中创建或者传递？你是用什么样的策略来实现的？1&gt; CoreData是对SQLite数据库的封装 2&gt; coreData中有三个对象是必须掌握的, NSManagedObject :只要定义一个类继承于该类就会创建一张与之对应的表, 也就是一个继承于该类的类就对应一张表. 每一个通过继承该类创建出来的对象,都是该类对应的表中的一条数据 NSManagedObjectContext: 用于操作数据库, 只要有类它就能对数据库的表进行增删改查 NSPersistentStoreCoordinator: 决定数据存储的位置 (SQLite/XML/其它文件中) 3&gt; Core data本身并不是一个并发安全的架构所以在多线程中实现Core data会有问题.问题在于 &gt;2.1 CoreData中的NSManagedObjectContext在多线程中不安全 &gt;2.2如果想要多线程访问CoreData的话，最好的方法是一个线程一个NSManagedObjectContext &gt;2.3每个NSManagedObjectContext对象实例都可以使用同一个NSPersistentStoreCoordinator实例，这是因为NSManagedObjectContext会在便用NSPersistentStoreCoordinator前上锁 简单描述下客户端的缓存机制？ 缓存可以分为：内存数据缓存、数据库缓存、文件缓存 每次想获取数据的时候 先检测内存中有无缓存 再检测本地有无缓存(数据库\文件) 最终发送网络请求 将服务器返回的网络数据进行缓存（内存、数据库、文件）， 以便下次读取 什么是序列化和反序列化，用来做什么 序列化把对象转化为字节序列的过程 反序列化把直接序列恢复成对象 把对象写到文件或者数据库中，并且读取出来 OC中实现复杂对象的存储 遵循NSCoding协议，实现复杂对象的存储，实现该协议后可以对其进行打包或者解包，转化为NSDate iOS中常用的数据存储方式有哪些？ 数据存储有四种方案，NSUserDefault,KeyChain,File,DB. 其中File有三种方式：plist,Archiver,Stream DB包括core Data和FMDB 说一说你对SQLite的认识 SQLite是目前主流的嵌入式关系型数据库，其最主要的特点就是轻量级、跨平台，当前很多嵌入式操作系统都将其作为数据库首选。 虽然SQLite是一款轻型数据库，但是其功能也绝不亚于很多大型关系数据库。 学习数据库就要学习其相关的定义、操作、查询语言，也就是大家日常说得SQL语句。和其他数据库相比，SQLite中的SQL语法并没有太大的差别，因此这里对于SQL语句的内容不会过多赘述，大家可以参考SQLite中其他SQL相关的内容，这里还是重点讲解iOS中如何使用SQLite构建应用程序。先看一下SQLite数据库的几个特点： 基于C语言开发的轻型数据库 在iOS中需要使用C语言语法进行数据库操作、访问（无法使用ObjC直接访问，因为libqlite3框架基于C语言编写） SQLite中采用的是动态数据类型，即使创建时定义了一种类型，在实际操作时也可以存储其他类型，但是推荐建库时使用合适的类型（特别是应用需要考虑跨平台的情况时） 建立连接后通常不需要关闭连接（尽管可以手动关闭） 在iOS中操作SQLite数据库可以分为以下几步（注意先在项目中导入libsqlite3框架）： 打开数据库，利用sqlite3_open()打开数据库会指定一个数据库文件保存路径，如果文件存在则直接打开，否则创建并打开。打开数据库会得到一个sqlite3类型的对象，后面需要借助这个对象进行其他操作。 执行SQL语句，执行SQL语句又包括有返回值的语句和无返回值语句。 对于无返回值的语句（如增加、删除、修改等）直接通过sqlite3_exec()函数执行； 对于有返回值的语句则首先通过sqlite3_prepare_v2()进行sql语句评估（语法检测），然后通过sqlite3_step()依次取出查询结果的每一行数据，对于每行数据都可以通过对应的sqlite3_column_类型()方法获得对应列的数据，如此反复循环直到遍历完成。当然，最后需要释放句柄。 说一说你对FMDB的认识 FMDB是一个处理数据存储的第三方框架，框架是对sqlite的封装，整个框架非常轻量级但又不失灵活性，而且更加面向对象。FMDB有如下几个特性： FMDB既然是对于libsqlite3框架的封装，自然使用起来也是类似的，使用前也要打开一个数据库，这个数据库文件存在则直接打开否则会创建并打开。这里FMDB引入了一个MFDatabase对象来表示数据库，打开数据库和后面的数据库操作全部依赖此对象。 对于数据库的操作跟前面KCDbManager的封装是类似的，在FMDB中FMDatabase类提供了两个方法executeUpdate:和executeQuery:分别用于执行无返回结果的查询和有返回结果的查询。当然这两个方法有很多的重载这里就不详细解释了。唯一需要指出的是，如果调用有格式化参数的sql语句时，格式化符号使用“?”而不是“%@”、等。 我们知道直接使用libsqlite3进行数据库操作其实是线程不安全的，如果遇到多个线程同时操作一个表的时候可能会发生意想不到的结果。为了解决这个问题建议在多线程中使用FMDatabaseQueue对象，相比FMDatabase而言，它是线程安全的。 将事务放到FMDB中去说并不是因为只有FMDB才支持事务，而是因为FMDB将其封装成了几个方法来调用，不用自己写对应的sql而已。其实在在使用libsqlite3操作数据库时也是原生支持事务的（因为这里的事务是基于数据库的，FMDB还是使用的SQLite数据库），只要在执行sql语句前加上“begin transaction;”执行完之后执行“commit transaction;”或者“rollback transaction;”进行提交或回滚即可。另外在Core Data中大家也可以发现，所有的增、删、改操作之后必须调用上下文的保存方法，其实本身就提供了事务的支持，只要不调用保存方法，之前所有的操作是不会提交的。在FMDB中FMDatabase有beginTransaction、commit、rollback三个方法进行开启事务、提交事务和回滚事务。 说一说你对Core Data的认识Core Data使用起来相对直接使用SQLite3的API而言更加的面向对象，操作过程通常分为以下几个步骤： 创建管理上下文 创建管理上下可以细分为：加载模型文件-&gt;指定数据存储路径-&gt;创建对应数据类型的存储-&gt;创建管理对象上下方并指定存储。 经过这几个步骤之后可以得到管理对象上下文NSManagedObjectContext，以后所有的数据操作都由此对象负责。同时如果是第一次创建上下文，Core Data会自动创建存储文件（例如这里使用SQLite3存储），并且根据模型对象创建对应的表结构。 查询数据 对于有条件的查询，在Core Data中是通过谓词来实现的。首先创建一个请求，然后设置请求条件，最后调用上下文执行请求的方法。 插入数据 插入数据需要调用实体描述对象NSEntityDescription返回一个实体对象，然后设置对象属性，最后保存当前上下文即可。这里需要注意，增、删、改操作完最后必须调用管理对象上下文的保存方法，否则操作不会执行。 删除数据 删除数据可以直接调用管理对象上下文的deleteObject方法，删除完保存上下文即可。注意，删除数据前必须先查询到对应对象。 修改数据 修改数据首先也是取出对应的实体对象，然后通过修改对象的属性，最后保存上下文。 OC中有哪些数据存储方式,各有什么区别? OC中有四种数据存储方式: NSUserDefaults,用于存储配置信息 SQLite,用于存储查询需求较多的数据 CoreData,用于规划应用中的对象 使用基本对象类型定制的个性化缓存方案. NSUserDefaults:对象中储存了系统中用户的配置信息,开发者可以通过这个实例对象对这些已有的信息进行修改,也 可以按照自己的需求创建新的配置项。 SQLite擅长处理的数据类型其实与NSUserDefaults差不多,也是基础类型的小数据,只是从组织形式上不同。开发者可以以关系型数据库的方式组织数据,使用SQL DML来管理数据。一般来说应用中的格式化的文本类数据可以存放在数据库 中,尤其是类似聊天记录、Timeline等这些具有条件查询和排序需求的数据。 CoreData是一个管理方案,它的持久化可以通过SQLite、XML或二进制文件储存。它可以把整个应用中的对象建模并进行自动化的管理。从归档文件还原模型时CoreData并不是一次性把整个模型中的所有数据都载入内存,而是根据运行时状态,把被调用到的对象实例载入内存。框架会自动控制这个过程,从而达到控制内存消耗,避免浪费。 无论从设计原理还是使用方法上看,CoreData都比较复杂。因此,如果仅仅是考虑缓存数据这个需求,CoreData绝对不是一个优选方案。 CoreData的使用场景在于:整个应用使用CoreData规划,把应用内的数据通过CoreData建模,完全基于CoreData架构应用。 使用基本对象类型定制的个性化缓存方案:从需求出发分析缓存数据有哪些要求:按Key查找,快速读取,写入不影响正常操作,不浪费内存,支持归档。这些都是基本需求,那么再进一步或许还需要固定缓存项数量,支持队列缓存,缓存过期等。 数据存储这一块, 面试常问, 你常用哪一种数据存储? 什么是序列化? sqlite是直接用它还是用封装了它的第三方库? 尤其是会问sqlite和core data的区别? iOS平台怎么做数据的持久化?coredata和sqlite有无必然联系?coredata是一个关系型数据库吗? iOS中可以有四种持久化数据的方式: 属性列表、对象归档、SQLite3和Core Data coredata可以使你以图形界面的方式快速的定义app的数据模型,同时在你的代码中容易获取到它。 coredata提供了基础结构去处理常用的功能,例如保存,恢复,撤销和重做,允许你在app中继续创建新的任务。 在使用coredata的时候,你不用安装额外的数据库系统,因为coredata使用内置的sqlite数据库。 coredata将你app的模型层放入到一组定义在内存中的数据对象。 coredata会 追踪这些对象的改变,同时可以根据需要做相应的改变,例如用户执行撤销命令。 当coredata在对你app数据的改变进行保存的时 候,core data会把这些数据归档,并永久性保存。 mac os x中sqlite库,它是一个轻量级功能强大的关系数据引擎,也很容易嵌入到应用程序。可以在多个平台使用,sqlite是一个轻 量级的嵌入式sql数据库编程。 与coredata框架不同的是,sqlite是使用程序式的,sql的主要的API来直接操作数据表。 Core Data不是一个关系型数据库,也不是关系型数据库管理系统(RDBMS)。 虽然Core Dta支持SQLite作为一种存储类型, 但它不能使用任意的SQLite数据库。 Core Data在使用的过程种自己创建这个数据库。Core Data支持对一、对多的关系。 如果后期需要增加数据库中的字段怎么实现，如果不使用CoreData呢？ 编写SQL语句来操作原来表中的字段 增加表字段：ALTER TABLE 表名 ADD COLUMN 字段名 字段类型; 删除表字段：ALTER TABLE 表名 DROP COLUMN 字段名; 修改表字段：ALTER TABLE 表名 RENAME COLUMN 旧字段名 TO 新字段名; SQLite数据存储是怎么用？ 添加SQLite动态库：导入主头文件：#import &lt;sqlite3.h&gt; 利用C语言函数创建\打开数据库，编写SQL语句 简单描述下客户端的缓存机制？ 缓存可以分为：内存数据缓存、数据库缓存、文件缓存 每次想获取数据的时候 先检测内存中有无缓存 再检测本地有无缓存(数据库\文件) 最终发送网络请求 将服务器返回的网络数据进行缓存（内存、数据库、文件）以便下次读取 你实现过多线程的Core Data么？NSPersistentStoreCoordinator，NSManagedObjectContext和NSManagedObject中的哪些需要在线程中创建或者传递？你是用什么样的策略来实现的？ CoreData是对SQLite数据库的封装 CoreData中的NSManagedObjectContext在多线程中不安全 如果想要多线程访问CoreData的话，最好的方法是一个线程一个NSManagedObjectContext 每个NSManagedObjectContext对象实例都可以使用同一个NSPersistentStoreCoordinator实例，这是因为NSManagedObjectContext会在便用NSPersistentStoreCoordinator前上锁 Core Data数据迁移博客地址: http://blog.csdn.net/jasonblog/article/details/17842535 FMDB的使用和对多张表的处理博客地址: http://blog.csdn.net/wscqqlucy/article/details/8464398 说说数据库的左连接和右连接的区别 数据库左连接和右连接的区别：主表不一样通过左连接和右连接，最小条数为3（记录条数较小的记录数），最大条数为12（3×4） 技术博客的地址 : http://www.2cto.com/database/201407/317367.html iOS 的沙盒目录结构是怎样的？ App Bundle 里面都有什么？ 沙盒结构 Application：存放程序源文件，上架前经过数字签名，上架后不可修改 Documents：常用目录，iCloud备份目录，存放数据,这里不能存缓存文件,否则上架不被通过 Library Caches：存放体积大又不需要备份的数据,SDWebImage缓存路径就是这个 Preference：设置目录，iCloud会备份设置信息 tmp：存放临时文件，不会被备份，而且这个文件下的数据有可能随时被清除的可能 App Bundle 里面有什么 Info.plist:此文件包含了应用程序的配置信息.系统依赖此文件以获取应用程序的相关信息 可执行文件:此文件包含应用程序的入口和通过静态连接到应用程序target的代码 资源文件:图片,声音文件一类的 其他:可以嵌入定制的数据资源 你会如何存储用户的一些敏感信息，如登录的 token使用keychain来存储,也就是钥匙串,使用keychain需要导入Security框架 自定义一个keychain的类 #import &lt;Security/Security.h&gt; @implementation YCKKeyChain +(NSMutableDictionary *)getKeychainQuery:(NSString *)service { return [NSMutableDictionary dictionaryWithObjectsAndKeys: (__bridge_transfer id)kSecClassGenericPassword,(__bridge_transfer id)kSecClass, service, (__bridge_transfer id)kSecAttrService, service, (__bridge_transfer id)kSecAttrAccount, (__bridge_transfer id)kSecAttrAccessibleAfterFirstUnlock, (__bridge_transfer id)kSecAttrAccessible, nil]; } +(void)save:(NSString *)service data:(id)data { // 获得搜索字典 NSMutableDictionary *keychainQuery = [self getKeychainQuery:service]; // 添加新的删除旧的 SecItemDelete((__bridge_retained CFDictionaryRef)keychainQuery); // 添加新的对象到字符串 [keychainQuery setObject:[NSKeyedArchiver archivedDataWithRootObject:data] forKey:(__bridge_transfer id)kSecValueData]; // 查询钥匙串 SecItemAdd((__bridge_retained CFDictionaryRef)keychainQuery, NULL); } +(id)load:(NSString *)service { id ret = nil; NSMutableDictionary *keychainQuery = [self getKeychainQuery:service]; // 配置搜索设置 [keychainQuery setObject:(id)kCFBooleanTrue forKey:(__bridge_transfer id)kSecReturnData]; [keychainQuery setObject:(__bridge_transfer id)kSecMatchLimitOne forKey: (__bridge_transfer id)kSecMatchLimit]; CFDataRef keyData = NULL; if (SecItemCopyMatching((__bridge_retained CFDictionaryRef)keychainQuery, (CFTypeRef *)&amp;keyData) == noErr) { @try { ret = [NSKeyedUnarchiver unarchiveObjectWithData:(__bridge_transfer NSData *)keyData]; } @catch (NSException *e) { NSLog(@&quot;Unarchive of %@ failed: %@&quot;, service, e); } @finally { } } return ret; } +(void)delete:(NSString *)service { NSMutableDictionary *keychainQuery = [self getKeychainQuery:service]; SecItemDelete((__bridge_retained CFDictionaryRef)keychainQuery); } 在别的类实现存储,加载,删除敏感信息方法 // 用来标识这个钥匙串 static NSString const KEY_IN_KEYCHAIN = @”com.yck.app.allinfo”; // 用来标识密码 static NSString const KEY_PASSWORD = @”com.yck.app.password”; +(void)savePassWord:(NSString *)password { NSMutableDictionary *passwordDict = [NSMutableDictionary dictionary]; [passwordDict setObject:password forKey:KEY_PASSWORD]; [YCKKeyChain save:KEY_IN_KEYCHAIN data:passwordDict]; } +(id)readPassWord { NSMutableDictionary *passwordDict = (NSMutableDictionary *)[YCKKeyChain load:KEY_IN_KEYCHAIN]; return [passwordDict objectForKey:KEY_PASSWORD]; } +(void)deletePassWord { [YCKKeyChain delete:KEY_IN_KEYCHAIN]; } 使用 NSUserDefaults 时，如何处理布尔的默认值？(比如返回 NO，不知道是真的 NO 还是没有设置过)if([[NSUserDefaults standardUserDefaults] objectForKey:ID] == nil){ NSLog(@&quot;没有设置&quot;); } MD5和Base64的区别是什么，各自使用场景是什么？做过加密相关的功能的，几乎都会使用到MD5和Base64，它们两者在实际开发中是最常用的。 • MD5：是一种不可逆的摘要算法，用于生成摘要，无法逆着破解得到原文。常用的是生成32位摘要，用于验证数据的有效性。比如，在网络请求接口中，通过将所有的参数生成摘要，客户端和服务端采用同样的规则生成摘要，这样可以防篡改。又如，下载文件时，通过生成文件的摘要，用于验证文件是否损坏。 • Base64：属于加密算法，是可逆的，经过encode后，可以decode得到原文。在开发中，有的公司上传图片采用的是将图片转换成base64字符串，再上传。在做加密相关的功能时，通常会将数据进行base64加密/解密。 plist文件是用来做什么的。一般用它来处理一些什么方面的问题。 plist是iOS系统中特有的文件格式。我们常用的NSUserDefaults偏好设置实质上就是plist文件操作。plist文件是用来持久化存储数据的。 我们通常使用它来存储偏好设置，以及那些少量的、数组结构比较复杂的不适合存储数据库的数据。比如，我们要存储全国城市名称和id，那么我们要优先选择plist直接持久化存储，因为更简单。 当存储大块数据是怎么做？ 你有很多选择，比如： 使用NSUerDefaults 使用XML, JSON, 或者 plist 使用NSCoding存档 使用类似SQLite的本地SQL数据库 使用 Core Data NSUserDefaults的问题是什么？虽然它很nice也很便捷，但是它只适用于小数据，比如一些简单的布尔型的设置选项，再大点你就要考虑其它方式了 XML这种结构化档案呢？总体来说，你需要读取整个文件到内存里去解析，这样是很不经济的。使用SAX又是一个很麻烦的事情。 NSCoding？不幸的是，它也需要读写文件，所以也有以上问题。 在这种应用场景下，使用SQLite 或者 Core Data比较好。使用这些技术你用特定的查询语句就能只加载你需要的对象。在性能层面来讲，SQLite和Core Data是很相似的。他们的不同在于具体使用方法。Core Data代表一个对象的graph model，但SQLite就是一个DBMS。Apple在一般情况下建议使用Core Data，但是如果你有理由不使用它，那么就去使用更加底层的SQLite吧。如果你使用SQLite，你可以用FMDB(https://GitHub.com/ccgus/fmdb)这个库来简化SQLite的操作，这样你就不用花很多经历了解SQLite的C API了 怎么解决sqlite锁定的问题1&gt; 设置数据库锁定的处理函数 int sqlite3_busy_handler(sqlite3*, int(*)(void*,int), void*); 函数可以定义一个回调函数，当出现数据库忙时，sqlite会调用该函数 当回调函数为ＮＵＬＬ时，清除busy handle，申请不到锁直接返回 回调函数的第二个函数会被传递为该由此次忙事件调用该函数的次数 回调函数返回非０,数据库会重试当前操作，返回０则当前操作返回SQLITE_BUSY 2&gt; 设定锁定时的等待时间 int sqlite3_busy_timeout(sqlite3*, 60); 定义一个毫秒数，当未到达该毫秒数时，sqlite会sleep并重试当前操作 如果超过ms毫秒，仍然申请不到需要的锁，当前操作返回sqlite_BUSY 当ms&lt;=0时，清除busy handle，申请不到锁直接返回]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS面试题12--绘图与动画]]></title>
    <url>%2F2018%2F09%2F12%2FiOS%E9%9D%A2%E8%AF%95%E9%A2%9812-%E7%BB%98%E5%9B%BE%E4%B8%8E%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[CAAnimation的层级结构 CAPropertyAnimation是CAAnimation的子类，也是个抽象类，要想创建动画对象，应该使用它的两个子类：CABasicAnimation和CAKeyframeAnimation 属性解析：keyPath：通过指定CALayer的一个属性名称为keyPath(NSString类型)，并且对CALayer的这个属性的值进行修改，达到相应的动画效果。比如，指定@”position”为keyPath，就修改CALayer的position属性的值，以达到平移的动画效果 CABasicAnimation，CAPropertyAnimation的子类 属性解析: fromValue：keyPath相应属性的初始值 toValue：keyPath相应属性的结束值 随着动画的进行，在长度为duration的持续时间内，keyPath相应属性的值从fromValue渐渐地变为toValue。如果fillMode=kCAFillModeForwards和removedOnComletion=NO，那么在动画执行完毕后，图层会保持显示动画执行后的状态。但在实质上，图层的属性值还是动画执行前的初始值，并没有真正被改变。比如，CALayer的position初始值为(0,0)，CABasicAnimation的fromValue为(10,10)，toValue为(100,100)，虽然动画执行完毕后图层保持在(100,100)这个位置，实质上图层的position还是为(0,0) CAKeyframeAnimation，CApropertyAnimation的子类，跟CABasicAnimation的区别是：CABasicAnimation只能从一个数值(fromValue)变到另一个数值(toValue)，而CAKeyframeAnimation会使用一个NSArray保存这些数值 属性解析： values：就是上述的NSArray对象。里面的元素称为”关键帧”(keyframe)。动画对象会在指定的时间(duration)内，依次显示values数组中的每一个关键帧 path：可以设置一个CGPathRef\CGMutablePathRef,让层跟着路径移动。path只对CALayer的anchorPoint和position起作用。如果你设置了path，那么values将被忽略 keyTimes：可以为对应的关键帧指定对应的时间点,其取值范围为0到1.0,keyTimes中的每一个时间值都对应values中的每一帧.当keyTimes没有设置的时候,各个关键帧的时间是平分的 CABasicAnimation可看做是最多只有2个关键帧的CAKeyframeAnimation CAAnimationGroup，CAAnimation的子类，可以保存一组动画对象，将CAAnimationGroup对象加入层后，组中所有动画对象可以同时并发运行 属性解析： animations：用来保存一组动画对象的NSArray 默认情况下，一组动画对象是同时运行的，也可以通过设置动画对象的beginTime属性来更改动画的开始时间 CATransition，CAAnimation的子类，用于做转场动画，能够为层提供移出屏幕和移入屏幕的动画效果。iOS比Mac OS X的转场动画效果少一点 UINavigationController就是通过CATransition实现了将控制器的视图推入屏幕的动画效果 属性解析: type：动画过渡类型 subtype：动画过渡方向 startProgress：动画起点(在整体动画的百分比) endProgress：动画终点(在整体动画的百分比) UIView动画 UIKit直接将动画集成到UIView类中，当内部的一些属性发生改变时，UIView将为这些改变提供动画支持 执行动画所需要的工作由UIView类自动完成，但仍要在希望执行动画时通知视图，为此需要将改变属性的代码放在[UIView beginAnimations:nil context:nil]和[UIView commitAnimations]之间 Block动画 帧动画 PNG 谈谈你对Core Graphic 绘图的了解? Core Graphics是基于C的API，可以用于一切绘图操作 Core Graphics 和Quartz 2D的区别 quartz是一个通用的术语，用于描述在IOS和MAC OS X ZHONG 整个媒体层用到的多种技术 包括图形、动画、音频、适配。 Quart 2D 是一组二位绘图和渲染API，Core Graphic会使用到这组API Quartz Core 专指Core Animation用到的动画相关的库、API和类 Core Graphics是高度集成于UIView和其他UIKit部分的。 Core Graphics数据结构和函数可以通过前缀CG来识别。 系统拥有坐标系，如320 480 硬件有retain屏幕和非retain屏：如320 480、640 960 Core Graphics 使用的是系统的坐标系来绘制图片。在分辨率为640 960手机上绘制图片时，实际上Core Graphics 的坐标是320*480。这个时候每个坐标系上的点，实际上拥有两个像素。 视图可以通过子视图、图层或实现drawRect：方法来表现内容，如果说实现了drawRect：方法，那么最好就不要混用其他方法了，如图层和子视图。自定义绘图大部分是由UIKit或者Core Graphics来实现的。 Core Graphics的优点：快速、高效，减小应用的文件大小。同时可以自由地使用动态的、高质量的图形图像。 使用Core Graphics，可以创建直线、路径、渐变、文字与图像等内容，并可以做变形处理 2D绘图一般可以拆分成以下几个操作: 线条 , 路径 , 文本 , 图片 , 渐变 由于像素是依赖于目标的，所以2D绘图并不能操作单独的像素，我们可以从上下文（Context）读取它。 绘图就好比在画布上拿着画笔机械的进行画画，通过制定不同的参数来进行不同的绘制。 http://www.tuicool.com/articles/jIJzMf http://blog.csdn.net/mangosnow/article/details/37054765 Core Animation(核心动画)? CoreAnimation也就是核心动画, 是一组非常强大的动画处理API, 可以使用少量的代码做出绚丽的效果, 是直接作用在CALayer上的, 并非UIView, 并且Core Animation的动画执行过程都是在后台操作, 不会阻塞主线程. 所有动画都是作用在CALayer上的, 当把动画添加到Layer上, 是不直接修改它的属性, Core Animation维护了两个平行layer的层次结构, 模型层树可以看到Layer的状态, 表示层树则是动画正在表现的值的近似。 Core Animation的使用步骤: 使用它需要先添加QuartzCore.framework框架和引入主头文件&lt;QuartzCore/QuartzCore.h&gt;(iOS7.0+ 不需要) 初始化一个CAAnimation对象，并设置一些动画相关属性 通过调用CALayer的addAnimation:forKey:方法增加CAAnimation对象到CALayer中，这样就能开始执行动画了 通过调用CALayer的removeAnimationForKey:方法可以停止CALayer中的动画 转场动画? CATransition-转场动画, 作为CAAnimation的子类，用于做转场动画，能够为层提供移出屏幕和移入屏幕的动画效果。iOS比Mac OS X的转场动画效果少一点. UINavigationController就是通CATransition实现了将控制器的视图推入屏幕的动画效果. Cocoa Touch提供了哪几种Core Animation过渡类型？ Cocoa Touch 提供了 4 种 Core Animation 过渡类型，分别为：交叉淡化、推挤、显示和覆盖。 使用UIView的动画函数, 实现转场动画 单视图: +(void)transitionWithView:(UIView* )view duration:(NSTimeInterval)duration options:(UIViewAnimationOptions)options animations:(void (^)(void))animations completion:(void (^)(BOOL finished))completion; 双视图: +(void)transitionFromView:(UIView )fromView toView:(UIView)toView duration:(NSTimeInterval)duration options:(UIViewAnimationOptions)options completion:(void (^)(BOOL finished))completion; 一个动画怎么实现? 以转场动画为例: 创建CATransition对象 CATransition *animation = [CATransition animation]; 设置运动时间(即动画时间) animation.duration = DURATION; 设置运动type(类型) animation.type = type; if (subtype != nil) { //设置子类 (和type配合使用, 指定运动的方向) animation.subtype = subtype;} 设置运动速度(动画的运动轨迹，用于变化起点和终点之间的插值计算,形象点说它决定了动画运行的节奏,比如是均匀变化(相同时间变化量相同)还是先快后慢,先慢后快还是先慢再快再慢) animation.timingFunction = UIViewAnimationOptionCurveEaseInOut; 将动画添加到view的Layer层 [view.layer addAnimation:animation forKey:@”animation”]; 动画类型如下: typedef enum : NSUInteger { Push, //推挤 Cube, //立方体 } AnimationType; 说说Core Animation是如何开始和结束动画的不是很清楚题目的真正要求，是想知道核心动画的哪些知识点。如何开始和结束动画，这核心动画有很多种，每种动画还有很大的区别。 参考答案： 动画的开始和结束都可以通过CAMediaTiming协议来处理，核心动画的基类是遵守了CAMediaTiming协议的，可以指定动画开始时间、动画时长、动画播放速度、动画在完成时的行为（停留在结束处、动画回到开始处、动画完成时移除动画）。 动画有基本类型有哪几种；表视图有哪几种基本样式。 动画有两种基本类型：一种为UIView动画,又称隐式动画,动画后frame的数值发生了变化.另一种是CALayer动画,又称显示动画,动画后模型层的数据不会发生变化,图形回到原来的位置。 UITableViewStylePlain：普通样式 UITableViewStyleGrouped:分组样式 UITableViewCellStyleDefault:Default样式：左边一个显示图片的imageView，一个标题textLabel，没有detailTextLabel。 UITableViewCellStyleSubtitle:Subtitle样式：左边一个显示图片的imageView，上边一个主标题textLabel，一个副标题detailTextLabel。主标题字体大且加黑，副标题字体小在主标题下边。 UITableViewCellStyleValue1:Value1样式：左边一个显示图片的imageView，左边一个主标题textLabel，右边一个副标题detailTextLabel，主标题字体比较黑。 UITableViewCellStyleValue2:Value2样式：左边一个主标题textLabel字体偏小，挨着右边一个副标题detailTextLabel，字体大且加黑。 CADisplayLink CADisplayLink是一种以屏幕刷新频率触发的时钟机制，每秒钟执行大约60次左右 CADisplayLink是一个计时器，可以使绘图代码与视图的刷新频率保持同步，而NSTimer无法确保计时器实际被触发的准确时间 使用方法： 定义CADisplayLink并制定触发调用方法 将显示链接添加到主运行循环队列 Quatrz 2D的绘图功能的三个核心概念是什么并简述其作用。上下文：主要用于描述图形写入哪里； 路径：是在图层上绘制的内容； 状态：用于保存配置变换的值、填充和轮廓， alpha 值等。 文章如有问题，请留言，我将及时更正。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS面试题11--第三方框架及其管理]]></title>
    <url>%2F2018%2F09%2F12%2FiOS%E9%9D%A2%E8%AF%95%E9%A2%9811-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6%E5%8F%8A%E5%85%B6%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[使用过CocoaPods吗？它是什么？CocoaPods的原理? CocoaPod是一个第三方库的管理工具，用来管理项目中的第三方框架。 在终端中进入（cd命令）你项目所在目录，然后在当前目录下，利用vim创建Podfile，运行： $ vim Podfile 然后在Podfile文件中输入以下文字： platform :ios, ‘9.3’ pod “AFNetworking”, “~&gt; 2.0” 然后保存退出。vim环境下，保存退出命令是 :wq 这时候，你会发现你的项目目录中，出现一个名字为Podfile的文件，而且文件内容就是你刚刚输入的内容。 这时候，你就可以利用CocoPods下载AFNetworking类库了,运行以下命令：$ pod install 用cocoapods管理第三方框架的时候我想改版本，怎么办到？ 可以直接或者终端打开Podfile, 修改Podfile文件中第三方框架的版本 集成三方框架有哪些方法 cocoapods framework 直接下载源码拖进项目用 SDWebImage的原理实现机制，如何解决TableView卡的问题?SDWebImage内部实现过程（建议画图记住） image 入口 setImageWithURL:placeholderImage:options: 会先把 placeholderImage 显示，然后 SDWebImageManager 根据 URL 开始处理图片。 进入 SDWebImageManager-downloadWithURL:delegate:options:userInfo:，交给 SDImageCache 从缓存查找图片是否已经下载 queryDiskCacheForKey:delegate:userInfo:. 先从内存图片缓存查找是否有图片，如果内存中已经有图片缓存，SDImageCacheDelegate 回调 imageCache:didFindImage:forKey:userInfo: 到 SDWebImageManager。 SDWebImageManagerDelegate 回调 webImageManager:didFinishWithImage: 到 UIImageView+WebCache 等前端展示图片。 如果内存缓存中没有，生成 NSInvocationOperation 添加到队列开始从硬盘查找图片是否已经缓存。 根据 URLKey 在硬盘缓存目录下尝试读取图片文件。这一步是在 NSOperation 进行的操作，所以回主线程进行结果回调 notifyDelegate:。 如果上一操作从硬盘读取到了图片，将图片添加到内存缓存中（如果空闲内存过小，会先清空内存缓存）。SDImageCacheDelegate 回调 imageCache:didFindImage:forKey:userInfo:。进而回调展示图片。 如果从硬盘缓存目录读取不到图片，说明所有缓存都不存在该图片，需要下载图片, 回调 imageCache:didNotFindImageForKey:userInfo:。 共享或重新生成一个下载器 SDWebImageDownloader 开始下载图片。 图片下载由 NSURLConnection 来做，实现相关 delegate 来判断图片下载中、下载完成和下载失败。 connection:didReceiveData: 中利用 ImageIO 做了按图片下载进度加载效果。 connectionDidFinishLoading: 数据下载完成后交给 SDWebImageDecoder 做图片解码处理。 图片解码处理在一个 NSOperationQueue 完成，不会拖慢主线程 UI。如果有需要对下载的图片进行二次处理，最好也在这里完成，效率会好很多。 在主线程 notifyDelegateOnMainThreadWithInfo: 宣告解码完成，imageDecoder:didFinishDecodingImage:userInfo: 回调给 SDWebImageDownloader。 imageDownloader:didFinishWithImage: 回调给 SDWebImageManager 告知图片下载完成。 通知所有的 downloadDelegates 下载完成，回调给需要的地方展示图片。 将图片保存到 SDImageCache 中，内存缓存和硬盘缓存同时保存。写文件到硬盘也在以单独 NSInvocationOperation 完成，避免拖慢主线程。 SDImageCache 在初始化的时候会注册一些消息通知，在内存警告或退到后台的时候清理内存图片缓存，应用结束的时候清理过期图片。 SDWI 也提供了 UIButton+WebCache 和 MKAnnotationView+WebCache，方便使用。 SDWebImagePrefetcher 可以预先下载图片，方便后续使用。 如何解决tableView卡顿问题，前面也提了很多方案。通过设置最大并发数, 设置当前页的cell, 而不是把所有cell一次性设置完, 以及数据图片的三级缓存, 直接保存在内存中和沙盒缓存中进行读取. 降低网络请求的次数, 不仅节约用户流量. 也会保证tableView滑动的流畅性 SDWebImage怎样实现图片的缓存机制的？ 图片的缓存, 内存缓存, 沙盒缓存, 操作缓存, 以tableViewController为例: 每次cell需要显示,都需要重新调用- (UITableViewCell )tableView:(UITableView )tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath { }方法 每次调用tableView显示行的数据源方法时, 如果需要从网络加载图片, 就需要将加载图片这样的耗时操作放在子线程上执行, 从网络上下载的图片可以以键值对的形式保存在定义的可变字典中,将每张图片的唯一的路径作为键,将从网络下载下来的图片作为值, 保存在内存缓存中, 这样每次滑动tableView cell重用时就直接判断内存缓存中有没有需要的图片, 如果有就不需要再次下载,在没有出现内存警告或者程序员手动清理内存缓存时, 就直接从内存缓存中获取图片. 为了每次退出程序,再次进入程序时,不浪费用户的流量, 需要将第一次进入程序时加载的图片保存在本地沙盒缓存文件中, 在沙盒中保存的图片数据没有被改变之前,下次开启程序就直接从沙盒的缓存文件中读取需要显示的图片, 并将沙盒缓存文件夹(Cache)中保存的图片保存到内存缓存中, 这样用户每次滑动tableView cell重用时直接从内存缓存中读取而不是从沙盒中读取, 节约时间. 你用过哪些第三方框架？ 使用过一些第三方框架, 例如AFN,SDWebimage,FMDB, MBProgressHUD, Masonry。 使用 AFNetworking做过断点续传吗？ 断点续传的主要思路: 检查服务器文件信息 检查本地文件 如果比服务器文件小, 断点续传, 利用 HTTP 请求头的 Range 实现断点续传 如果比服务器文件大，重新下载 如果和服务器文件一样，下载完成 使用第三方框架的时候有没有仔细研读过它们的源码(AFNetworking)？AFN底层原理分析。 AFNetworking主要是对NSURLSession和NSURLCollection（iOS9.0废弃）的封装,其中主要有以下类: AFHTTPRequestOperationManager :内部封装的是 NSUrlConnection,负责发送网络请求,使用最多的一个类.（3.0废弃） AFHTTPSessionManager :内部封装是 NSUrlSession ,负责发送网络请求,使用最多的一个类. AFHTTPRequestOperationManager 和 AFHTTPSessionManager :定义的 API(方法名称)是一模一样,没有任何区别. AFNetworkReachabilityManager :实时监测网络状态的工具类.当前的网络环境发生改变之后,这个工具类就可以检测到. AFSecurityPolicy :网络安全的工具类, 主要是针对 HTTPS 服务. AFURLRequestSerialization :序列化工具类,基类.上传的数据转换成JSON格式(AFJSONRequestSerializer).使用不多. AFURLResponseSerialization :反序列化工具类;基类.使用比较多: AFJSONResponseSerializer; JSON解析器,默认的解析器. AFHTTPResponseSerializer; 万能解析器; JSON和XML之外的数据类型,直接返回二进制数据.对服务器返回的数据不做任何处理. AFXMLParserResponseSerializer; XML解析器; AFN默认超时时长是多少啊? AFN的默认超时时长是60s. 举出5个以上你所熟悉的iOS sdk库有哪些和第三方库有哪些?1&gt; iOS-sdk: Foundation.framework, CoreGraphics.framework, UIKit.framework, MediaPlayer.framework, CoreAudio.framework 2&gt; 第三方库: 1.AFNetWoring 2.SDWebImage 3.masonry 4.MBProgressHUD 3&gt; 框架分类: 音频和视频 Core Audio OpenAL Media Library AVFoundation 数据管理 Core Data SQLite 图片和动画 Core Animation OpenGL ES Quartz 2D 网络 Bonjour WebKit BSD Sockets 用户应用 Address Book Core Location Map Kit Store Kit 第三方API是怎么用的？ 大公司的开放API,github上面别人发布的框架用第三方API, 在官方文档都有说明，按照官方文档的一步一步做参考官方提供的示例程序。先自己创建一个工程试试，等熟悉了，在使用到项目中 实现过框架或者库以供他人使用么？如果有，请谈一谈构建框架或者库时候的经验；如果没有，请设想和设计框架的public的API，并指出大概需要如何做、需要注意哪些问题，以使人人更容易地使用你的框架。从以下角度出发来思考和设计公共框架： • 确保外部调用简单，且保证有详细的头文件注释说明。 • 确保API编码规范，保证风格统一。 • 确保API易扩展，可以考虑预留参数 • 确保没有外部依赖或者依赖要尽可能的少，以保证公共库的纯洁（原则上不能有外部依赖） • 确保易维护，不存在冗余API 简述下苹果的开发框架？Foundation 提供OC的基础类（像NSObject）、基本数据类型等 UIKit 创建和管理应用程序的用户界面 QuartzCore 提供动画特效以及通过硬件进行渲染的能力 CoreGraphics 提供2D绘制的基于C的API SystemConfiguration 检测当前网络是否可用和硬件设备状态 AVFoundation 提供音频录制和回放的底层API，同时也负责管理音频硬件 CFNetwork 访问和配置网络，像HTTP、FTP和Bonjour Services CoreFoundation 提供抽象的常用数据类型，如Unicode strings、XML、URL等 CoreLocation 使用GPS和WIFI获取位置信息]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS面试题10--报错警告调试]]></title>
    <url>%2F2018%2F09%2F12%2FiOS%E9%9D%A2%E8%AF%95%E9%A2%9810-%E6%8A%A5%E9%94%99%E8%AD%A6%E5%91%8A%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[你在实际开发中，有哪些手机架构与性能调试经验 刚接手公司的旧项目时，模块特别多，而且几乎所有的代码都写在控制器里面，比如UI控件代码、网络请求代码、数据存储代码 接下来采取MVC模式进行封装、重构 自定义UI控件封装内部的业务逻辑 封装网络请求工具类(降低耦合) 封装数据存储工具类 BAD_ACCESS在什么情况下出现？这种问题是经常遇到的，在开发时经常会出现BAD_ACCESS。原因是访问了野指针，比如访问已经释放对象的成员变量或者发消息、死循环等。 如何调试BAD_ACCESS错误？出现BAD_ACCESS错误，通常是访问了野指针，比如访问了已经释放了的对象。快速定位问题的步骤有： 1. 重写对象的respondsToSelector方法，先找到出现EXECBADACCESS前访问的最后一个object 2. 设置Enable Zombie Objects 3. 设置全局断点快速定位问题代码所在行，接收所有的异常 4. Xcode7已经集成了BAD_ACCESS捕获功能：Address Sanitizer，与步骤2一样设置 5. analyze也行（不一定管用） 什么时候会报 unrecognized selector 异常？ 当调用对象（子类，各级父类）中不含有对应方法的时候，并且依旧没有给出“消息转发”的具体方案的时候，程序在运行时会crash并抛出 unrecognized selector 异常 objective-c 中的每个方法在运行时会被转为消息发送objc_msgSend(reciver, selector) 例如 [person say]就会被转化为 objc_msgSend(person, @selector(say)) 运行时会根据对象(reciever) 的isa 指针找到该对象所对应的类，然后会依次在对应的类，父类，爷爷类，根类中找对应的方法 下面只讲述对象方法的解析过程： 第一步：+ (BOOL)resolveInstanceMethod:(SEL)sel实现方法，指定是否动态添加方法。若返回NO，则进入下一步，若返回YES，则通过class_addMethod函数动态地添加方法，消息得到处理，此流程完毕。 第二步：在第一步返回的是NO时，就会进入- (id)forwardingTargetForSelector:(SEL)aSelector方法，这是运行时给我们的第二次机会，用于指定哪个对象响应这个selector。不能指定为self。若返回nil，表示没有响应者，则会进入第三步。若返回某个对象，则会调用该对象的方法。 第三步：若第二步返回的是nil，则我们首先要通过- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector指定方法签名，若返回nil，则表示不处理。若返回方法签名，则会进入下一步。 第四步：当第三步返回方法方法签名后，就会调用- (void)forwardInvocation:(NSInvocation *)anInvocation方法，我们可以通过anInvocation对象做很多处理，比如修改实现方法，修改响应对象等 第五步：若没有实现- (void)forwardInvocation:(NSInvocation *)anInvocation方法，那么会进入- (void)doesNotRecognizeSelector:(SEL)aSelector方法。若我们没有实现这个方法，那么就会crash，然后提示打不到响应的方法。到此，动态解析的流程就结束了。 有哪些常见的 Crash 场景？ 访问了僵尸对象 访问了不存在的方法 数组越界 在定时器下一次回调前将定时器释放,会Crash lldb（gdb）常用的调试命令？• p 输出基本类型//p (int)[[[self view] subviews] count] • po 用于输出 Objective-C 对象//po [self view] • expr 可以在调试时动态执行指定表达式，并将结果打印出来。常用于在调试过程中修改变量的值。//源代码中 a = 1 ；expr a=2 输出结果：(int) $0 = 2 如果一个函数10次中有7次正确，3次错误，问题可能出现在哪里？这样的问题通过应聘者的分析，可以知道应聘者的功底如何。很多人的回答会是很简单的，没有从多方面去分析。这样的问题也是很有意义的，在项目开发中所产生的bug，有的时候会出现这样的情况，而代码量比较大且业务比较复杂时，通过其他工具并不能分析出来是什么bug，但是我们却可以根据出现的频率推测。笔者把这个问题当作测试部反馈过来的bug描述问题来分析一下。 参考答案： 从问题描述可知，bug不会必现的，因此无法直接定位出错之处。从以下角度出现来分析可能出错之处： 1. 因出错并不是崩溃，因此没有错误日志可看。第一步就是分析函数中的所有分支，是否在语法上存在可能缺少条件的问题。所以，检查所有的分支，确保每个分支执行的结果的正确的 2. 检测函数的参数，保证必传参数不能为空，若为空应该抛出异常。因此，用断言检测参数的正确性是很重要的。 3. 检测函数中每个分支所调用的函数返回结果是正确的，其实就是一个递归的过程（步骤1、2） 你一般是如何调试Bug的？这个问题看起来很笼统，但又一针见血。通过应聘者的回答，可很直观地看出这个应聘者的处理bug的能力，以及其解决问题的思维。 参考答案： Bug分为测试中的Bug和线上的Bug： • 线上Bug：项目使用了友盟统计，因此会有崩溃日志，通过解析dYSM可以直接定位到大部分bug崩溃之处。解决线上bug需要从主干拉一个新的分支，解决bug并测试通过后，再合并到主干，然后上线。若是多团队开发，可以将fix bug分支与其他团队最近要上线的分支集成，然后集成测试再上线。 • 测试Bug：根据测试所反馈的bug描述，若语义不清晰，则直接找到提bug人，操作给开发人员看，最好是可以bug复现。解决bug时，若能根据描述直接定位bug出错之处，则好处理；若无法直观定位，则根据bug类型分几种处理方式，比如崩溃的bug可以通过instruments来检测、数据显示错误的bug，则需要阅读代码一步步查看逻辑哪里写错。 对于开发中出现的崩溃或者数据显示不正常，那就需要根据经验或者相关工具来检测可能出错之处。当然，团队内沟通解决是最好的。 获取一台设备唯一标识的方法有哪些？ 现在常用的是用UUID + keychain结合来实现这个需求。 UUID是Universally Unique Identifier的缩写，中文意思是通用唯一识别码。它是让分布式系统中的所有元素，都能有唯一的辨识资讯，而不需要透过中央控制端来做辨识资讯的指定。这样，每个人都可以建立不与其它人冲突的 UUID。在此情况下，就不需考虑数据库建立时的名称重复问题。苹果公司建议使用UUID为应用生成唯一标识字符串。 //获取一个UUID - (NSString*)uuid { CFUUIDRef uuid = CFUUIDCreate( nil ); CFStringRef uuidString = CFUUIDCreateString( nil, uuid ); NSString * result = (NSString *)CFBridgingRelease(CFStringCreateCopy( NULL, uuidString)); CFRelease(uuid); CFRelease(uuidString); return result; } 现在我们获取到了一个UUID，虽然这个标识是唯一的，但是这样还是无法保证每一次的唯一性，因为当你每次调用这个方法或者把应用卸载了，UUID会重新生成一个不同的。这个时候keychain就起到了作用。 所以整个逻辑是这样的：先从keychain取UUID，如果能取到，就用这个比对，如果取不到就重新生成一个保存起来。keychain独立在App之外，是和系统统一等级的，所以你不用担心它挂掉。 keychain是苹果公司Mac OS中的密码管理系统。它在Mac OS 8.6中被导入，并且包括在了所有后续的Mac OS版本中，包括Mac OS X。一个钥匙串可以包含多种类型的数据：密码（包括网站，FTP服务器，SSH帐户，网络共享，无线网络，群组软件，加密磁盘镜像等），私钥，电子证书和加密笔记等。iOS端同样有个keychain帮助我们管理这些敏感信息。 使用过keychain保存过账号密码的童鞋应该对这个工具非常了解，在这里不做过多解释。使用keychain需要导入Security.framework和KeychainItemWrapper.h/.m，KeychainItemWrapper.h/.m搜一下可以下载下来，拖入工程中。保存UUID代码如下： - (void)saveUuidWithKeyChain { KeychainItemWrapper *keychainItem = [[KeychainItemWrapper alloc] initWithIdentifier:@"UUID" accessGroup:@"com.xxx.www"]; NSString *strUUID = [keychainItem objectForKey:(id)kSecValueData]; if (strUUID == nil || [strUUID isEqualToString:@""]) { [keychainItem setObject:[self uuid] forKey:(id)kSecValueData]; } } 注：这个方法中accessGroup:这个参数如果一些App设置相同的话，是可以共享的。 从keychain获取UUID的方法如下： - (NSString *)getKeychain { KeychainItemWrapper *keychainItem = [[KeychainItemWrapper alloc] initWithIdentifier:@"UUID" accessGroup:@"com.xxx.www"]; NSString *strUUID = [keychainItem objectForKey:(id)kSecValueData]; return strUUID; } 至此，基本上唯一标识的几个方法算是写完了，大家可以测试一下，卸载应用再重新装，从keychain读取的UUID还是和之前一样。 但这里有个不确定因素，就是手机系统恢复出厂设置或者抹掉所有数据的话，这个方法也可能不起作用了，因为它是依靠钥匙串在生存，钥匙串挂掉的话它也就失效了。 你一般是怎么用 Instruments 的？ 这个问题也就是考察下你经验如何了, Instruments里面工具很多,也没必要逐一说明,挑几个常用的说下就好 参考答案: Time Profiler:性能分析 Zombies:检查是否访问了僵尸对象,但是这个工具只能从上往下检查,不智能 Allocations:用来检查内存,写算法的那批人也用这个来检查 Leaks:检查内存,看是否有内存泄露 你一般是如何调试 Bug 的？ 查看异常报告 配置相关环境，重现bug 代码检查 用测试案例来捕获bug 可以请同事一同来审查问题，有些时候当局者迷，旁观者清。 如何对iOS设备进行性能测试?Profile-&gt; Instruments -&gt;Time Profiler 进行性能测试！ 测试iOS版的 App 注意事项分享以下几点： 1.app使用过程中，接听电话。可以测试不同的通话时间的长短，对于通话结束后，原先打开的app的响应，比如是否停留在原先界面，继续操作时的相应速度等。 2.app使用过程中，有推送消息时，对app的使用影响 3.设备在充电时，app的响应以及操作流畅度 4.设备在不同电量时(低于10%，50%，95%)，app的响应以及操作流畅度 5.意外断电时，app数据丢失情况 6.网络环境变化时，app的应对情况如何：是否有适当提示?从有网络环境到无网络环境时，app的反馈如何?从无网络环境回到有网络环境时，是否能自动加载数据，多久才能开始加载数据 7.多点触摸的情况 8.跟其他app之间互相切换时的响应 9.进程关闭再重新打开的反馈 10.IOS系统语言环境变化时]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS面试题9--UI]]></title>
    <url>%2F2018%2F09%2F12%2FiOS%E9%9D%A2%E8%AF%95%E9%A2%989-UI%2F</url>
    <content type="text"><![CDATA[viewcontroller的一些方法的说明viewDidLoad,viewWillDisappear, viewWillAppear方法的 顺序和作用？viewWillAppear:视图即将可见时调用。默认情况下不执行任何操作 viewDidAppear:视图已完全过渡到屏幕上时调用 viewWillDisappear:视图被驳回时调用，覆盖或以其他方式隐藏。默认情况下不执行任何操作 viewDidDisappear:视图被驳回后调用，覆盖或以其他方式隐藏。默认情况下不执行任何操作loadView; .这是当他们没有正在使用nib视图页面，子类将会创建自己的自定义视图层。绝不能直接调用。 viewDidLoad:在视图加载后被调用，如果是在代码中创建的视图加载器，他将会在loadView方法后被调用，如果是从nib视图页面输出，他将会在视图设置好后后被调用。 「initWithNibName: bundle:」载入nib档案来初始化「loadView」载入视图「viewDidLoad」在载入视图至内存后会呼叫的方法「viewDidUnload」在视图从内存中释放后会呼叫的方法 (当内存过低，释放一些不需要的视图时调用) 「viewWillAppear」当收到视图在视窗将可见时的通知会呼叫的方法 「viewDidAppear」当收到视图在视窗已可见时的通知会呼叫的方法 「viewWillDisappear」当收到视图将去除、被覆盖或隐藏于视窗时的通知会呼叫的方法 「viewDidDisappear」当收到视图已去除、被覆盖或隐藏于视窗时的通知会呼叫的方法 「didReceiveMemoryWarning」收到系统传来的内存警告通知后会执行的方法 「shouldAutorotateToInterfaceOrientation」是否支持不同方向的旋转视图 「willAnimateRotationToInterfaceOrientation」在进行旋转视图前的会执行的方法（用于调整旋转视图之用） 代码的执行顺序 1、 alloc 创建对象，分配空间 2、init (initWithNibName) 初始化对象，初始化数据 3、loadView 从nib载入视图 ，通常这一步不需要去干涉。除非你没有使用xib文件创建视图 4、viewDidLoad 载入完成，可以进行自定义数据以及动态创建其他控件 5、viewWillAppear 视图将出现在屏幕之前，马上这个视图就会被展现在屏幕上了 6、viewDidAppear 视图已在屏幕上渲染完成当一个视图被移除屏幕并且销毁的时候的执行顺序，这个顺序差不多和上面的相反 1、viewWillDisappear 视图将被从屏幕上移除之前执行 2、viewDidDisappear 视图已经被从屏幕上移除，用户看不到这个视图了 3、dealloc 视图被销毁，此处需要对你在init和viewDidLoad中创建的对象进行释放 什么是key window？ 一个窗口当前能接受键盘和非触摸事件时，便被认为是主窗口。而触摸事件则被投递到触摸发生的窗口，没有相应坐标值的事件被投递到主窗口。同一时刻只有一个窗口是主窗口。 谈一谈你是怎么封装view的- 先添加所需子控件 - 再接收模型数据根据模型数据设置子控件数据和位置 - 简而言之, 自己的事情自己做, 把不需要暴露出去的封装起来 简单说一下APP的启动过程,从main文件开始说起程序启动分为两类:1.有storyboard 2.没有storyboard 有storyboard情况下: 1.main函数 2.UIApplicationMain * 创建UIApplication对象 * 创建UIApplication的delegate对象 3.根据Info.plist获得Main.storyboard的文件名,加载Main.storyboard(有storyboard) * 创建UIWindow * 创建和设置UIWindow的rootViewController * 显示窗口 没有storyboard情况下: 1.main函数 2.UIApplicationMain * 创建UIApplication对象 * 创建UIApplication的delegate对象 3.delegate对象开始处理(监听)系统事件(没有storyboard) * 程序启动完毕的时候, 就会调用代理的application:didFinishLaunchingWithOptions:方法 * 在application:didFinishLaunchingWithOptions:中创建UIWindow * 创建和设置UIWindow的rootViewController * 显示窗口 怎么解决缓存池满的问题(cell)iOS中不存在缓存池满的情况，因为通常我们ios中开发，对象都是在需要的时候才会创建，有种常用的说话叫做懒加载，还有在UITableView中一般只会创建刚开始出现在屏幕中的cell，之后都是从缓存池里取，不会在创建新对象。缓存池里最多也就一两个对象，缓存池满的这种情况一般在开发java中比较常见，java中一般把最近最少使用的对象先释放。 UIButton与UITableView的层级结构 继承结构，属于内部的子控件结构 UIButton为：UIButton &gt; UIControl &gt; UIView &gt; UIResponder &gt; NSObject UITableView为：UITableView &gt; UIScrollView &gt; UIView &gt; UIResponder &gt; NSObject 设置scroll view的contensize能在Viewdidload里设置么,为什么 一般情况下可以设置在viewDidLoad中，但在autolayout下，系统会在viewDidAppear之前根据subview的constraint重新计算scrollview的contentsize。 这就是为什么，在viewdidload里面手动设置了contentsize没用。因为在后面，会再重新计算一次，前面手动设置的值会被覆盖掉。 解决办法就是： 去除autolayout选项，自己手动设置contentsize 如果要使用autolayout，要么自己设置完subview的constraint，然后让系统自动根据constraint计算出contentsize。要么就在viewDidAppear里面自己手动设置contentsize。 简述你对UIView、UIWindow和CALayer的理解 UIView: 属于UIkit.framework框架,负责渲染矩形区域的内容,为矩形区域添加动画,响应区域的触摸事件,布局和管理一个或多个子视图 UIWindow:属于UIKit.framework框架,是一种特殊的UIView,通常在一个程序中只会有一个UIWindow,但可以手动创建多个UIWindow,同时加到程序里面。UIWindow在程序中主要起到三个作用: 作为容器,包含app所要显示的所有视图 传递触摸消息到程序中view和其他对象 与UIViewController协同工作,方便完成设备方向旋转的支持 CAlayer:属于QuartzCore.framework,是用来绘制内容的,对内容进行动画处理依赖与UIView来进行显示,不能处理用户事件。 UIView和CALayer是相互依赖的,UIView依赖CALayer提供内容,CALayer依赖UIView的容器显示绘制内容。 (补充)UIViewController:每个视图控制器都有一个自带的视图,并且负责这个视图相关的一切事务。方便管理视图中的子视图,负责model与view的通信;检测设备旋转以及内存警告;是所有视图控制类的积累,定义了控制器的基本功能。 frame和bounds有什么不同？(Difference between frame and bounds?) frame指的是：该view在父view坐标系统中的位置和大小（参照点是父亲的坐标系统） bounds指的是：该view在本身坐标系统中的位置和大小（参照点是本身坐标系统） 关于页面间传值的问题?属性传值：A页面设置属性 NSString *paramString，在跳转B页面的时候初始化paramString。 //A页面.h文件 @property (nonatomic, copy)NSString *paramString; //A页面.m文件 NextViewController *nextVC = [[NextViewController alloc] init]; nextVC.paramString = @"参数传质"; [self presentViewController:nextVC animated:YES completion:nil]; 委托delegate传值：在B页面定义delegate，并且设置delegate属性，在A页面实现delegate协议 通知notification传值：在B页面中发送通知，在A页面注册观察者并且在不用的时候移除观察者。 //B页面发送通知 [[NSNotificationCenter defaultCenter] postNotificationName:@"ChangeNameNotification" object:self userInfo:@{@"name":self.nameTextField.text}]; [self dismissViewControllerAnimated:YES completion:nil]; //A页面注册观察者 [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(ChangeNameNotification:) name:@"ChangeNameNotification" object:nil]; } //观察到通知时候的处理方法 -(void)ChangeNameNotification:(NSNotification*)notification{ NSDictionary *nameDictionary = [notification userInfo]; self.nameLabel.text = [nameDictionary objectForKey:@"name"]; } //通知不使用的时候移除观察者 [[NSNotificationCenter defaultCenter] removeObserver:self]; block传值：在B页面定义一个block类型的变量，在B页面跳转A的时候调用这个block。在A页面跳转到B页面的时候对B页面的block赋值。 //B页面定义block，并设置block类型的变量 typedef void (^ablock)(NSString *str); @property (nonatomic, copy) ablock block; //B页面跳转到A页面调用这个block self.block(self.nameTextField.text); [self dismissViewControllerAnimated:YES completion:nil]; //A页面跳转到B页面的时候对B页面的block赋值，这样在B页面跳转的时候就会回调这个block函数 [self presentViewController:second animated:YES completion:nil]; second.block = ^(NSString *str){ self.nameLabel.text = str; }; kvo传值：在A页面设置B页面的变量second，并且对这个变量进行观察 - (void)addObserver:(NSObject * _Nonnull)anObserver forKeyPath:(NSString * _Nonnull)keyPath options:(NSKeyValueObservingOptions)options context:(void * _Nullable)context 并在A页面实现 - (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context方法。 在B页面对变量keyPath进行设置，在A页面都会观察的到。 @property (nonatomic, strong) SecondViewController *second; //在A视图跳转到B视图的地方添加如下代码 self.second = [[SecondViewController alloc] initWithNibName:@"SecondViewController" bundle:nil]; [self.second addObserver:self forKeyPath:@"userName" options:NSKeyValueObservingOptionNew context:nil]; [self presentViewController:self.second animated:YES completion:nil]; //实现这个观察对象的方法 -(void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context //在B页面对userName进行设置，在A页面都可以间听到 单例模式传值：通过全局的方式保存 对于通知代理面试常问, 代理和通知分别在什么情况下使用? 区别? 各自优点? 关于视图的生命周期的问题 首先判断控制器是否有视图，如果没有就调用loadView方法创建：通过storyboard或者代码； 随后调用viewDidLoad，可以进行下一步的初始化操作；只会被调用一次； 在视图显示之前调用viewWillAppear；该函数可以多次调用； 视图viewDidAppear 在视图显示之前调用viewWillDisappear；该函数可以多次调用；如需要）； 在布局变化前后，调用viewWill/DidLayoutSubviews处理相关信息； 视图生命周期图 响应者链条? (What is responder chain?) 事件响应链。包括点击事件，画面刷新事件等。在视图栈内从上至下，或者从下之上传播. 可以说点事件的分发，传递以及处理。具体可以去看下touch事件这块。 首先解释响应者链的概念 UIResponder类，是UIKIT中一个用于处理事件响应的基类。窗口上的所有事件触发，都由该类响应（即事件处理入口）。所以，窗口上的View及控制器都是派生于该类的，例如UIView、UIViewController等。 调用UIResponder类提供的方法或属性，我们就可以捕捉到窗口上的所有响应事件，并进行处理。 响应者链条是由多个响应者对象连接起来的链条，其中响应者对象是能处理事件的对象，所有的View和ViewController都是响应者对象，利用响应者链条能让多个控件处理同一个触摸事件. 事件传递机制 image 如果当前view不能处理当前事件，那么事件将会沿着响应者链(Responder Chain)进行传递，知道遇到能处理该事件的响应者(Responsder Object)。 - 接收事件的initial view如果不能处理该事件并且她不是顶层的View，则事件会往它的父View进行传递。 - initial view的父View获取事件后如果仍不能处理，则继续往上传递，循环这个过程。如果顶层的View还是不能处理这个事件的话，则会将事件传递给它们的ViewController， - 如果ViewController也不能处理，则传递给Window(UIWindow)，此时Window不能处理的话就将事件传递UIApplication，最后如果连Application也不能处理，则废弃该事件 ViewController的loadView,viewDidLoad,viewDidUnload分别是在什么时候调用的？在自定义ViewController的时候这几个函数里面应该做什么工作？ viewDidLoad在view从nib文件初始化时调用， loadView在controller的view为nil时调用。 此方法在编程实现view时调用, view控制器默认会注册memory warning notification,当viewcontroller的任何view没有用的时候，viewDidUnload会被调用，在这里实现将retain的view release,如果是retain的IBOutlet view属性则不要在这里release,IBOutlet会负责release。 UITableView的重用机制?(或者如何在一个view上显示多个tableView,tableView要求不同的数据源以及不同的样式 (要求自定义cell), 如何组织各个tableView的delegate和dataSource?请说说实现思路?) 查看UITableView头文件,会找到NSMutableArray visiableCells,和NSMutableArray reusableTableCells两个结构。 visiableCells内保存当前显示的cells,reusableTableCells保存可重用的cells。 TableView显示之初,reusableTableCells为空,那么 [tableView dequeueReusableCellWithIdentifier:CellIdentifier]返回nil。 开始的cell都是通过 [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:CellIdentifier] 来创建,而且cellForRowAtIndexPath只是调用最大显示cell数的次数。 比如:有100条数据,iPhone一屏最多显示10个cell。 程序最开始显示TableView的情况是: 用[[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:CellIdentifier]创建10次cell,并给cell指定同样的重用标识(当然,可以为不同显示类型的cell指定不同的标识)。并且10个cell全部都加入到visiableCells数组,reusableTableCells为空。 向下拖动tableView,当cell1完全移出屏幕,并且cell11(它也是alloc出来的,原因同上)完全显示出来的时候。cell11加入到visiableCells,cell1移出visiableCells,cell1加入到reusableTableCells。 接着向下拖动tableView,因为reusableTableCells中已经有值,所以,当需要显示新的cell, cellForRowAtIndexPath再次被调用的时候,[tableView dequeueReusableCellWithIdentifier:CellIdentifier],返回cell1。 cell1加入到visiableCells,cell1 移出reusableTableCells;cell2移出 visiableCells,cell2加入到reusableTableCells。之后再需要显示的Cell就可 以正常重用了. 注意：配置Cell的时候一定要注意，对取出的重用的cell做重新赋值，不要遗留老数据。 在一个tableView中需要自定义多种样式的cell(两种或三种),通常你如何实现,说说思路即可? 同上！ UITableView的性能优化? 滑动的时候有种卡的感觉是为什么？怎么解决？ 在使用第三方应用时，却经常遇到性能上的问题，普遍表现在滚动时比较卡，特别是cell中包含图片的情况时。 实际上针对性地优化一下就可以解决tableView滑动的时候卡顿的问题: 使用不透明视图。不透明的视图可以提高渲染的速度。可以将cell及其子视图的opaque属性设为YES（默认值）。 不要重复创建不必要的cell。UITableView只需要一屏幕的UITableViewCell对象即可。因此在cell不可见时，可以将其缓存起来，而在需要时继续使用它即可。注意：cell被重用时，需要调用setNeedsDisplayInRect:或setNeedsDisplay方法重绘cell。 减少动画效果的使用，最好不要使用insertRowsAtIndexPaths:withRowAnimation:方法，而是直接调用reloadData方法。 减少视图的数目。Cell包含了textLabel、detailTextLabel和imageView等view，而你还可以自定义一些视图放在它的contentView里，创建它会消耗较多资源，并且也影响渲染的性能。 cell包含图片，且数目较多，使用自定义的cell速度会比使用默认的要快。继承UITableViewCell，重写drawRect方法：- (void)drawRect:(CGRect)rect { if (image) { [image drawAtPoint:imagePoint]; self.image = nil; } else { [placeHolder drawAtPoint:imagePoint]; } [text drawInRect:textRect withFont:font lineBreakMode:UILineBreakModeTailTruncation]; } 不过这样一来，你会发现选中一行后，这个cell就变蓝了，其中的内容就被挡住了。最简单的方法就是将cell的selectionStyle属性设为UITableViewCellSelectionStyleNone，这样就不会被高亮了。 -不需要与用户交互时，使用CALayer，将内容绘制到layer上，然后对cell的contentView.layer调用addSublayer:方法。这个例子中，layer并不会显著影响性能，但如果layer透明，或者有圆角、变形等效果，就会影响到绘制速度了。解决办法可参见后面的预渲染图像。 不要做多余的绘制工作。在实现drawRect:的时候，它的rect参数就是需要绘制的区域，这个区域之外的不需要进行绘制。 预渲染图像。你会发现即使做到了上述几点，当新的图像出现时，仍然会有短暂的停顿现象。解决的办法就是在图形上下文中画，导出成UIImage对象，然后再绘制到屏幕。（头像圆角，或者其他变形的时候，用图形上下文能提高性能。）异步绘制 不要阻塞主线程。tableview在更新数据时，整个界面卡住不动，完全不响应用户请求。常见的是网络请求，等待时间长待数秒。 解决方案：使用多线程，让子线程去执行这些函数或方法。 注意：当下载线程数超过2时，会显著影响主线程的性能。所以在不需要响应用户请求时，下载线程数可以增加到5，不建议再加了，以加快下载速度。如果用户正在交互，应把线程数量控制在2个以内。 提前计算并缓存好高度，因为heightforrowatindexpath调用非常频繁 选择正确的数据结构：学会选择对业务场景最合适的数组结构是写出高效代码的基础。比如，数组: 有序的一组值。使用索引来查询很快，使用值查询很慢，插入/删除很慢。字典: 存储键值对，用键来查找比较快。集合: 无序的一组值，用值来查找很快，插入/删除很快。 gzip/zip压缩：当从服务端下载相关附件时，可以通过gzip/zip压缩后再下载，使得内存更小，下载速度也更快。 tableview的cell里如何嵌套collection view？思路同网易新闻类似,用自定义的继承自UITableViewCell的类,在initWithFrame的构造方法中, 初始化自定义的继承自UICollectionView的类 下拉和上拉的原理? 以tableView的上拉刷新为例: 为了进行无缝阅读, 通过tableView的代理方法, willDisplayCell判断是否是最后一行, 如果是最后一行, 在显示最后一行的同时, 判断当前是否存在上拉刷新 如果当前没有上拉刷新, 就进行加载数据, 启动小菊花转啊转。 以tableView的下拉刷新为例: 判断当前的上拉刷新视图是否动画 如果没有动画, 就不是上拉刷新 然后下拉刷新加载数据 加载完毕数据关闭刷新 如何实现cell的动态的行高？ 如果希望每条数据显示自身的行高, 必须设置两个属性, 1.预估行高, 2.自定义行高 设置预估行高 tableView.estimatedRowHeight = 200 设置定义行高 tableView.rowHeight = UITableViewAutomaticDimension 如果要让自定义行高有效, 必须让容器视图有一个自下而上的约束 谈谈webView iOS开发中webview和native code的配合上的一些经验和技巧。 webview与运维成本低，更新几乎不依赖App的版本；但在交互和性能上与跟native code有很大差距。 native code与之对应。 HTML5确实给web带入了一个新时代。这个时代是什么，web app。也就是说，只有脱离native的这个前提，在浏览器的环境下，HTML5的意义才能显现，而我们讨论iOS App的时候，HTML5显然没什么意义。 不管是用webview还是native code，两个原则： 用户体验不打折 运维成本低 为什么不提开发成本。因为做web开发和iOS开发根本就是两回事。当然，web开发发展了这么多年，对于某些功能实现是要比native app快。但多数情况，同一个功能，对于iOS开发者和web开发者，用各自擅长的方式开发成本都最低，所以说某个功能开发成本低，往往是一个伪命题。 刚刚说了，webview的优势在于更新不依赖版本，那么在一款App中，只有会频繁更新的界面考虑webview才有意义。那么哪些界面会频繁更新，这就要因App而异了。 首页。首页资源可谓必争之地，内容一天一换是正常现象，一天几换也不稀奇。而如果仅仅是内容的更换，非要上个webview就显得有些激进了。而事实上首页的变化千奇百怪，逢年过节变个脸，特殊情况挂个公告，偶尔还要特批强推一把某个业务，等等。此前，我在设计App首页的时候，把首页配置设计的非常复杂。App端要处理n种情况，n各参数，server端要记住n种规则，直到一天，我崩溃了，把首页完全换成webview，才豁然开朗。 活动页。做互联网都知道，活动，是一个最常见的运营手段。特点是，周期短，功能少，但基本不能复用。这些特点都标识了活动不适合做native，要用webview实现。即使有人告诉你说，我的活动是一个长期活动而且形式不变，也不要相信他。因为在第二期，第三期，第四期他会分别加上一些非常诡异，却有很合理的小变更，而这些变更是你在那个版本根本无法实现的。 试水的新功能。这种界面，往往设计不成熟，需要在运行过程中不断收集用户反馈，更新升级，甚至决定去留。所以，只有webview才能hold住如此不稳定的功能。切记在一个功能还没有确定之前，不要大张旗鼓单位开发native code，要知道，你写的这些代码，三天后就要改一遍，而且要发布上线。 富文本内容。这个不用多说了吧，按照HTML的常用标签做一个webtext可不是小工程。而且富文本的变化太多了，一点无法匹配，都会导致整个界面巨丑。 OK，上边说了我认为最该使用webview的4个界面，分别带有不同的特点，但webview的交互是个短板，因此webview在一个App中，只能作为界面，不允许在界面中出现动作。而一个webview的界面如何跟native code结合起来呢，我的答案是，超链接。在webview上点击超链接，会调用webview delegate的shouldload方法，自这里拦截请求，进行处理。由于webview的链接都是URL，因此我建议，把整个App的界面都用URL管理起来。 长相问题，webview很难长成native的view。方案：长不成也要装成。在一些情况下，禁用webview滚动，使用滚动框架（iScroll不错）去实现。webview上下留出200pixel的空白背景，y从-200开始。否则大家知道，webview上下会有阴影的背景，不藏起来会很丑。等等，还有很多其他的方法去伪装webview，是要视情景而用。 cell中嵌套webview，在oc中调用js获取web的高度， CGFloat height = [[self.webView stringByEvaluatingJavaScriptFromString:@”document.body.offsetHeight”] floatValue];在通过webViewDidFinishLoad里面更新行高。 awakeFromNib与viewdidload区别 awakefromnib：当.nib文件被加载的时候，会发送一个awakefromnib消息到.nib文件中的每个对象，每个对象都可以定义自己的awakefromnib函数来响应这个消息，执行必要操作。也就是说 通过.nib文件创建view对象执行awakefromnib viewdidload：当view对象被加载到内存就会执行viewdidload，不管是通过nib还是代码形式，创建对象就会执行viewdidload layoutSubview何时调用? 初始化init方法时不会触发 滚动uiscrollview触发 旋转屏幕触发 改变view的值触发，前提是frame改变了 改变uiview的大小触发 viewcontroller的didreceivememorywaring在什么时候调用 默认操作是什么 应用程序收到来自系统的内存警告时，调用didreceivememorywaring方法 默认做法：控制器上的view不再窗口上显示时，调用viewWillUnload，直接销毁view，并调用viewdidunload UIWindow和UIView和 CALayer 的联系和区别? UIView是视图的基类，UIViewController是视图控制器的基类，UIResponder是表示一个可以在屏幕上响应触摸事件的对象； UIwindow是UIView的子类，UIWindow的主要作用：一是提供一个区域来显示UIView，二是将事件（event）的分发给UIView，一个应用基本上只有一个UIWindow. 图层不会直接渲染到屏幕上，UIView是iOS系统中界面元素的基础，所有的界面元素都是继承自它。它本身完全是由CoreAnimation来实现的。它真正的绘图部分，是由一个CALayer类来管理。UIView本身更像是一个CALayer的管理器。一个UIView上可以有n个CALayer，每个layer显示一种东西，增强UIView的展现能力。 都可以显示屏幕效果 如果需要用户交互就要用UIVIew,其可接收触摸事件(继承UIResponder),而CALayer不能接收触摸事件 如果没有用户交互可选用CALayer,因为其所在库较小,占用的资源较少 UIScrollView contentsize 内容视图的尺寸 contentoffset 内容视图当前位置相对滚动视图frame的偏移量 contentinset 内容视图相对滚动视图frame的展示原点 如何实现瀑布流,流水布局 使用UICollectionView 使用自定义的FlowLayout 需要在layoutAttributesForElementsInRect中设置自定义的布局(item的frame) 在 prepareLayout中计算布局 遍历数据内容,根据索引取出对应的attributes(使用layoutAttributesForCellWithIndexPath),根据九宫格算法设置布局 细节1: 实时布局,重写shouldInvalidateLayoutForBoundsChange(bounds改变重新布局,scrollview的contentoffset&gt;bounds) 细节2: 计算设置itemsize(保证内容显示完整,uicollectionview的content size是根据itemize计算的),根据列最大高度/对应列数量求出,最大高度累加得到 细节3: 追加item到最短列,避免底部参差不齐. UIImage有哪几种加载方式 二进制 imageWithData Bundle imageWithName 本地路径 imageWithContentOfFile 描述九宫格算法 NSInteger col = x;//定义列数 NSInteger index = self.shopsView.subviews.count;//获取下标 CGFloat margin = (self.shopsView.frame.size.width - col*viewW) / (col - 1);//定义间隔 CGFloat viewX = (index % col ) * (viewW + margin); CGFloat viewY = (index / col ) * (viewH + 10); 实现图片轮播图 ScrollView只需要设置三个ImageView即可，并且默认显示中间的ImageView 根据ScrollView的移动情况，迅速变化三个ImageView中图片数据 ImageView更新完毕后，偷偷把ScrollView拉回到中间的ImageView位置，这样视觉效果上就实现了无限循环的效果 应用的生命周期 -(BOOL)application:(UIApplication )application willFinishLaunchingWithOptions:(NSDictionary )launchOptions 告诉代理进程启动但还没进入状态保存 -(BOOL)application:(UIApplication )application didFinishLaunchingWithOptions:(NSDictionary )launchOptions 告诉代理启动基本完成程序准备开始运行 -(void)applicationWillResignActive:(UIApplication *)application 当应用程序将要入非活动状态执行，在此期间，应用程序不接收消息或事件，比如来电话了 -(void)applicationDidBecomeActive:(UIApplication *)application 当应用程序入活动状态执行，这个刚好跟上面那个方法相反 -(void)applicationDidEnterBackground:(UIApplication *)application 当程序被推送到后台的时候调用。所以要设置后台继续运行，则在这个函数里面设置即可 -(void)applicationWillEnterForeground:(UIApplication *)application 当程序从后台将要重新回到前台时候调用，这个刚好跟上面的那个方法相反。 -(void)applicationWillTerminate:(UIApplication *)application 当程序将要退出是被调用，通常是用来保存数据和一些退出前的清理工作。 load initialize方法的区别 +(void)load; 当类对象被引入项目时, runtime 会向每一个类对象发送 load 消息 load 方法会在每一个类甚至分类被引入时仅调用一次,调用的顺序：父类优先于子类, 子类优先于分类 load 方法不会被类自动继承 +(void)initialize; 也是在第一次使用这个类的时候会调用这个方法 UIScrollView 大概是如何实现的，它是如何捕捉、响应手势的？ 我对UIScrollView的理解是frame就是他的contentSize,bounds就是他的可视范围,通过改变bounds从而达到让用户误以为在滚动,以下是一个简单的UIScrollView实现 第二个问题个人理解是解决手势冲突,对自己添加的手势进行捕获和响应 // 让UIScrollView遵守UIGestureRecognizerDelegate协议,实现这个方法,在这里方法里对添加的手势进行处理就可以解决冲突 (BOOL)gestureRecognizer:(UIGestureRecognizer )gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer )otherGestureRecognizer +[UIView animateWithDuration:animations:completion:] 内部大概是如何实现的？animateWithDuration:这就等于创建一个定时器 animations:这是创建定时器需要实现的SEL completion:是定时器结束以后的一个回调block 什么时候会发生「隐式动画」？ 当改变CALayer的一个可做动画的属性，它并不能立刻在屏幕上体现出来.相反，它是从先前的值平滑过渡到新的值。这一切都是默认的行为，你不需要做额外的操作,这就是隐式动画 如何把一张大图缩小为1/4大小的缩略图？imgData = UIImageJPEGRepresentation(image, 0.6f) 当TableView的Cell改变时，如何让这些改变以动画的形式呈现？[tableView deselectRowAtIndexPath:indexPath animated:TRUE]; // 重点是这2句代码实现的功能 [tableView beginUpdates]; [tableView endUpdates]; 为什么当 Core Animation 完成时，layer 又会恢复到原先的状态？ 因为这些产生的动画只是假象,并没有对layer进行改变.那么为什么会这样呢,这里要讲一下图层树里的呈现树.呈现树实际上是模型图层的复制,但是它的属性值表示了当前外观效果,动画的过程实际上只是修改了呈现树,并没有对图层的属性进行改变,所以在动画结束以后图层会恢复到原先状态 设计一个进度条。 自定义一个UIView的子类 //提供一个成员属性，接收下载进度值 @property (nonatomic, assign) CGFloat progress; 重写成员属性progress的setter //每次改变成员属性progress的值，就会调用它的setter -(void)setProgress:(CGFloat)progress { _progress = progress; //当下载进度改变时，手动调用重绘方法 [self setNeedsDisplay]; } 重写 -(void)drawRect:(CGRect)rect（核心） -(void)drawRect:(CGRect)rect { //设置圆弧的半径 CGFloat radius = rect.size.width * 0.5; //设置圆弧的圆心 CGPoint center = CGPointMake(radius, radius); //设置圆弧的开始的角度（弧度制） CGFloat startAngle = - M_PI_2; //设置圆弧的终止角度 CGFloat endAngle = - M_PI_2 + 2 * M_PI * self.progress; //使用UIBezierPath类绘制圆弧 UIBezierPath *path = [UIBezierPath bezierPathWithArcCenter:center radius:radius - 5 startAngle:startAngle endAngle:endAngle clockwise:YES]; //将绘制的圆弧渲染到图层上（即显示出来） [path stroke]; } 如何播放 GIF 图片，有什么优化方案么？ UIImageView用来显示图片， 使用UIImageView中的动画数组来实现图片的动画效果 用UIWebView来显示动态图片 第三方显示框架 通过UIImageView显示动画效果，实际上是把动态的图拆成了一组静态的图，放到数组中，播放的时候依次从数组中取出。如果播放的图片比较少占得内存比较小或者比较常用（比如工具条上一直显示的动态小图标），可以选择用imageNamed：方式获取图片，但是通过这种方式加到内存中，使用结束，不会自己释放，多次播放动画会造成内存溢出问题。因此，对于大图或经常更换的图，在取图片的时候可以选择imageWithContentsOfFile:方式获取图片，优化内存。 使用UIWebView显示图片需要注意显示图片的尺寸与UIWebView尺寸的设置，如果只是为了显示动态图片，可以禁止UIWebView滚动。在显示动态图片的时候，即使是动图的背景处为透明，默认显示出来是白色背景，这个时候需要手动设置UIWebView的透明才能达到显示动图背景透明的效果。 有哪几种方式可以对图片进行缩放，使用 CoreGraphics 缩放时有什么注意事项？ UIImageView整体拉伸 UIImage局部拉伸 UIImage修改大小 images.xcassets：多亏了Xcode中Asset Catalog的slice和dice，我们不需要代码也能拉伸图片。首先在Xcode中选中图片，然后点击右下角的Show Slicing： 图形上下文等比例缩放 XIB与Storyboards的优缺点?- XIB：在编译前就提供了可视化界面，可以直接拖控件，也可以直接给控件添加约束，更直观一些，而且类文件中就少了创建控件的代码，确实简化不少，通常每个XIB对应一个类。 - Storyboard：在编译前提供了可视化界面，可拖控件，可加约束，在开发时比较直观，而且一个storyboard可以有很多的界面，每个界面对应一个类文件，通过storybard，可以直观地看出整个App的结构。 - XIB：需求变动时，需要修改XIB很大，有时候甚至需要重新添加约束，导致开发周期变长。XIB载入相比纯代码自然要慢一些。对于比较复杂逻辑控制不同状态下显示不同内容时，使用XIB是比较困难的。当多人团队或者多团队开发时，如果XIB文件被发动，极易导致冲突，而且解决冲突相对要困难很多。 - Storyboard：需求变动时，需要修改storyboard上对应的界面的约束，与XIB一样可能要重新添加约束，或者添加约束会造成大量的冲突，尤其是多团队开发。对于复杂逻辑控制不同显示内容时，比较困难。当多人团队或者多团队开发时，大家会同时修改一个storyboard，导致大量冲突，解决起来相当困难。 控制器View的加载过程？当程序访问了控制器的View属性时会先判断控制器的View是否存在，如果存在就直接返回已经存在的View； 如果不存在，就会先调用loadView这个方法；如果控制器的loadView方法实现了，就会按照loadView方法加载自定义的View； 如果控制器的loadView方法没有实现就会判断storyboard是否存在； 如果storyboard存在就会按照storyboard加载控制器的View；如果storyboard不存在，就会创建一个空视图返回。 应用程序的启动流程？1.执行Main 2.执行UIApplicationMain函数. 3.创建UIApplication对象,并设置UIApplicationMain对象的代理. UIApplication的第三个参数就是UIApplication的名称,如果指定为nil,它会默认为UIApplication. UIApplication的第四个参数为UIApplication的代理. 4.开启一个主运行循环.保证应用程序不退出. 5.加载info.plist.加载配置文件.判断一下info.plist文件当中有没有Main storyboard file base name里面有没有指定storyboard文件,如果有就去加载info.plist文件,如果没有,那么应用程序加载完毕. 事件传递与响应的完整过程?在产生一个事件时,系统会将该事件加入到一个由UIApplication管理的事件队列中, UIApplication会从事件队列中取出最前面的事件,将它传递给先发送事件给应用程序的主窗口. 主窗口会调用hitTest方法寻找最适合的视图控件,找到后就会调用视图控件的touches方法来做具体的事情. 当调用touches方法,它的默认做法, 就会将事件顺着响应者链条往上传递， 传递给上一个响应者,接着就会调用上一个响应者的touches方法 下列回调机制的理解不正确的是A target-action：当两个对象之间有⽐较紧密的关系时，如视图控制器与其下的某个视图。 B delegate：当某个对象收到多个事件，并要求同一个对象来处理所有事件时。委托机制必须依赖于某个协议定义的⽅法来发送消息。 C NSNotification：当需要多个对象或两个无关对象处理同一个事件时。 D Block：适⽤于回调只发⽣生一次的简单任务。 参考答案：B 给UIImageView添加圆角 最直接的方法就是使用如下属性设置： imgView.layer.cornerRadius = 10; // 这一行代码是很消耗性能的 imgView.clipsToBounds = YES; 好处是使用简单，操作方便。坏处是离屏渲染（off-screen-rendering）需要消耗性能。对于图片比较多的视图上，不建议使用这种方法来设置圆角。通常来说，计算机系统中CPU、GPU、显示器是协同工作的。CPU计算好显示内容提交到GPU，GPU渲染完成后将渲染结果放入帧缓冲区。 简单来说，离屏渲染，导致本该GPU干的活，结果交给了CPU来干，而CPU又不擅长GPU干的活，于是拖慢了UI层的FPS（数据帧率），并且离屏需要创建新的缓冲区和上下文切换，因此消耗较大的性能。 给UIImage添加生成圆角图片的扩展API： - (UIImage *)hyb_imageWithCornerRadius:(CGFloat)radius { CGRect rect = (CGRect){0.f, 0.f, self.size}; UIGraphicsBeginImageContextWithOptions(self.size, NO, UIScreen.mainScreen.scale); CGContextAddPath(UIGraphicsGetCurrentContext(), [UIBezierPath bezierPathWithRoundedRect:rect cornerRadius:radius].CGPath); CGContextClip(UIGraphicsGetCurrentContext()); [self drawInRect:rect]; UIImage *image = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return image; } 然后调用时就直接传一个圆角来处理： imgView.image = [[UIImage imageNamed:@&quot;test&quot;] hyb_imageWithCornerRadius:4]; 这么做就是on-screen-rendering了，通过模拟器-&gt;debug-&gt;Color Off-screen-rendering看到没有离屏渲染了!（黄色的小圆角没有显示了，说明这个不是离屏渲染了） 在画之前先通过UIBezierPath添加裁剪，但是这种不实用 - (void)drawRect:(CGRect)rect { CGRect bounds = self.bounds; [[UIBezierPath bezierPathWithRoundedRect:rect cornerRadius:8.0] addClip]; [self.image drawInRect:bounds]; } 通过mask遮罩实现 一个view已经初始化完毕，view上面添加了n个button（可能使用循环创建），除用view的tag之外，还可以采用什么办法来找到自己想要的button来修改Button的值这个问题有很多种方式，而且不同的使用场景也不一样的。比如说： • 第一种：如果是点击某个按钮后，才会刷新它的值，其它不用修改，那么不用引用任何按钮，直接在回调时，就已经将接收响应的按钮给传过来了，直接通过它修改即可。 • 第二种：点击某个按钮后，所有与之同类型的按钮都要修改值，那么可以通过在创建按钮时将按钮存入到数组中，在需要的时候遍历查找。 使用drawRect有什么影响？ drawRect方法依赖Core Graphics框架来进行自定义的绘制，但这种方法主要的缺点就是它处理touch事件的方式：每次按钮被点击后，都会用setNeddsDisplay进行强制重绘；而且不止一次，每次单点事件触发两次执行。这样的话从性能的角度来说，对CPU和内存来说都是欠佳的。特别是如果在我们的界面上有多个这样的UIButton实例。 viewWillLayoutSubView你总是知道的。controller layout触发的时候，开发者有机会去重新layout自己的各个subview。 横竖屏切换的时候，系统会响应一些函数，其中 viewWillLayoutSubviews 和 viewDidLayoutSubviews。 - (void)viewWillLayoutSubviews { [self _shouldRotateToOrientation:(UIDeviceOrientation)[UIApplication sharedApplication].statusBarOrientation]; } -(void)_shouldRotateToOrientation:(UIDeviceOrientation)orientation { if (orientation == UIDeviceOrientationPortrait ||orientation == UIDeviceOrientationPortraitUpsideDown) { // 竖屏 } else { // 横屏 } } 通过上述一个函数就知道横竖屏切换的接口了。 注意：viewWillLayoutSubviews只能用在ViewController里面，在view里面没有响应。 一个tableView是否可以关联两个不同的数据源？ 当然是可以关联多个不同的数据源，但是不能同时使用多个数据源而已。比如，一个列表有两个筛选功能，一个是筛选城市，一个是筛选时间，那么这两个就是两个数据源了。当筛选城市时，就会使用城市数据源；当筛选时间时，就会使用时间数据源。 如何自动计算cell的高度？ 实现原理：通过数据模型的id作为key，以确保唯一，如何才能保证复用cell时不会出现混乱。在配置完数据后，通过更新约束，得到最后一个控件的frame，就只可以判断cell实际需要的高度，并且缓存下来，下次再获取时，判断是否存在，若存在则直接返回。因此，只会计算一遍 UITableView是如何计算内容高度的？为什么初始化时配置数据时，获取行高的代理方法会调用数据条数次？ UITableView是继承于UIScrollView的，因此也有contentSize。要得到tableview的contentsize，就需要得到所有cell的高度，从而计算出总高度，才能得到contentsize。因此，在reloadData时，就会调用该代理方法数据条数次。 一个tableView是否可以关联两个不同的数据源?你会怎么处理?答：首先我们从代码来看，数据源如何关联上的，其实是在数据源关联的代理方法里实现的。 因此我们并不关心如何去关联他，他怎么关联上，方法只是让我返回根据自己的需要去设置如相关的数据源。 因此，我觉得可以设置多个数据源啊，但是有个问题是，你这是想干嘛呢?想让列表如何显示，不同的数据源分区块显示? 给出委托方法的实例，并且说出UITableVIew的Data Source方法CocoaTouch框架中用到了大量委托，其中UITableViewDelegate就是委托机制的典型应用，是一个典型的使用委托来实现适配器模式，其中UITableViewDelegate协议是目标，tableview是适配器，实现UITableViewDelegate协议，并将自身设置为talbeview的delegate的对象，是被适配器，一般情况下该对象是UITableViewController。 UITableVIew的Data Source方法有- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section; - (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath; cocoa touch框架答：iPhone OS 应用程序的基础 Cocoa Touch 框架重用了许多 Mac 系统的成熟模式，但是它更多地专注于触摸的接口和优化。 UIKit 为您提供了在 iPhone OS 上实现图形，事件驱动程序的基本工具，其建立在和 Mac OS X 中一样的 Foundation 框架上，包括文件处理，网络，字符串操作等。 Cocoa Touch 具有和 iPhone 用户接口一致的特殊设计。有了 UIKit，您可以使用 iPhone OS 上的独特的图形接口控件，按钮，以及全屏视图的功能，您还可以使用加速仪和多点触摸手势来控制您的应用。 各色俱全的框架 除了UIKit 外，Cocoa Touch 包含了创建世界一流 iPhone 应用程序需要的所有框架，从三维图形，到专业音效，甚至提供设备访问 API 以控制摄像头，或通过 GPS 获知当前位置。 Cocoa Touch 既包含只需要几行代码就可以完成全部任务的强大的 Objective-C 框架，也在需要时提供基础的 C 语言 API 来直接访问系统。这些框架包括： Core Animation：通过 Core Animation，您就可以通过一个基于组合独立图层的简单的编程模型来创建丰富的用户体验。 Core Audio：Core Audio 是播放，处理和录制音频的专业技术，能够轻松为您的应用程序添加强大的音频功能。 Core Data：提供了一个面向对象的数据管理解决方案，它易于使用和理解，甚至可处理任何应用或大或小的数据模型。 功能列表：框架分类 下面是 Cocoa Touch 中一小部分可用的框架： 音频和视频：Core Audio ，OpenAL ，Media Library ，AV Foundation 数据管理 ：Core Data ，SQLite 图形和动画 ：Core Animation ，OpenGL ES ，Quartz 2D 网络：Bonjour ，WebKit ，BSD Sockets 用户应用：Address Book ，Core Location ，Map Kit ，Store Kit xib文件的构成分为哪3个图标？都具有什么功能。File’s Owner 是所有 nib 文件中的每个图标，它表示从磁盘加载 nib 文件的对象； First Responder 就是用户当前正在与之交互的对象； View 显示用户界面；完成用户交互；是 UIView 类或其子类。 简述应用程序按Home键进入后台时的生命周期,和从后台回到前台时的生命周期? 应用程序:-[AppDelegate application:willFinishLaunchingWithOptions:] -[AppDelegate application:didFinishLaunchingWithOptions:] -[AppDelegate applicationDidBecomeActive:] 退到后台: -[AppDelegate applicationWillResignActive:] -[AppDelegate applicationDidEnterBackground:] 回到前台: -[AppDelegate applicationWillEnterForeground:] -[AppDelegate applicationDidBecomeActive:] ViewController之间， 加载页面: -[mainViewController viewDidLoad] -[mainViewController viewWillAppear:] -[mainViewController viewWillLayoutSubviews] -[mainViewController viewDidLayoutSubviews] -[mainViewController viewDidAppear:] 退出当前页面: -[mainViewController viewWillDisappear:] -[mainViewController viewDidDisappear:] 返回之前页面: -[mainViewController viewWillAppear:] -[mainViewController viewWillLayoutSubviews] -[mainViewController viewDidLayoutSubviews] -[mainViewController viewDidAppear:] 是否使用Core Text或者Core Image等？如果使用过，请谈谈你使用Core Text或者Core Image的体验。CoreText • 随意修改文本的样式 • 图文混排(纯C语言) • 国外:Niumb Core Image(滤镜处理) * 能调节图片的各种属性(对比度, 色温, 色差等) 分析一下使用手机获取验证码注册账号的实现逻辑(给了一个示例图)，发送到手机的验证码超过60秒钟后重新发送 定义一个label属性，赋值为60秒，再定义一个count 设置一个timer 每次减少一秒 把count– 再把count的值拼接到label上 当count == 0 的时候 再显示重新发送 你做iphone开发时候,有哪些传值方式,view和view之间是如何传值的?block, target-action ,代理,属性 有哪几种手势通知方法、写清楚方法名？-(void)touchesBegan:(NSSet)touchedwithEvent:(UIEvent)event; -(void)touchesMoved:(NSSet)touched withEvent:(UIEvent)event; -(void)touchesEnded:(NSSet)touchedwithEvent:(UIEvent)event; -(void)touchesCanceled:(NSSet)touchedwithEvent:(UIEvent)event;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS面试题8--Swift]]></title>
    <url>%2F2018%2F09%2F12%2FiOS%E9%9D%A2%E8%AF%95%E9%A2%988-Swift%2F</url>
    <content type="text"><![CDATA[Swift和Objective-C的联系 Swift与Objective-C共用同一套运行时环境 我们编写程序，让程序运行起来，被机器执行的代码并非全部是由我们自己来编写的。需要同时运行很多预先写好的支持性的代码，才能让我们自己的代码运行起来。程序并非单独存在的，运行时处在一定的环境当中。我总联想到很多小蚂蚁在泥土上面爬，而我自己写的程序只是其中的一只。 Swift跟Objective-C编译出的程序代码运行在同一套运行环境上面。Swift的类型可以桥接到Objective-C的类型，反之亦然。Swift编写的代码可以调用Objective-C编写的代码，反之也一样。 Objective-C之前积累下来的大量类库，实现不用改写Swift就可以直接调用。 同一个工程，可以同时使用Swift和Objective-C Objective-C在一端，Swift在另一端，两端经中间文件进行桥接。桥接文件包含Objective-C的头文件，编译时自动转成Swift可以识别的形式。Swift就可以使用Objective-C的类和它的函数。 在Swift的类中，加上@objc（类名）的字样，Objective-C也可以使用Swift编写的类。但Swift跟C++的相互调用，需要Objective-C来封装。 Swift骨子里大多与Objective-C一样 Objective-C出现过的绝大多数概念，比如引用记数、ARC、属性、协议、接口、初始化、扩展类、命名参数、匿名函数等，在Swift中继续有效（可能只是换了个术语）。我自己将Swift看成是Objective-C的一块大大的语法糖，其他人可能有不同感受。 Swift大多数概念与Objective-C一样，也有些概念在Objective-C找不到对应，比如泛型。Swift中将那种操作写一次就可以作用多个类型的语法叫做Generics（泛型）。 Swift比Objective-C有什么优势？ Swift 容易阅读 不再需要行尾的分号，以及 if/else 语句中围绕条件表达式的括弧。另外就是方法的调用不再互相嵌套成中括号[[[ ]]]。Swift 中的方法和函数的调用使用行业内标准的在一对括弧内使用逗号分隔的参数列表。这样做的结果就是一种带有简化了句法和语法的更加干净有表现力的语言。 Swift 更易于维护 Swift 丢掉了对着两个文件的要求。 Xcode编译器可以自动计算出以来并执行增量构建。如此，将头文件 同实现文件相分离。把 Objective-C 头文件(.h) 和实现文件 (.m) 合并成了一个代码文件 (.swift) Swift 更加安全 Swift代码中的可选类型使得一个nil可选值的可能性变得非常的明确, 这意味它能在你写下一段糟糕的代码时会生成一个编译器错误. 这就建立了一种短程反馈的循环，可以让程序员带着目标去写代码. 问题在代码被写就时就可以被修复, 这大大节省了你要在修复有关来自 Objective-C 指针逻辑的bug时需要耗费的时间和金钱. Swift 代码更少 Swift 减少了重复性语句和字符串操作所需要的代码量。在 Objective-C 中, 使用文本字符串将两块信息组合起来的操作非常繁琐。Swift 采用当代编程语言的特性，比如使用“+”操作符将两个字符串加到一起 Swift中的类型系统减少了代码语句的复杂性–作为编译器可以理解的类型。比如，Objective-C要求程序员记住特殊字符标记（%s，%d，%@）并且提供了一个用逗号分隔的变量来代替每个标记。Swift支持字符串插入，这就消除了需要记住的标记和允许程序员直接插入变量到面向用户的字符串中 Swift 速度更快 删除遗留下来的C语言约定大大提升了引擎盖之下Swift的性能, 进行计算密集型任务的性能上，Swift已经逼近C++的表现, 将近是OC运行速度的1.4倍. 总结: 使用 Swift，程序员只要维护原来一半量的代码文件，手动的代码同步工作为零，标点输入出错的概率也远远低于以前 – 这样就能腾出更多的时间写高质量的代码。通过使用可选类型 —— 一种针对返回或不返回值的编译时安全机制，而返回值是同步操作、网络失效时无效的用户输入以及数据验证错误发生时普遍会遇到的问题。ARC 在 Swift 中对过程式 C 风格的代码，还有苹果公司 Cocoa 框架使用的面向对象代码都进行了统一。 Swift的内存管理是怎样的？ Swift 使用自动引用计数（Automatic Reference Counting, ARC）来简化内存管理, 这种内存管理方式相比GC而言，对程序员的要求较高, 并且ARC比GC更容易引起编程错误，但却比GC快。尤其在性能很重要的场合。 Swift支持面向过程编程吗？ 它采用了 Objective-C 的命名参数以及动态对象模型，可以无缝对接到现有的 Cocoa 框架，并且可以兼容 Objective-C 代码，支持面向过程编程和面向对象编程。 举例说明Swift里面有哪些是 Objective-C中没有的？ Swift引入了在Objective-C中没有的一些高级数据类型，例如tuples（元组），可以使你创建和传递一组数值。 Swift还引入了可选项类型（Optionals），用于处理变量值不存在的情况。可选项的意思有两种：一是变量是存在的，例如等于X，二是变量值根本不存在。Optionals类似于Objective-C中指向nil的指针，但是适用于所有的数据类型，而非仅仅局限于类，Optionals 相比于Objective-C中nil指针更加安全和简明，并且也是Swift诸多最强大功能的核心。 Swift 是一门安全语言吗？ Swift是一门类型安全的语言，Optionals就是代表。Swift能帮助你在类型安全的环境下工作，如果你的代码中需要使用String类型，Swift的安全机制能阻止你错误的将Int值传递过来，这使你在开发阶段就能及时发现并修正问题。 为什么要在变量类型后面加个问号？ 用来标记这个变量的值是可选的，一般用“！”和“？”定义可选变量的区别：用“！”定的可选变量必须保证转换能够成功，否则报错，但定义的变量可以直接使用，不会封装在option里；而用“？”号定的可选变量即使转换不成功本身也不会出错，变量值为nil，如果转换成功，要使用该变量进行计算时变量名后需要加“！” 什么是泛型，它们又解决了什么问题？ 泛型是用来使代码能安全工作。在Swift中，泛型可以在函数数据类型和普通数据类型中使用，例如类、结构体或枚举。 泛型解决了代码复用的问题。有一种常见的情况，你有一个方法，需要一个类型的参数，你为了适应另一种类型的参数还得重新再写一遍这个方法。 比如，在下面的代码中，第二个方法是第一个方法的“克隆体”： func areIntEqual(x: Int, _ y: Int) -> Bool { return x == y } func areStringsEqual(x: String, _ y: String) -> Bool { return x == y } areStringsEqual("ray", "ray") // true areIntEqual(1, 1) // true 一个Objective-C开发者可能会采用NSObject来解决问题： import Foundation func areTheyEqual(x: NSObject, _ y: NSObject) -> Bool { return x == y } areTheyEqual("ray", "ray") // true areTheyEqual(1, 1) // true 这段代码能达到了目的，但是编译的时候并不安全。它允许一个字符串和一个整型数据进行比较： areTheyEqual(1, "ray") //程序可能不会崩溃，但是允许一个字符串和一个整型数据进行比较可能不会得到想要的结果。 采用泛型的话，你可以将上面两个方法合并为一个，并同时还保证了数据类型安全。这是实现代码： func areTheyEqual&lt;T: Equatable>(x: T, _ y: T) -> Bool { return x == y } areTheyEqual("ray", "ray") areTheyEqual(1, 1)]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS面试题7--Block]]></title>
    <url>%2F2018%2F09%2F12%2FiOS%E9%9D%A2%E8%AF%95%E9%A2%987-Block%2F</url>
    <content type="text"><![CDATA[Block底层原理实现 首先我们来看四个函数 void test1() { int a = 10; void (^block)() = ^{ NSLog(@"a is %d", a); }; a = 20; block(); // 10 } void test2() { __block int a = 10; void (^block)() = ^{ NSLog(@"a is %d", a); }; a = 20; block(); // 20 } void test3() { static int a = 10; void (^block)() = ^{ NSLog(@"a is %d", a); }; a = 20; block(); // 20 } int a = 10; void test4() { void (^block)() = ^{ NSLog(@"a is %d", a); }; a = 20; block();//20 } 造成这样的原因是：传值和传址。为什么说会有传值和传址，把.m编译成c++代码。得到.cpp文件，我们来到文件的最后，看到如下代码 struct __test1_block_impl_0 { struct __block_impl impl; struct __test1_block_desc_0* Desc; int a; __test1_block_impl_0(void *fp,struct __test1_block_desc_0* Desc,int _a,int flag=0): a(_a){ impl.isa = &_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; } }; static void __test1_block_func_0(struct __test1_block_imp_0 *__cself) { int a = __cself->a; NSLog(a);//这里就是打印a的值，代码太长，而且没意义，我就不敲出来了。 } void test1() { int a = 10; void (*block)() = (void (*)())&__test1_block_impl_0((void *))__test1_block_func_0,&__test1_block_desc_0_DATA,a); a = 20; ((void (*)(__block_impl *))((__block_ipml *)block)->FuncPtr)((_block_impl *)block); } int main(int argc, const char * argv[]) { /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; test1(); } return 0; } static struct IMAGE_INFO { unsigned version; unsigned flag; } _OBJC_IMAGE_INFO = { 0, 2 }; 我们看到void test1()中，void (*block)() 右边最后面 ，把a传进去了，也就是把10这个值传进去了. 而且对void (*block)()简化分析，void (* block)() = &amp;__test1_block_impl_0(); 所以block就是指向结构体的指针。 10传入block后，代码最上面创建的__test1_block_impl_0结构体中，a = 10； 对void test1()中最下面的函数进行简化分析，得到(block)-&gt;FuncPtr)(block)，我们在回到刚才__test1_block_impl_0这个结构体中，impl.FuncPtr = fp;而fp又是传入结构体的第一个参数，而在void (*block)()中，传入结构体的第一个参数为__test1_block_func_0，也就是说(block)-&gt;FuncPtr)(block) =》__test1_block_func_0(block); 上一步相当于调用__test1_block_func_0（）这个函数，我们来看这个函数，有这样一段代码：int a = __cself-&gt;a;访问block中的a值，传递给a；所以是10.这种就是传值！！！ ===== 我们再来看test2( );添加了__block会发送什么变化呢 void test2() { __attribute__((_blocks__(byref))) __Block_byref_a_0 a = {(void*)0,(__Block_byref_a_0 *)&a,0,sizeof(__Block_byref_a_0),10}; void(*block)() = (void (*)())&__test2_block_impl_0((void *))__test2_block_func_0,&__test2_block_desc_0_DATA,(__Block_byref_a_0 *)&a,570425344); (a.__forwarding->a) = 20; ((void (*)(__block_impl *))((__block_ipml *)block)->FuncPtr)((_block_impl *)block); } int main(int argc, const char * argv[]) { /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; test2(); } return 0; } static struct IMAGE_INFO { unsigned version; unsigned flag; } _OBJC_IMAGE_INFO = { 0, 2 }; 代码虽然很多看着很复杂，但是我们只需要看我们想要知道的，睁大你的眼睛，看到void(*block)()这个函数的最后面，有个&amp;a,天啊，这里传的是a的地址。从test2到test4，都是传址，所以a的值发生改变，block打印出来的是a的最终值。 总结：只有普通局部变量是传值，其他情况都是传址。 block的定义// 无参无返回 void(^block)(); // 无参有返回 int(^block1)(); // 有参有返回 int(^block1)(int number); 也可以直接打入inline来自动生成block格式 &lt;#returnType#&gt;(^&lt;#blockName#&gt;)(&lt;#parameterTypes#&gt;) = ^(&lt;#parameters#&gt;) { &lt;#statements#&gt; }; block的内存管理 无论当前环境是ARC还是MRC,只要block没有访问外部变量,block始终在全局区 MRC情况下 block如果访问外部变量,block在栈里 不能对block使用retain,否则不能保存在堆里 只有使用copy,才能放到堆里 ARC情况下 block如果访问外部变量,block在堆里 block可以使用copy和strong,并且block是一个对象 block的循环引用 如果要在block中直接使用外部强指针会发生错误,使用以下代码在block外部实现可以解决 __weak typeof(self) weakSelf = self; 但是如果在block内部使用延时操作还使用弱指针的话会取不到该弱指针,需要在block内部再将弱指针强引用一下 __strong typeof(self) strongSelf = weakSelf; 描述一个你遇到过的retain cycle例子。block中的循环引用：一个viewController @property (nonatomic,strong)HttpRequestHandler * handler; @property (nonatomic,strong)NSData *data; _handler = [httpRequestHandler sharedManager]; [ downloadData:^(id responseData){ _data = responseData; }]; self 拥有_handler, _handler 拥有block, block拥有self（因为使用了self的_data属性，block会copy 一份self） 解决方法： __weak typedof(self)weakSelf = self [ downloadData:^(id responseData){ weakSelf.data = responseData; block中的weak self，是任何时候都需要加的么？ 不是什么任何时候都需要添加的，不过任何时候都添加似乎总是好的。只要出现像self-&gt;block-&gt;self.property/self-&gt;_ivar这样的结构链时，才会出现循环引用问题。好好分析一下，就可以推断出是否会有循环引用问题。 通过block来传值 在控制器间传值可以使用代理或者block,使用block相对来说简洁 在前一个控制器的touchesBegan:方法内实现如下代码 ModalViewController *modalVc = [[ModalViewController alloc] init]; modalVc.valueBlcok = ^(NSString *str){ NSLog(@"ViewController拿到%@",str); }; [self presentViewController:modalVc animated:YES completion:nil]; 在ModalViewController控制器的.h文件中声明一个block属性 @property (nonatomic ,strong) void(^valueBlcok)(NSString *str); 并在.m文件中实现方法 - (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event { // 传值:调用block if (_valueBlcok) { _valueBlcok(@"123"); } } 这样在ModalViewController回到上一个控制器的时候,上一个控制器的label就能显示ModalViewController传过来的字符串 block作为一个参数使用 新建一个类,在.h文件中声明一个方法- (void)calculator:(int(^)(int result))block; 并在.m文件中实现该方法 -(void)calculator:(int (^)(int))block { self.result = block(self.result); } 在其他类中调用该方法 CalculatorManager *mgr = [[CalculatorManager alloc] init]; [mgr calculator:^(int result){ result += 5; return result; }]; block作为返回值使用 在masonry框架中我们可以看到如下用法make.top.equalTo(superview.mas_top).with.offset(padding.top); 这个方法实现就是将block作为返回值来使用 来分析一下这段代码：其实可以将这段代码看成make.top,make.equalTo,make.with,make.offset,所以可以得出一个结论是make.top返回了一个make,才能实现make.top.equalTo 那来模仿一下这种功能的实现 新建一个类,在.h文件中声明一个方法- (CalculatorManager *(^)(int a))add; 在.m文件中实现方法`objc (CalculatorManager * (^)(int a))add { return ^(int a){ _result += a; return self; };}` 这样就可以在别的类中实现上面代码的用法 mgr.add(1).add(2).add(3); block的变量传递 如果block访问的外部变量是局部变量,那么就是值传递,外界改了,不会影响里面 如果block访问的外部变量是__block或者static修饰,或者是全局变量,那么就是指针传递,block里面的值和外界同一个变量,外界改变,里面也会改变 验证一下是不是这样 通过Clang来将main.m文件编译为C++ 在终端输入如下命令clang -rewrite-objc main.m void(*block)() = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_a_0 *)&amp;a, 570425344)); void(*block)() = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, a)); 可以看到在编译后的代码最后可以发现被__block修饰过得变量使用的是&amp;a,而局部变量是a block的注意点 在block内部使用外部指针且会造成循环引用情况下,需要用__weak修饰外部指针 __weak typeof(self) weakSelf = self; 在block内部如果调用了延时函数还使用弱指针会取不到该指针,因为已经被销毁了,需要在block内部再将弱指针重新强引用一下 __strong typeof(self) strongSelf = weakSelf; 如果需要在block内部改变外部变量的话,需要在用__block修饰外部变量 使用block有什么好处？使用NSTimer写出一个使用block显示（在UILabel上）秒表的代码。说到block的好处，最直接的就是代码紧凑，传值、回调都很方便，省去了写代理的很多代码。 对于这里根本没有必要使用block来刷新UILabel显示，因为都是直接赋值。当然，笔者觉得这是在考验应聘者如何将NSTimer写成一个通用用的Block版本。 NSTimer封装成Block版: http://www.henishuo.com/nstimer-block/ 使用起来像这样： NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:1.0 repeats:YES callback:^() { weakSelf.secondsLabel.text = ... } [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes]; block跟函数很像： 可以保存代码 有返回值 有形参 调用方式一样 使用系统的某些block api（如UIView的block版本写动画时），是否也考虑引用循环问题？系统的某些block api中，UIView的block版本写动画时不需要考虑，但也有一些api需要考虑。所谓“引用循环”是指双向的强引用， 所以那些“单向的强引用”（block 强引用 self ）没有问题，比如这些： [UIView animateWithDuration:duration animations:^{ [self.superview layoutIfNeeded]; }]; [[NSOperationQueue mainQueue] addOperationWithBlock:^{ self.someProperty = xyz; }]; [[NSNotificationCenter defaultCenter] addObserverForName:@&quot;someNotification&quot; object:nil queue:[NSOperationQueue mainQueue] usingBlock:^(NSNotification * notification) { self.someProperty = xyz; }]; 这些情况不需要考虑“引用循环”。 但如果你使用一些参数中可能含有成员变量的系统api，如GCD、NSNotificationCenter就要小心一点。比如GCD内部如果引用了 self，而且GCD的其他参数是成员变量，则要考虑到循环引用： __weak __typeof(self) weakSelf = self; dispatch_group_async(_operationsGroup, _operationsQueue, ^{ __typeof__(self) strongSelf = weakSelf; [strongSelf doSomething]; [strongSelf doSomethingElse]; }); 类似的： __weak __typeof(self) weakSelf = self; _observer = [[NSNotificationCenter defaultCenter] addObserverForName:@&quot;testKey&quot; object:nil queue:nil usingBlock:^(NSNotification *note) { __typeof__(self) strongSelf = weakSelf; [strongSelf dismissModalViewControllerAnimated:YES]; }]; self –&gt; _observer –&gt; block –&gt; self 显然这也是一个循环引用。 谈谈对Block 的理解?并写出一个使用Block执行UIVew动画? Block是可以获取其他函数局部变量的匿名函数，其不但方便开发，并且可以大幅提高应用的执行效率(多核心CPU可直接处理Block指令) [UIView transitionWithView:self.view duration:0.2 ptions:UIViewAnimationOptionTransitionFlipFromLeft animations:^{ [[blueViewController view] removeFromSuperview]; [[self view] insertSubview:yellowViewController.view atIndex:0]; } completion:NULL]; 写出上面代码的Block的定义。 typedef void(^animations) (void); typedef void(^completion) (BOOL finished); 什么是block 对于闭包(block),有很多定义，其中闭包就是获取其它函数局部变量的匿名函数，这个定义即接近本质又较好理解。 对于刚接触Block的同学，会觉得有些绕，因为我们习惯写这样的程序main(){ funA();} funA(){funB();} funB(){…..}; 就是函数main调用函数A，函数A调用函数B… 函数们依次顺序执行，但现实中不全是这样的，例如项目经理M，手下有3个程序员A、B、C，当他给程序员A安排实现功能F1时，他并不等着A完成之后，再去安排B去实现F2，而是安排给A功能F1，B功能F2，C功能F3，然后可能去写技术文档，而当A遇到问题时，他会来找项目经理M，当B做完时，会通知M，这就是一个异步执行的例子。 在这种情形下，Block便可大显身手，因为在项目经理M，给A安排工作时，同时会告诉A若果遇到困难，如何能找到他报告问题(例如打他手机号)，这就是项目经理M给A的一个回调接口，要回掉的操作，比如接到电话，百度查询后，返回网页内容给A，这就是一个Block，在M交待工作时，已经定义好，并且取得了F1的任务号(局部变量)，却是在当A遇到问题时，才调用执行，跨函数在项目经理M查询百度，获得结果后回调该block。 block 实现原理 Objective-C是对C语言的扩展，block的实现是基于指针和函数指针。 从计算语言的发展，最早的goto，高级语言的指针，到面向对象语言的block，从机器的思维，一步步接近人的思维，以方便开发人员更为高效、直接的描述出现实的逻辑(需求)。 使用实例:cocoaTouch框架下动画效果的Block的调用 使用typed声明block typedef void(^didFinishBlock) (NSObject *ob); 这就声明了一个didFinishBlock类型的block， 然后便可用 @property (nonatomic,copy) didFinishBlock finishBlock; 声明一个blokc对象，注意对象属性设置为copy，接到block 参数时，便会自动复制一份。 __block是一种特殊类型， 使用该关键字声明的局部变量，可以被block所改变，并且其在原函数中的值会被改变。 关于block 答: 面试时，面试官会先问一些，是否了解block，是否使用过block，这些问题相当于开场白，往往是下面一系列问题的开始，所以一定要如实根据自己的情况回答。 1). 使用block和使用delegate完成委托模式有什么优点? 首先要了解什么是委托模式，委托模式在iOS中大量应用，其在设计模式中是适配器模式中的对象适配器，Objective-C中使用id类型指向一切对象，使委托模式更为简洁。了解委托模式的细节： iOS设计模式—-委托模式 使用block实现委托模式，其优点是回调的block代码块定义在委托对象函数内部，使代码更为紧凑; 适配对象不再需要实现具体某个protocol，代码更为简洁。 2). 多线程与block GCD与Block 使用 dispatch_async 系列方法，可以以指定的方式执行block GCD编程实例 dispatch_async的完整定义 void dispatch_async( dispatch_queue_t queue, dispatch_block_t block); 功能：在指定的队列里提交一个异步执行的block，不阻塞当前线程 通过queue来控制block执行的线程。主线程执行前文定义的 finishBlock对象 dispatch_async(dispatch_get_main_queue(),^(void){finishBlock();}); 解释以下代码的内存泄漏原因- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath { HJTestCell *cell = [tableView dequeueReusableCellWithIdentifier:@&quot;TestCell&quot; forIndexPath:indexPath]; [cell setTouchBlock:^(HJTestCell *cell) { [self refreshData]; }]; return cell; } 原因： [cell setTouchBlock:^(HJTestCell *cell) { [self refreshData]; }]; 产生内存泄露的原因是因为循环引用 在给cell设置的TouchBlock中，使用了__strong修饰的self，由于Block的原理，当touchBlock从栈复制到堆中时，self会一同复制到堆中，retain一次，被touchBlock持有，而touchBlock又是被cell持有的，cell又被tableView持有，tableView又被self持有，因此形成了循环引用：self间接持有touchBlock，touchBlock持有self 一旦产生了循环引用，由于两个object都被强引用，所以retainCount始终不能为0，无发释放，产生内存泄漏 解决办法： 使用weakSelf解除touchBlock对self的强引用 __weak __typeof__(self) weakSelf = self; [cell setTouchBlock:^(HJTestCell *cell) { [weakSelf refreshData]; }];]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS面试题6--KVO和KVC]]></title>
    <url>%2F2018%2F09%2F12%2FiOS%E9%9D%A2%E8%AF%95%E9%A2%986-KVO%E5%92%8CKVC%2F</url>
    <content type="text"><![CDATA[KVC的底层实现？当一个对象调用setValue方法时，方法内部会做以下操作： ①检查是否存在相应key的set方法，如果存在，就调用set方法 ②如果set方法不存在，就会查找与key相同名称并且带下划线的成员属性，如果有，则直接给成员属性赋值 ③如果没有找到_key,就会查找相同名称的属性key，如果有就直接赋值 ④如果还没找到，则调用valueForUndefinedKey:和setValue:forUndefinedKey:方法。 这些方法的默认实现都是抛出异常，我们可以根据需要重写它们。 KVO的底层实现？ kvo基于runtime机制实现。 使用了isa 混写（isa-swizzling），当一个对象(假设是person对象，person的类是MYPerson)的属性值(假设person的age)发生改变时，系统会自动生成一个类，继承自MYPerson ：NSKVONotifying_MYPerson，在这个类的setAge方法里面，调用 [super setAge:age] [self willChangeValueForKey:@&quot;age&quot;] 和 [self didChangeValueForKey:@&quot;age&quot;] ,而这两个方法内部会主动调用监听者内部的- (void)observeValueForKeyPath这个方法。 想要看到NSKVONotifying_MYPerson很简单，在self.person.age = 20; 这里打断点，在调试区域就能看到 _person-&gt;NSObject-&gt;isa=(Class)NSKVONotifying_MYPerson. 同时我们在 self.person = [[MYPerson alloc]init]; 后面打断点，看到 _person-&gt;NSObject-&gt;isa=(Class)MYPerson 由此可见，在添加监听者之后，person类型已经由MYPerson被改变成NSKVONotifying_MYPerson 什么是KVO和KVC?答：KVC:键 – 值编码 使用字符串直接访问对象的属性。 KVO:键值观察机制，它提供了观察某一属性变化的方法 KVO的缺陷?KVO是一个对象能够观察另外一个对象的属性的值，并且能够发现值的变化。前面两种模式更加适合一个controller与任何其他的对象进行通信，而KVO更加适合任何类型的对象侦听另外一个任意对象的改变（这里也可以是controller，但一般不是controller）。这是一个对象与另外一个对象保持同步的一种方法，即当另外一种对象的状态发生改变时，观察对象马上作出反应。它只能用来对属性作出反应，而不会用来对方法或者动作作出反应。 优点： 1.能够提供一种简单的方法实现两个对象间的同步。例如：model和view之间同步； 2.能够对非我们创建的对象，即内部对象的状态改变作出响应，而且不需要改变内部对象（SKD对象）的实现； 3.能够提供观察的属性的最新值以及先前值； 4.用key paths来观察属性，因此也可以观察嵌套对象； 5.完成了对观察对象的抽象，因为不需要额外的代码来允许观察值能够被观察 缺点： 1.我们观察的属性必须使用strings来定义。因此在编译器不会出现警告以及检查； 2.对属性重构将导致我们的观察代码不再可用； 3.复杂的“IF”语句要求对象正在观察多个值,这是因为所有的观察代码通过一个方法来指向； 4.当释放观察者时需要移除观察者。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS面试题5--内存管理]]></title>
    <url>%2F2018%2F09%2F12%2FiOS%E9%9D%A2%E8%AF%95%E9%A2%985-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[ARC处理原理ARC是Objective-C编译器的特性，而不是运行时特性或者垃圾回收机制，ARC所做的只不过是在代码编译时为你自动在合适的位置插入release或autorelease，只要没有强指针指向对象，对象就会被释放。 前端编译器 前端编译器会为“拥有的”每一个对象插入相应的release语句。如果对象的所有权修饰符是__strong，那么它就是被拥有的。如果在某个方法内创建了一个对象，前端编译器会在方法末尾自动插入release语句以销毁它。而类拥有的对象（实例变量/属性）会在dealloc方法内被释放。事实上，你并不需要写dealloc方法或调用父类的dealloc方法，ARC会自动帮你完成一切。此外，由编译器生成的代码甚至会比你自己写的release语句的性能还要好，因为编辑器可以作出一些假设。在ARC中，没有类可以覆盖release方法，也没有调用它的必要。ARC会通过直接使用objc_release来优化调用过程。而对于retain也是同样的方法。ARC会调用objc_retain来取代保留消息。 ARC优化器 虽然前端编译器听起来很厉害的样子，但代码中有时仍会出现几个对retain和release的重复调用。ARC优化器负责移除多余的retain和release语句，确保生成的代码运行速度高于手动引用计数的代码。 下面关于Objective-C内存管理的描述错误的是A 当使用ARC来管理内存时，代码中不可以出现autorelease B autoreleasepool 在 drain 的时候会释放在其中分配的对象 C 当使用ARC来管理内存时，在线程中大量分配对象而不用autoreleasepool则可能会造成内存泄露 D 在使用ARC的项目中不能使用NSZone 参考答案：A 理由：ARC只是在大多时候编译自动为我们添加上内存管理的代码，只是我们的源代码看不到而已，但是在编译时，编译器会添加上相关内存管理代码。对于自动释放池，在drain时会将自动释放池中的所有对象的引用计数减一，若引用计数为0，则会自动释放掉其内存。如果在线程中需要大量分配内存，我们理应添加上自动释放池，以防内存泄露。比如在for循环中要分配大量的内存处理数据，那么我们应该在for循环内添加自动释放池，在每个循环后就将内存释放掉，防止内存泄露。在ARC项目中，自然不能手动使用NSZone，也不能调用父类的dealloc。 MRC文件在ARC工程混合编译时，需要在文件的Compiler Flags上添加什么参数A -shared B -fno-objc-arc C -fobjc-arc D -dynamic 参考答案：B 什么情况使用 weak 关键字，相比 assign 有什么不同？ 什么情况使用weak关键字? 在 ARC 中,在有可能出现循环引用的时候,往往要通过让其中一端使用 weak 来解决,比如: delegate 代理属性 自身已经对它进行一次强引用,没有必要再强引用一次,此时也会使用 weak,自定义 IBOutlet 控件属性一般也使用 weak；当然，也可以使用strong。 weak与assign的不同? weak 此特质表明该属性定义了一种“非拥有关系” (nonowning relationship)。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特质同assign类似， 然而在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。 而 assign 的“设置方法”只会执行针对“纯量类型” (scalar type，例如 CGFloat 或 NSlnteger 等)的简单赋值操作。 assigin 可以用非 OC 对象,而 weak 必须用于 OC 对象 调用对象的release 方法会销毁对象吗？ 不会，调用对象的release 方法只是将对象的引用计数器-1，当对象的引用计数器为0的时候会调用了对象的dealloc 方法才能进行释放对象的内存。 自动释放池常见面试代码for (int i = 0; i < someLargeNumber; ++i) { NSString *string = @"Abc"; string = [string lowercaseString]; string = [string stringByAppendingString:@"xyz"]; NSLog(@"%@",string); } 问：以上代码存在什么样的问题？如果循环的次数非常大时，应该如何修改？ 存在问题：问题处在每执行一次循环，就会有一个string加到当前runloop中的自动释放池中，只有当自动释放池被release的时候，自动释放池中的标示了autorelease的这些数据所占用的内存空间才能被释放掉。假设，当someLargeNumber大到一定程度时，内存空间将被耗尽而没有被释放掉，所以就出现了内存溢出的现象。 解决办法1：如果i比较大，可以用@autoreleasepool {}解决，放在for循环外，循环结束后，销毁创建的对象，解决占据栈区内存的问题 解决方法2：如果i玩命大，一次循环都会造成自动释放池被填满，自动释放池放在for循环内，每次循环都将上一次创建的对象release 修改之后: for(int i = 0; i&lt;1000;i++) { NSAutoreleasePool * pool1 = [[NSAutoreleasePool alloc] init]; NSString *string = @&quot;Abc&quot;; string = [string lowercaseString]; string = [string stringByAppendingString:@&quot;xyz&quot;]; NSLog(@&quot;%@&quot;,string); //释放池 [pool1 drain]; } objective-C对象的内存布局是怎样的？ 由于Objective-C中没有多继承，因此其内存布局还是很简单的，就是：最前面有个isa指针，然后父类的实例变量存放在子类的成员变量之前 看下面的程序,第一个NSLog会输出什么?这时str的retainCount是多少?第二个和第三个呢? 为什么?NSMutableArray* ary = [[NSMutableArray array] retain]; NSString *str = [NSString stringWithFormat:@"test"]; [str retain]; [aryaddObject:str]; NSLog(@”%@%d”,str,[str retainCount]); [str retain]; [str release]; [str release]; NSLog(@”%@%d”,str,[str retainCount]); [aryremoveAllObjects] NSLog(@”%@%d”,str,[str retainCount]); str的retainCount创建+1，retain+1，加入数组自动+1 3 retain+1，release-1，release-1 2 数组删除所有对象，所有数组内的对象自动-1 1 回答person的retainCount值,并解释为什么Person *per = [[Person alloc] init]; 此时person 的retainCount的值是1 self.person = per; 在self.person 时,如果是assign,person的 retainCount的值不变,仍为1 若是:retain person的retainCount的值加1,变为2 若是:copy person的retainCount值不变,仍为1 什么时候需要在程序中创建内存池? 用户自己创建的数据线程，则需要创建该线程的内存池 如果我们不创建内存池，是否有内存池提供给我们? 界面线程维护着自己的内存池，用户自己创建的数据线程，则需要创建该线程的内存池 苹果是如何实现autoreleasepool的？autoreleasepool以一个队列数组的形式实现,主要通过下列三个函数完成. • objc_autoreleasepoolPush • objc_autoreleasepoolPop • objc_autorelease 看函数名就可以知道，对autorelease分别执行push、pop操作。销毁对象时执行release操作。 objc使用什么机制管理对象内存？ 通过引用计数器(retainCount)的机制来决定对象是否需要释放。 每次runloop完成一个循环的时候，都会检查对象的 retainCount，如果retainCount为0，说明该对象没有地方需要继续使用了，可以释放掉了。 为什么要进行内存管理? 因为移动设备的内存极其有限,当一个程序所占内存达到一定值时， 系统会发出内存警告. 当程序达到更大的值时, 程序会闪退, 影响用户体验. 为了保证程序的运行流畅, 必须进行内存管理 内存管理的范围? 管理所有继承自NSObject的对象, 对基本数据类型无效.是因为对象和其他数据类型在系统中存储的空间不一样,其他局部变量主要存储在栈区(因为基本数据类型占用的存储空间是固定的,一般存放于栈区),而对象存储于堆中,当代码块结束时,这个代码块所涉及到的所有局部变量会自动弹栈清空,指向对象的指针也会被回收,这时对象就没有指针指向,但依然存在于堆内存中,造成内存泄露. objc使用什么机制管理对象内存(或者内存管理方式有哪些)？(重点) MRC(manual retain-release)手动内存管理 ARC(automatic reference counting)自动引用计数 Garbage collection (垃圾回收)。但是iOS不支持垃圾回收, ARC作为LLVM3.0编译器的一项特性, 在iOS5.0 (Xcode4) 版本后推出的。 ARC的判断准则, 只要没有强指针指向对象, 对象就会被释放. iOS是如何管理内存的？ 这个问题的话上一个问题也提到过,讲下block的内存管理,ARC下的黄金法则就行。 这里说下swift里的内存管理: delgate照样weak修饰,闭包前面用[weak self],swift里的新东西,unowned,举例,如果self在闭包被调用的时候可能为空,则用weak,反之亦然,如果为空时使用了unowned,程序会崩溃,类似访问了悬挂指针,在oc中类似于unsafe_unretained,类似assign修饰了oc对象,对象被销毁后,被unowned修饰的对象不会为空,但是unowned访问速度更快,因为weak需要unwarp后才能使用 内存管理的原则 只要还有人在使用这个对象, 那么这个对象就不会被回收 只有你想使用这个对象, 那么就应该让这个对象的引用计数器加1 当你不想使用这个对象时, 应该让对象的引用计数器减1 谁创建, 就由谁来release 如果你通过alloc, new, copy 来创建一个对象, 当你不想用这个对象的时候就必须调用release 或者autorelease 让引用计数器减1 不是你创建的就不用你负责 release 谁retain 谁release 只要你调用了retain ,无论这个对象如何生成, 都需要调用release 总结: 有加就应该有减, 曾让某个计数器加1, 就应该让其在最后减1 内存管理研究的对象: 野指针:指针变量没有进行初始化或指向的空间已经被释放。 使用野指针调用对象方法，会报异常，程序崩溃。 通常再调用完release方法后，把保存对象指针的地址清空，赋值为nil，找oc中没有空指针异常，所以[nil retain]调用方法不会有异常。 内存泄露 如 Person * person = [Person new]; (对象提前赋值nil或者清空)在栈区的person已经被释放, 而堆区new产生的对象还没有释放, 就会造成内存泄露 在MRC手动引用计数器模式下, 造成内存泄露的情况 没有配对释放，不符合内存管理原则 对象提前赋值nil或者清空，导致release不起作用。 僵尸对象 : 堆中已经被释放的对象(retainCount = 0) 空指针 : 指针赋值为空,nil 如何判断对象已经被销毁 重写dealloc方法，对象销毁时，会调用，重写时一定要[super dealloc] retainCount = 0，使用retain能否复活对象 已经被释放的对象无法复活 对象与对象之间存在的关系 继承关系 组合关系（是一种强烈的包含关系） 依赖关系(对象作为方法参数传递) 对象的组合关系中，确保成员变量不被提前释放？ 重写set方法，在set方法中，retain该对象。 成员变量的对象，在哪里配对释放？ dealloc中释放 对象组合关系中，内存泄露有哪几种情况？ set方法没有retain对象 没有release旧对象 没有判断向set方法中传入的是否为同一个对象 正确重写set方法 判断是否为同一对象 release旧对象 retain新对象 分别描述内存管理要点、autorelease、release、NSAutoreleasePool?并说明autorelease是什么时候被release的?简述什么时候由你负责释放对象,什么时候不由你释放?[NSAutoreleasePool release]和[NSAutoreleasePool drain]有什么区别? 内存管理要点:Objective-C 使用引用计数机制(retainCount)来管理内存。 内存每被引用一次,该内存的引用计数+1,每被释放一次引 用计数-1。 当引用计数 = 0 的时候,调用该对象的 dealloc 方法,来彻底从内存中删除该对象。 alloc,allocWithZone,new(带初始化)时:该对象引用计数 +1; retain:手动为该对象引用计数 +1; copy:对象引用计数 +1;//注意copy的OC数据类型是否有mutable，如有为深拷贝，新对象计数为1，如果没有，为浅拷贝，计数+1 mutableCopy:生成一个新对象,新对象引用计数为 1; release:手动为该对象引用计数 -1; autorelease:把该对象放入自动释放池,当自动释放池释放时,其内的对象引用计数 -1。 NSAutoreleasePool: NSAutoreleasePool是通过接收对象向它发送的autorelease消息,记录该对象的release消息,当自动释放池被销毁时,会自动向池中的对象发送release消息。 autorelease 是在自动释放池被销毁,向池中的对象发送release 只能释放自己拥有的对象。 区别是:在引用计数环境下(在不使用ARC情况下),两者基本一样,在GC(垃圾回收制)环境下,release 是一个no-op(无效操作),所以无论是不是GC都使用drain 面试中内存管理,release和autorelease的含义?这里尤其要强调下autorelease,它引申出自动释放池,也能引申出Run loop! 自动释放池是什么,如何工作 ? 什么是自动释放池：用来存储多个对象类型的指针变量 自动释放池对池内对象的作用：存入池内的对象，当自动释放池被销毁时，会对池内对象全部做一次release操作 对象如何加入池中：调用对象的autorelease方法 自动释放池能嵌套使用吗：能 自动释放池何时被销毁 ：简单的看，autorelease的”}”执行完以后。而实际情况是Autorelease对象是在当前的runloop迭代结束时释放的，而它能够释放的原因是系统在每个runloop迭代中都加入了自动释放池Push和Pop 多次调用对象的autorelease方法会导致：野指针异常 自动释放池的作用：将对象与自动释放池建立关系，池子内调用autorelease，在自动释放池销毁时销毁对象，延迟release销毁时间 自动释放池什么时候释放？ 通过Observer监听RunLoop的状态，一旦监听到RunLoop即将进入睡眠等待状态，就释放自动释放池（kCFRunLoopBeforeWaiting） iPhone OS有没有垃圾回收?autorelease 和垃圾回收制(gc)有什么关系? iOS 中没有垃圾回收。autorelease只是延迟释放,gc是每隔一段时间询问程序,看是否有无指针指向的对象,若有,就将它回收。他们两者没有什么关系。 ARC问题 什么是arc机制：自动引用计数. 系统判断对象是否销毁的依据：指向对象的强指针是否被销毁 arc的本质：对retainCount计算，创建+1 清空指针 - 1 或者到达autoreleasepool的大括号-1 arc目的：不需要程序员关心retain和release操作. 如何解决arc机制下类的相互引用：.h文件中使用@class关键字声明一个类，两端不能都用强指针，一端用strong一端用weak ARC通过什么方式帮助开发者管理内存？ARC相对于MRC，不是在编译时添加retain/release/autorelease这么简单。应该是编译期和运行期两部分共同帮助开发者管理内存。 在编译期，ARC用的是更底层的C接口实现的retain/release/autorelease，这样做性能更好，也是为什么不能在ARC环境下手动retain/release/autorelease，同时对同一上下文的同一对象的成对retain/release操作进行优化（即忽略掉不必要的操作） ARC也包含运行期组件，这个地方做的优化比较复杂，但也不能被忽略，手动去做未必优化得好，因此直接交给编译器来优化，相信苹果吧！ 开发项目时你是怎么检查内存泄露 静态分析 analyze instruments工具里面有个leak 可以动态分析 如果在block中多次使用 weakSelf的话，可以在block中先使用strongSelf，防止block执行时weakSelf被意外释放 对于非ARC，将 weak 改用为 block 即可 麻烦你设计个简单的图片内存缓存器（移除策略是一定要说的） 内存缓存是个通用话题，每个平台都会涉及到。cache算法会影响到整个app的表现。候选人最好能谈下自己都了解哪些cache策略及各自的特点。 常见的有FIFO,LRU,LFU等等。由于NSCache的缓存策略不透明，一些app开发者会选择自己做一套cache机制，其实并不难。 FIFO : 新访问的数据插入FIFO队列尾部，数据在FIFO队列中顺序移动；淘汰FIFO队列头部的数据； LRU : 新数据插入到链表头部；每当缓存数据命中，则将数据移到链表头部；当链表满的时候，将链表尾部的数据丢弃； LFU : 新加入数据插入到队列尾部（因为引用计数为1）；队列中的数据被访问后，引用计数增加，队列重新排序；当需要淘汰数据时，将已经排序的列表最后的数据块删除； 常见的出现内存循环引用的场景有哪些？ 定时器（NSTimer）： NSTimer经常会被作为某个类的成员变量，而NSTimer初始化时要指定self为target，容易造成循环引用（self-&gt;timer-&gt;self）。 另外，若timer一直处于validate的状态，则其引用计数将始终大于0，因此在不再使用定时器以后，应该先调用invalidate方法 block的使用： block在copy时都会对block内部用到的对象进行强引用(ARC)或者retainCount增1(非ARC)。在ARC与非ARC环境下对block使用不当都会引起循环引用问题， 一般表现为，某个类将block作为自己的属性变量，然后该类在block的方法体里面又使用了该类本身，简单说就是self.someBlock =Type var{[self dosomething];或者self.otherVar = XXX;或者_otherVar = …};出现循环的原因是：self-&gt;block-&gt;self或者self-&gt;block-&gt;_ivar（成员变量） 代理（delegate）： 在委托问题上出现循环引用问题已经是老生常谈了，规避该问题的杀手锏也是简单到哭，一字诀：声明delegate时请用assign(MRC)或者weak(ARC)，千万别手贱玩一下retain或者strong，毕竟这基本逃不掉循环引用了！ 对象添加到通知中心中，当通知中心发通知时，这个对象却已经被释放了，可能会出现什么问题？ 其实这种只是考查对通知的简单应用。通知是多对多的关系，主要使用场景是跨模块传值。当某对象加入到通知中心后，若在对象被销毁前不将该对象从通知中心中移除，当发送通知时，就会造成崩溃。这是很常见的。所以，在添加到通知中心后，一定要在释放前移除。 ARC下不显式指定任何属性关键字时，默认的关键字都有哪些？ 对于基本数据类型默认关键字是：atomic,readwrite,assign 对于普通的Objective-C对象：atomic,readwrite,strong 写一个便利构造器+ (id)Person { Person *person=[Person alloc]init]; return [person autorelease]; 备注:ARC时不用 autorelease } 写出下面程序段的输出结果NSDictionary *dict = [NSDictionary dictionaryWithObject:@"a string value" forKey:@"akey"]; NSLog(@"%@", [dict objectForKey:@"akey"]); [dict release]; 打印输出 a string value,然后崩溃----原因:便利构造器创建的对象,之后的release,会造成过度释放 请写出以下代码的执行结果NSString * name = [ [ NSString alloc] init ]; name = @”Habb”; [ name release]; 打印输出结果是: Habb,在[name release]前后打印均有输出结果 ---会造成内存泄露---原先指向的区域变成了野指针,之后的释放,不能释放之前创建的区域 写出方法获取iOS内存使用情况？iOS是如何管理内存的？我相信很多人的回答是内存管理的黄金法则，其实如果我是面试官，我想要的答案不是这样的。我希望的回答是工作中如何处理内存管理的。 参考答案： Block内存管理：由于使用block很容易造成循环引用，因此一定要小心内存管理问题。最好在基类controller下重写dealloc，加一句打印日志，表示类可以得到释放。如果出现无打印信息，说明这个类一直得不到释放，表明很有可能是使用block的地方出现循环引用了。对于block中需要引用外部controller的属性或者成员变量时，一定要使用弱引用，特别是成员变量像_testId这样的，很多人都没有使用弱引用，导致内存得不到释放。 对于普通所创建的对象，因为现在都是ARC项目，所以记住内存管理的黄金法则就可以解决。 很多内置的类，如tableview的delegate的属性是assign不是retain？ tableview的代理一般都是它所属的控制器，控制器会对它内部的view进行一次retain操作，而tableview对代理控制器也进行一次retain操作，就会出现循环引用问题。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS面试题4--Objective-C]]></title>
    <url>%2F2018%2F09%2F12%2FiOS%E9%9D%A2%E8%AF%95%E9%A2%984-Objective-C%2F</url>
    <content type="text"><![CDATA[面试笔试都是必考语法知识的。请认真复习和深入研究OC。 方法和选择器有何不同？(Difference between method and selector?) selector是一个方法的名字，method是一个组合体，包含了名字和实现. Core Foundation的内存管理 凡是带有Create、Copy、Retain等字眼的函数，创建出来的对象，都需要在最后做一次release 比如CFRunLoopObserverCreate release函数：CFRelease(对象); malloc和New的区别 new 是c++中的操作符，malloc是c 中的一个函数 new 不止是分配内存，而且会调用类的构造函数，同理delete会调用类的析构函数，而malloc则只分配内存，不会进行初始化类成员的工作，同样free也不会调用析构函数 内存泄漏对于malloc或者new都可以检查出来的，区别在于new可以指明是那个文件的那一行， 而malloc没有这些信息。 new 和 malloc效率比较 new可以认为是malloc加构造函数的执行。 new出来的指针是直接带类型信息的。 你是否接触过OC中的反射机制？简单聊一下概念和使用 class反射 通过类名的字符串形式实例化对象 Class class NSClassFromString@(@"student"); Student *stu = [[class alloc ]init]; 将类名变为字符串 Class class =[Student class]; NSString *className = NSStringFromClass(class); SEL的反射 通过方法的字符串形式实例化方法 SEL selector = NSSelectorFromClass(@"setName"); [stu performSelector:selector withObject:@"Mike"]; 将方法变成字符串 NSStringFomrSelector(@selector*(setName:)) 什么是SEL?如何声明一个SEL?通过那些方法能够,调用SEL包装起来的方法? SEL就是对方法的一种包装。包装的SEL类型数据它对应相应的方法地址，找到方法地址就可以调用方法。在内存中每个类的方法都存储在类对象中，每个方法都有一个与之对应的SEL类型的数据，根据一个SEL数据就可以找到对应的方法地址，进而调用方法。 SEL s1 = @selector(test1); // 将test1方法包装成SEL对象 SEL s2 = NSSelectorFromString(@"test1"); // 将一个字符串方法转换成为SEL对象 调用方法有两种方式： 1.直接通过方法名来调用 [person text] 2.间接的通过SEL数据来调用 SEL aaa = @selector(text); [person performSelector:aaa]; 协议中是什么意思?子类继承了父类,那么子类会遵守父类中遵守的协议吗?协议中能够定义成员变量?如何约束一个对象类型的变量要存储的地址是遵守一个协议对象? 遵守NSObject协议 会 能，但是只在头文件中声明，编译器是不会自动生成实例变量的。需要自己处理getter和setter方法 id NS/CF/CG/CA/UI这些前缀分别是什么含义 函数归属于属于cocoa Fundation框架 函数归属于属于core Fundation框架 函数归属于属于CoreGraphics.frameworks框架 函数归属于属于CoreAnimation.frameworks框架 函数归属于属于UIkit框架 面向对象都有哪些特征以及你对这些特征的理解。 继承：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。 继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段。 封装：封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。我们在类中编写的方法就是对实现细节的一种封装；我们编写一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口。 多态性 ：多态性是指允许不同子类型的对象对同一消息作出不同的响应。简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。多态性分为编译时的多态性和运行时的多态性。方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）。运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事： 方法重写（子类继承父类并重写父类中已有的或抽象的方法）； 对象造型（用父类型引用引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。 抽象：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。 我们说的Objective-C是动态运行时语言是什么意思? (When we call objective c is runtime language what does it mean?) 主要是将数据类型的确定由编译时,推迟到了运行时。这个问题其实浅涉及到两个概念,运行时和多态。 简单来说, 运行时机制使我们直到运行时才去决定一个对象的类别,以及调用该类别对象指定方法。 多态:不同对象以自己的方式响应相同的消息的能力叫做多态。 意思就是假设生物类(life)都拥有一个相同的方法-eat;那人类属于生物,猪也属于生物,都继承了life后,实现各自的eat,但是调用是我们只需调用各自的eat方法。也就是不同的对象以自己的方式响应了相同的消 息(响应了eat这个选择器)。因此也可以说,运行时机制是多态的基础. readwrite, readonly, assign, retain, copy, nonatomic属性的作用? readwrite 是可读可写特性;需要生成getter方法和setter方法; readonly 是只读特性 只会生成getter方法 不会生成setter方法 ,不希望属性在类外改变; assign 是赋值特性,setter方法将传入参数赋值给实例变量;仅设置变量时; assign用于简单数据类型,如NSInteger,double,bool; retain 表示持有特性,setter方法将传入参数先保留,再赋值,传入参数的引用计数retaincount会+1; copy 表示赋值特性,setter方法将传入对象复制一份;需要完全一份新的变量时; nonatomic 非原子操作,决定编译器生成的setter getter是否是原子操作; atomic 表示多线程安全,一般使用 nonatomic。 简述NotificationCenter、KVC、KVO、Delegate?并说明它们之间的区别?(重点) KVO（Key-Value- Observing）：一对多, 观察者模式,键值观察机制，它提供了观察某一属性变化的方法，极大简化了代码。 KVC (Key-Value-Coding)：是键值编码, 一个对象在调用setValue的时候， 检查是否存在相应key的set方法，存在就调用set方法。 set方法不存在，就查找_key的成员变量是否存在，存在就直接赋值。 如果_key没找到，就查找相同名称的key，存在就赋值。 如果没有就调用valueForUndefinedkey和setValue：forUndefinedKey。 Delegate: 通常发送者和接收者的关系是直接的一对一的关系。 代理的目的是改变或传递控制链。允许一个类在某些特定时刻通知到其他类，而不需要获取到那些类的指针。 可以减少框架复杂度。消息的发送者(sender)告知接收者(receiver)某个事件将要发生，delegate同意然然后发送者响应事件，delegate机制使得接收者可以改变发送者的行为。 Notification: 观察者模式, 通常发送者和接收者的关系是间接的多对多关系。 消息的发送者告知接收者事件已经发生或者将要发送，仅此而已，接收者并不能反过来影响发送者的行为。 区别 效率肯定是delegate比NSNotification高。 delegate方法比notification更加直接，需要关注返回值，所以delegate方法往往包含should这个很传神的词。相反的，notification最大的特色就是不关心结果。所以notification往往用did这个词汇。 两个模块之间联系不是很紧密，就用notification传值，例如多线程之间传值用notificaiton。 delegate只是一种较为简单的回调，且主要用在一个模块中，例如底层功能完成了，需要把一些值传到上层去，就事先把上层的函数通过delegate传到底层，然后在底层call这个delegate，它们都在一个模块中，完成一个功能，例如说 NavgationController 从 B 界面到A 点返回按钮 (调用popViewController方法) 可以用delegate比较好。 懒加载(What is lazy loading ?) 就是懒加载,只在用到的时候才去初始化。也可以理解成延时加载。我觉得最好也最简单的一个列子就是tableView中图片的加载显示了, 一个延时加载, 避免内存过高,一个异步加载,避免线程堵塞提高用户体验 OC有多继承吗?没有的话可以用什么方法替代? 多继承即一个子类可以有多个父类,它继承了多个父类的特性。 Object-c的类没有多继承,只支持单继承,如果要实现多继承的话,可以通过类别和协议的方式来实现。 protocol（协议）可以实现多个接口,通过实现多个接口可以完成多继承; Category（类别）一般使用分类,用Category去重写类的方法,仅对本Category有效,不会影响到其他类与原有类的关系。 分别描述类别(categories)和延展(extensions)是什么?以及两者的区别?继承和类别在实现中有何区别?为什么Category只能为对象添加方法,却不能添加成员变量? 类别: 在没有原类.m文件的基础上,给该类添加方法; 延展:一种特殊形式的类别,主要在一个类的.m文件里声明和实现延展的作用,就是给某类添加私有方法或是私有变量。 两个的区别: 延展可以添加属性并且它添加的方法是必须要实现的。延展可以认为是一个私有的类目。 类别可以在不知道,不改变原来代码的情况下往里面添加新的方法,只能添加,不能删除修改。 并且如果类别和原来类中的方法产生名称冲突,则类别将覆盖原来的方法,因为类别具有更高的优先级。 继承可以增加，修改删除方法，添加属性。 Category只能为对象添加方法,却不能添加成员变量的原因:如果可以添加成员变量,添加的成员变量没有办法初始化 Objective-C有私有方法么?私有变量呢?如多没有的话,有没有什么代替的方法? objective-c类里面的方法只有两种,静态方法和实例方法.但是可以通过把方法的声明和定义都放在.m文件中来实现一个表面上的私有方法。有私有变量,可以通过@private来修饰,或者把声明放到.m文件中。在Objective‐C中,所有实例变量默认都是私有的, 所有实例方法默认都是公有的 #include与#import的区别? #import与 @class的区别? #import指令是Object-C针对#include的改进版本，#import确保引用的文件只会被引用一次，这样你就不会陷入递归包含的问题中。 # impor与@class二者的区别在于： #import会链入该头文件的全部信息，包括实例变量和方法等；而@class只是告诉编译器，其后面声明的名称是类的名称，至于这些类是如何定义的，暂时不用考虑。 在头文件中一般使用@class来声明这个名称是类的名称,不需要知道其内部的实体变量和方法. 而在实现类里面，因为会用到这个引用类的内部的实体变量和方法，所以需要使用#import来包含这个被引用类的头文件。 在编译效率方面，如果你有100个头文件都#import了同一个头文件，或者这些文件是依次引用的，如A–&gt;B, B–&gt;C, C–&gt;D这样的引用关系。当最开始的那个头文件有变化的话，后面所有引用它的类都需要重新编译，如果你的类有很多的话，这将耗费大量的时间。而是用@class则不会。 如果有循环依赖关系，如:A–&gt;B, B–&gt;A这样的相互依赖关系，如果使用#import来相互包含，那么就会出现编译错误，如果使用@class在两个类的头文件中相互声明，则不会有编译错误出现。 浅复制(拷贝)和深复制的区别? (Difference between shallow copy and deep copy?) 浅复制(copy)：只复制指向对象的指针，而不复制引用对象本身。 深复制(mutableCopy)：复制引用对象本身。深复制就好理解了,内存中存在了两份独立对象本身, 当修改A时,A_copy不变。 类变量的@protected,@private,@public,@package声明各有什么含义?变量的作用域不同。 @protected 该类和子类中访问，是默认的; @private 只能在本类中访问; @public 任何地方都能访问; @package 本包内使用，跨包不可以 Objective-C与C、C+++之间的联系和区别？ Objective-C和C++都是C的面向对象的超集。 Object与C++的区别主要点：Objective-C是完全动态的，支持在运行时动态类型决议(dynamic typing)，动态绑定(dynamic binding)以及动态装载(dynamic loading)；而C++是部分动态的，编译时静态绑定，通过嵌入类(多重继承)和虚函数(虚表)来模拟实现。 Objective-C 在语言层次上支持动态消息转发，其消息发送语法为 [object function]； 而且C++ 为 object-&gt;function()。 两者的语义也不同，在 Objective-C 里是说发送消息到一个对象上，至于这个对象能不能响应消息以及是响应还是转发消息都不会 crash； 而在 C++ 里是说对象进行了某个操作，如果对象没有这个操作的话，要么编译会报错(静态绑定)，要么程序会 crash 掉的(动态绑定)。 目标-动作机制 目标是动作消息的接收者。一个控件，或者更为常见的是它的单元，以插座变量的形式保有其动作消息的目标。 动作是控件发送给目标的消息，或者从目标的角度看，它是目标为了响应动作而实现的方法. 程序需要某些机制来进行事件和指令的翻译。这个机制就是目标-动作机制。 Objective-C优点和缺点 优点:1.Cateogies 2.Posing 3.动态识别 4.指标计算 5.弹性讯息传递 6.不是一个过度复杂的C衍生语言 7.Objective-C与C++可混合编程 缺点:1.不支持命名空間 2.不支持运算符重载 3.不支持多重继承 4.使用动态运行时类型,所有的方法都是函数调用,所以很多编译时优化方法都用不到。(如内联函数等),性能低劣。 C语言的函数调用和oc的消息机制有什么区别? 对于C语言，函数的调用在编译的时候会决定调用哪个函数。编译完成之后直接顺序执行。 OC的函数调用成为消息发送。属于动态调用过程。在编译的时候并不能决定真正调用哪个函数（事实证明，在编译阶段，OC可以调用任何函数，即使这个函数并未实现，只要申明过就不会报错。而C语言在编译阶段就会报错）。只有在真正运行的时候才会根据函数的名称找到对应的函数来调用。 什么是谓词谓词就是通过NSPredicate给定的逻辑条件作为约束条件，完成对数据的筛选。 定义谓词对象，谓词对象中包含了过滤条件 NSPredicate *predicate = [NSPredicate predicateWithFormat:@"age40"]; array = [persons filteredArrayUsingPredicate:predicate]; 包含语句的使用 predicate = [NSPredicate predicateWithFormat:@"[self.name](https://link.jianshu.com?t=http://self.name) IN {'1','2','4'} || self.age IN{30,40}"]; 指定字符开头和指定字符结尾，是否包含指定字符 name以a开头的 predicate = [NSPredicate predicateWithFormat:@"name BEGINSWITH 'a'"]; name以ba结尾的 predicate = [NSPredicate predicateWithFormat:@"name ENDSWITH 'ba'"]; name中包含字符a的 predicate = [NSPredicate predicateWithFormat:@"name CONTAINS 'a'"]; like进行匹配多个字符 name中只要有s字符就满足条件 predicate = [NSPredicate predicateWithFormat:@"name like '*s*'"]; ?代表一个字符，下面的查询条件是：name中第二个字符是s的 predicate = [NSPredicate predicateWithFormat:@"name like '?s'"]; C与OC混用处理.m可以识别c和oc，.mm可以识别c c++ oc 但是cpp只能用c/c++ atomic和nonatomic的区别 atomic提供多线程安全，防止读写未完成的时候被另外一个线程读写，造成数据错误。 nonatomic在自己管理内存的环境中，解析的访问器保留并自动释放返回值，若指定了nonatomic，那么访问器只是简单的返回这个值。 常见的oc数据类型哪些，和c的基本类型有啥区别 常见的：NSInteger CGFloat NSString NSNumber NSArray NSDate NSInteger根据32或者64位系统决定本身是int还是long CGFloat根据32或者64位系统决定本身是float还是double NSString NSNumber NSArray NSDate都是指针类型的对象，在堆中分配内存，c语言中的char int 等都是在栈中分配空间 id和nil代表什么 id类型的指针可以指向任何OC对象 nil代表空值（空指针的值，0） nil和NULL的区别？ 从oc的官方语法上看，nil表示对象的指针 即对象的引用为空 null表示指向基础数据类型变量 即c语言变量的指针为空 在非arc中 两个空可以互换，但是在arc中 普通指针和对象引用被严格限制，不能互换 nil、Nil、NULL和NSNull区别 nil和C语言的NULL相同，在objc/objc.h中定义。nil表示Objective-C对象的值为空。在C语言中，指针的空值用NULL表示。在Objective-C中，nil对象调用任何方法表示什么也不执行，也不会崩溃。 Nil:那么对于我们Objective-C开发来说，Nil也就代表((void *)0)。但是它是用于代表空类的. 比如：Class myClass = Nil; NULL: 在C语言中，NULL是无类型的，只是一个宏，它代表空. 这就是在C/C++中的空指针。对于我们Objective-C开发来说，NULL就表示((void*)0). NSNull:NSNull是继承于NSObject的类型。它是很特殊的类，它表示是空，什么也不存储，但是它却是对象，只是一个占位对象。使用场景就不一样了，比如说服务端接口中让我们在值为空时，传空。NSDictionry *parameters = @{@”arg1” : @”value1”,@”arg2” : arg2.isEmpty ? [NSNull null] : arg2}; NULL、nil、Nil这三者对于Objective-C中值是一样的，都是(void *)0，那么为什么要区分呢？又与NSNull之间有什么区别： NULL是宏，是对于C语言指针而使用的，表示空指针 nil是宏，是对于Objective-C中的对象而使用的，表示对象为空 Nil是宏，是对于Objective-C中的类而使用的，表示类指向空 NSNull是类类型，是用于表示空的占位对象，与JS或者服务端的null类似的含意 向一个nil对象发送消息会发生什么？ 向nil发送消息是完全有效的——只是在运行时不会有任何作用。 如果一个方法返回值是一个对象，那么发送给nil的消息将返回0(nil) 如果方法返回值为指针类型，其指针大小为小于或者等于sizeof(void*)，float，double，long double 或者long long的整型标量，发送给nil的消息将返回0。 -如果方法返回值为结构体，正如在《Mac OS X ABI 函数调用指南》，发送给nil的消息将返回0。结构体中各个字段的值将都是0。其他的结构体数据类型将不是用0填充的。 如果方法的返回值不是上述提到的几种情况，那么发送给nil的消息的返回值将是未定义的。 self.和self-&gt;的区别 self.是调用get或者set方法 self是当前本身，是一个指向当前对象的指针 self-&gt;是直接访问成员变量 类方法和实例方法的本质区别和联系 类方法 实例方法 属于类对象 属于实例对象 只能类对象调用 实例对象调用 self是类对象 self是实例对象 类方法可以调用其他类方法 实例方法可以调用实例方法 类方法不能访问成员变量 实例方法可以访问成员变量 类方法不能直接调用对象方法 实例方法可以调用类方法 _block/weak修饰符区别 _block在arc和mrc环境下都能用，可以修饰对象，也能修饰基本数据类型 _weak只能在arc环境下使用，只能修饰对象(NSString)，不能修饰基本数据类型(int) _block对象可以在block中重新赋值，_weak不行。 写一个NSString类的实现NSString *str = [[NSString alloc] initWithCString: nullTerminatedCString encoding:encoding]; 为什么标准头文件都有类似以下的结构？# ifndef __INCvxWorksh # define __INCvxWorksh # ifdef __cplusplus extern "C" { # endif # ifdef __cplusplus } # endif # endif 显然，头文件中的编译宏 #ifndef __INCvxWorksh、#define __INCvxWorksh、#endif 的作用是防止该头文件被重复引用 init和initwithobject区别（语法）？ 后者给属性赋值 @property的本质是什么？ivar、getter、setter是如何生成并添加到这个类中的？@property的本质： @property = ivar（实例变量） + getter（取方法） + setter（存方法） “属性” (property)有两大概念：ivar（实例变量）、存取方法（access method ＝ getter + setter） ivar、getter、setter如何生成并添加到类中： 这是编译器自动合成的，通过@synthesize关键字指定，若不指定，默认为@synthesize propertyName = _propertyName;若手动实现了getter/setter方法，则不会自动合成。 现在编译器已经默认为我们添加@synthesize propertyName = _propertyName;因此不再需要手动添加了，除非你真的要改成员变量名。 生成getter方法时，会判断当前属性名是否有_，比如声明属性为@property (nonatomic, copy) NSString *_name;那么所生成的成员变量名就会变成__name，如果我们要手动生成getter方法，就要判断是否以_开头了。 不过，命名都要有规范，是不允许声明属性是使用_开头的，不规范的命名，在使用runtime时，会带来很多的不方便的。 这个写法会出什么问题：@property (copy) NSMutableArray *array; 没有指明为nonatomic，因此就是atomic原子操作，会影响性能。该属性使用了同步锁，会在创建时生成一些额外的代码用于帮助编写多线程程序，这会带来性能问题，通过声明nonatomic可以节省这些虽然很小但是不必要额外开销。在我们的应用程序中，几乎都是使用nonatomic来声明的，因为使用atomic并不能保证绝对的线程安全，对于要绝对保证线程安全的操作，还需要使用更高级的方式来处理，比如NSSpinLock、@syncronized等 因为使用的是copy，所得到的实际是NSArray类型，它是不可变的，若在使用中使用了增、删、改操作，则会crash @protocol和category中如何使用 @property• 在protocol中使用@property只会生成setter和getter方法声明，我们使用属性的目的是希望遵守我协议的对象能实现该属性• category使用@property也是只会生成setter和getter方法的声明，如果我们真的需要给category增加属性的实现，需要借助于运行时的两个函数：• objc_setAssociatedObject• objc_getAssociatedObject @property中有哪些属性关键字？1.原子性 （atomic，nonatomic）2.读写（readwrite, readonly）3.内存管理（assign, strong, weak, unsafe_unretained,copy）4.getter、setter isa指针问题 isa：是一个Class 类型的指针. 每个实例对象有个isa的指针,他指向对象的类，而Class里也有个isa的指针, 指向meteClass(元类)。元类保存了类方法的列表。当类方法被调用时，先会从本身查找类方法的实现，如果没有，元类会向他父类查找该方法。同时注意的是：元类（meteClass）也是类，它也是对象。元类也有isa指针,它的isa指针最终指向的是一个根元类(root meteClass).根元类的isa指针指向本身，这样形成了一个封闭的内循环。 如何访问并修改一个类的私有属性？ 一种是通过KVC获取 通过runtime访问并修改私有属性 如何为 Class 定义一个对外只读对内可读写的属性?在头文件中将属性定义为readonly,在.m文件中将属性重新定义为readwrite Objective-C 中，meta-class 指的是什么？meta-class 是 Class 对象的类,为这个Class类存储类方法,当一个类发送消息时,就去这个类对应的meta-class中查找那个消息,每个Class都有不同的meta-class,所有的meta-class都使用基类的meta-class(假如类继承NSObject,那么他所对应的meta-class也是NSObject)作为他们的类 Objective-C 的class是如何实现的？Selector是如何被转化为 C 语言的函数调用的？ 当一个类被正确的编译过后，在这个编译成功的类里面，存在一个变量用于保存这个类的信息。我们可以通过[NSClassFromString]或[obj class]。这样的机制允许我们在程序执行的过程当中，可以Class来得到对象的类，也可以在程序执行的阶段动态的生成一个在编译阶段无法确定的一个对象。 （isa指针） @selector()基本可以等同C语言的中函数指针,只不过C语言中，可以把函数名直接赋给一个函数指针，而Object-C的类不能直接应用函数指针，这样只能做一个@selector语法来取. @interface foo -(int)add:int val; @end SEL class_func ; //定义一个类方法指针 class_func = @selector(add:int); @selector是查找当前类的方法，而[object @selector(方法名:方法参数..) ] ;是取object对应类的相应方法. 查找类方法时，除了方法名,方法参数也查询条件之一. 可以用字符串来找方法 SEL 变量名 = NSSelectorFromString(方法名字的字符串); 可以运行中用SEL变量反向查出方法名字字符串。NSString *变量名 = NSStringFromSelector(SEL参数); 取到selector的值以后，执行seletor。 SEL变量的执行.用performSelecor方法来执行. [对象 performSelector:SEL变量 withObject:参数1 withObject:参数2]; 对于语句NSString *obj = [[NSData alloc] init]; ，编译时和运行时obj分别是什么类型？ 编译时是NSString类型 ，运行时是NSData类型. @synthesize和@dynamic分别有什么作用？答: @property有两个对应的词，一个是 @synthesize，一个是 @dynamic。如果 @synthesize和 @dynamic都没写，那么默认的就是@syntheszie var = _var; @synthesize 的语义是如果你没有手动实现 setter 方法和 getter 方法，那么编译器会自动为你加上这两个方法。 @dynamic 告诉编译器：属性的 setter 与 getter 方法由用户自己实现，不自动生成。（当然对于 readonly 的属性只需提供 getter 即可）。假如一个属性被声明为 @dynamic var，然后你没有提供 @setter方法和 @getter 方法，编译的时候没问题，但是当程序运行到 instance.var = someVar，由于缺 setter 方法会导致程序崩溃；或者当运行到 someVar = var 时，由于缺 getter 方法同样会导致崩溃。编译时没问题，运行时才执行相应的方法，这就是所谓的动态绑定。 NSString 的时候用copy和strong的区别？OC中NSString为不可变字符串的时候，用copy和strong都是只分配一次内存，但是如果用copy的时候，需要先判断字符串是否是不可变字符串，如果是不可变字符串，就不再分配空间，如果是可变字符串才分配空间。如果程序中用到NSString的地方特别多，每一次都要先进行判断就会耗费性能，影响用户体验，用strong就不会再进行判断，所以，不可变字符串可以直接用strong。 NSArray、NSSet、NSDictionary与NSMutableArray、NSMutableSet、NSMutableDictionary的特性和作用（遇到copy修饰产生的变化） 特性： NSArray表示不可变数组，是有序元素集，只能存储对象类型，可通过索引直接访问元素，而且元素类型可以不一样，但是不能进行增、删、改操作；NSMutableArray是可变数组，能进行增、删、改操作。通过索引查询值很快，但是插入、删除等效率很低。 NSSet表示不可变集合，具有确定性、互异性、无序性的特点，只能访问而不能修改集合；NSMutableSet表示可变集合，可以对集合进行增、删、改操作。集合通过值查询很快，插入、删除操作极快。 NSDictionary表示不可变字典，具有无序性的特点，每个key对应的值是唯一的，可通过key直接获取值；NSMutableDictionary表示可变字典，能对字典进行增、删、改操作。通过key查询值、插入、删除值都很快。 作用： 数组用于处理一组有序的数据集，比如常用的列表的dataSource要求有序，可通过索引直接访问，效率高。 集合要求具有确定性、互异性、无序性，在iOS开发中是比较少使用到的，笔者也不清楚如何说明其作用 字典是键值对数据集，操作字典效率极高，时间复杂度为常量，但是值是无序的。在ios中，常见的JSON转字典，字典转模型就是其中一种应用。 请把字符串2015-04-10格式化日期转为NSDate类型NSString *timeStr = @"2015-04-10"; NSDateFormatter *formatter = [[NSDateFormatter alloc] init]; formatter.dateFormat = @"yyyy-MM-dd"; formatter.timeZone = [NSTimeZone defaultTimeZone]; NSDate *date = [formatter dateFromString:timeStr]; // 2015-04-09 16:00:00 +0000 NSLog(@"%@", date); 在一个对象的方法里：[self.name=@object] 和name=@object有什么不同 这是老生常谈的话题了，实质上就是问setter方法赋值与成员变量赋值有什么不同。通过点语法self.name实质上就是 [self setName:@object];。而name这里是成员变量，直接赋值。 一般来说，在对象的方法里成员变量和方法都是可以访问的，我们通常会重写Setter方法来执行某些额外的工作。比如说，外部传一个模型过来，那么我会直接重写Setter方法，当模型传过来时，也就是意味着数据发生了变化，那么视图也需要更新显示，则在赋值新模型的同时也去刷新UI。这样也不用再额外提供其他方法了。 怎样使用performSelector传入3个以上参数，其中一个为结构体- (id)performSelector:(SEL)aSelector; - (id)performSelector:(SEL)aSelector withObject:(id)object; - (id)performSelector:(SEL)aSelector withObject:(id)object1 withObject:(id)object2; 因为系统提供的performSelector的api中，并没有提供三个参数。因此，我们只能传数组或者字典，但是数组或者字典只有存入对象类型，而结构体并不是对象类型，那么怎么办呢？ 没有办法，我们只能通过对象放入结构作为属性来传过去了： ypedef struct HYBStruct { int a; int b; } *my_struct; @interface HYBObject : NSObject @property (nonatomic, assign) my_struct arg3; @property (nonatomic, copy) NSString *arg1; @property (nonatomic, copy) NSString *arg2; @end @implementation HYBObject // 在堆上分配的内存，我们要手动释放掉 - (void)dealloc { free(self.arg3); } @end 测试： my_struct str = (my_struct)(malloc(sizeof(my_struct))); str->a = 1; str->b = 2; HYBObject *obj = [[HYBObject alloc] init]; obj.arg1 = @"arg1"; obj.arg2 = @"arg2"; obj.arg3 = str; [self performSelector:@selector(call:) withObject:obj]; // 在回调时得到正确的数据的 - (void)call:(HYBObject *)obj { NSLog(@"%d %d", obj.arg3->a, obj.arg3->b); } objc中向一个对象发送消息[obj foo]和objc_msgSend()函数之间有什么关系？实际上，编译器在编译时会转换成objc_msgSend，大概会像这样： ((void (*)(id, SEL))(void)objc_msgSend)((id)obj, sel_registerName("foo")); 也就是说，[obj foo];在objc动态编译时，会被转换为：objc_msgSend(obj, @selector(foo));这样的形式，但是需要根据具体的参数类型及返回值类型进行相应的类型转换。 下面的代码输出什么？@implementation Son : Father - (id)init { self = [super init]; if (self) { NSLog(@"%@", NSStringFromClass([self class])); NSLog(@"%@", NSStringFromClass([super class])); } return self; } @end // 输出 NSStringFromClass([self class]) = Son NSStringFromClass([super class]) = Son 这个题目主要是考察关于Objective-C中对self和super的理解。我们都知道：self是类的隐藏参数，指向当前调用方法的这个类的实例。那super呢？很多人会想当然的认为“super和self类似，应该是指向父类的指针吧！”。这是很普遍的一个误区。其实 super是一个 Magic Keyword，它本质是一个编译器标示符，和self 是指向的同一个消息接受者！他们两个的不同点在于：super会告诉编译器，调用class 这个方法时，要去父类的方法，而不是本类里的。 上面的例子不管调用[self class]还是[super class]，接受消息的对象都是当前 Son ＊xxx 这个对象。当使用self调用方法时，会从当前类的方法列表中开始找，如果没有，就从父类中再找；而当使用super时，则从父类的方法列表中开始找。然后调用父类的这个方法。 若一个类有实例变量NSString *_foo，调用setValue:forKey:时，可以以foo还是_foo作为key？ 两者都可以。 什么时候使用NSMutableArray，什么时候使用NSArray? 当数组在程序运行时，需要不断变化的，使用NSMutableArray，当数组在初始化后，便不再改变的，使用NSArray。需要指出的是，使用NSArray只表明的是该数组在运行时不发生改变，即不能往NSAarry的数组里新增和删除元素，但不表明其数组內的元素的内容不能发生改变。NSArray是线程安全的，NSMutableArray不是线程安全的，多线程使用到NSMutableArray需要注意。 类NSObject的那些方法经常被使用? NSObject是Objetive-C的基类，其由NSObject类及一系列协议构成。 其中类方法alloc、class、 description 对象方法init、dealloc、– performSelector:withObject:afterDelay:等经常被使用 什么是简便构造方法? 简便构造方法一般由CocoaTouch框架提供，如NSNumber的`objc numberWithBool: numberWithChar: numberWithDouble: numberWithFloat: numberWithInt:` Foundation下大部分类均有简便构造方法，我们可以通过简便构造方法，获得系统给我们创建好的对象，并且不需要手动释放。 什么是构造方法，使用构造方法有什么注意点。什么是构造方法：构造方法是对象初始化并一个实例的方法。 构造方法有什么用： 一般在构造方法里 对类进行一些初始化操作 注意点：方法开头必须以init开头，接下来名称要大写 例如 initWithName ，initLayout 创建一个对象需要经过那三个步骤？ 开辟内存空间 初始化参数 返回内存地址值 Get方法的作用是什么？Get方法的作用：为调用者返回对象内部的成员变量 Set方法的作用是什么？Set方法的好处？ Set方法的作用：为外界提供一个设置成员变量值的方法。 Set方法的好处： 不让数据暴露在外，保证了数据的安全性 对设置的数据进行过滤 结构体当中能定义oc对象吗？不能, 因为结构体当中只能是类型的声明不能进行分配空间 点语法本质是什么,写一个点语法的例子,并写上注释 点语法的本质是方法的调用，而不是访问成员变量，当使用点语法时，编译器会自动展开成相应的方法。切记点语法的本质是转换成相应的set和get方法，如果没有set和get方法，则不能使用点语法。 例如有一个Person类 通过@property定义了name和age属性,再提供了一个run方法。 Person *person = [Person new]; person.name=@”sk666”;//调用了person的setName方法 int age = person.age; // 调用了person的age方法 person.run //调用了person的run方法 id类型是什么，instancetype是什么，有什么区别？ id类型：万能指针，能作为参数，方法的返回类型。 instancetype：只能作为方法的范围类型，并且返回的类型是当前定义类的类类型。 成员变量名的命名以下划线开头的好处？ 与get方法的方法名区分开来； 可以和一些其他的局部变量区分开来，下划线开头的变量，通常都是类的成员变量。 这段代码有什么问题吗:@implementation Person - (void)setAge:(int)newAge { self.age = newAge; } @end 会死循环,会重复调用自己!self.age 改为_age即可; 并且书写不规范:setter方法中的newAge应该为age 截取字符串”20 | http://www.baidu.com” 中, ”|”字符前面和后面的数据,分别输出它们。NSString * str = @"20 | http://www.baidu.com"; NSArray *array = [str componentsSeparatedByString:@"|"]; //这是分别输出的截取后的字符串 for (int i = 0; i]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS面试题3--C语言]]></title>
    <url>%2F2018%2F09%2F12%2FiOS%E9%9D%A2%E8%AF%95%E9%A2%983-C%E8%AF%AD%E8%A8%80%2F</url>
    <content type="text"><![CDATA[C语言，开发的基础功底，iOS很多高级应用都要和C语言打交道，所以，C语言在iOS开发中的重要性，你懂的。里面的一些问题可能并不是C语言问题，但是属于计算机的一些原理性的知识点，所以我就不再另外写一篇文章了，直接写在这里。 当你写下面的代码时会发生什么事？ least = MIN(*p++, b); 结果是：((p++) &lt;= (b) ? (p++) : (*p++)) 这个表达式会产生副作用，指针p会作三次++自增操作。 用预处理指令#define声明一个常数，用以表明1年中有多少秒（忽略闰年问题）#define SECONDS_PER_YEAR (60 * 60 * 24 * 365)UL(UL无符号长整形) 写一个”标准”宏MIN ，这个宏输入两个参数并返回较小的一个。#define MIN(A,B) （（A） &lt;= (B) ? (A) : (B)) 写一个标准宏Max，并给出以下代码的输出int array[5] = {1, 2, 3, 4, 5}; int *p = &amp;array[0]; int max = Max(*p++, 1); printf("%d %d", max, *p); 参考答案： 1，2 #define Max(X, Y) ((X) > (Y) ? (X) : (Y)) 当看到宏时，就会想到宏定义所带来的副作用。对于++、–，在宏当中使用是最容易产生副作用的，因此要慎用。 分析： p指针指向了数组array的首地址，也就是第一个元素对应的地址，其值为1. 宏定义时一定要注意每个地方要加上圆括号 *p++相当于*p, p++,所以Max(*p++, 1)相当于： (*p++) > (1) ? (*p++) : (1) => (1) > (1) ? (*p++) : (1) => 第一个*p++的结果是，p所指向的值变成了2，但是1 > 1为値，所以最终max的值就是1。而后面的(*p++)也就不会执行，因此p所指向的地址对应的值就是2，而不是3. 扩展：如果上面的*p++改成*(++p)如何？ (*++p) > (1) ? (*++p) : (1) => (2) > (1) ? (*++p) : (1) => max = *++p; => *p = 3，max = 3; define定义的宏和const定义的常量有什么区别？λ #define定义宏的指令，程序在预处理阶段将用#define所定义的内容只是进行了替换。因此程序运行时，常量表中并没有用#define所定义的宏，系统并不为它分配内存，而且在编译时不会检查数据类型，出错的概率要大一些。 λ const定义的常量，在程序运行时是存放在常量表中，系统会为它分配内存，而且在编译时会进行类型检查。 #define定义表达式时要注意“边缘效应”，例如如下定义： #define N 2 + 3 // 我们预想的N值是5，我们这样使用N int a = N / 2; // 我们预想的a的值是2.5，可实际上a的值是3.5 关键字volatile有什么含意?并给出三个不同的例子 优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。下面是volatile变量的几个例子： 并行设备的硬件寄存器（如：状态寄存器） 一个中断服务子程序中会访问到的非自动变量(Non-automatic variables) 多线程应用中被几个任务共享的变量 完成字符串拷贝可以使用sprintf、strcpy、以及memcpy函数，请问这些函数有什么区别?你喜欢哪一个？为什么？这些函数的区别在于实现功能以及操作对象不同。 strcpy：函数操作的对象是字符串，完成从源字符串到目的字符串的拷贝功能。 sprintf：这个函数主要用来实现（字符串或基本数据类型）向字符串的转换功能。如果源对象是字符串，并且指定%s格式符，也可实现字符串拷贝功能。 memcpy：函数顾名思义就是内存拷贝，实现将一个内存块的内容复制到另一个内存块这一功能。内存块由其首地址以及长度确定。因此，memcpy 的操作对象适用于任意数据类型，只要能给出对象的起始地址和内存长度信息、并且对象具有可操作性即可。鉴于memcpy函数等长拷贝的特点以及数据类型代表的物理意义，memcpy函数通常限于同种类型数据或对象之间的拷贝，其中当然也包括字符串拷贝以及基本数据类型的拷贝。 对于字符串拷贝来说，用上述三个函数都可以实现，但是其实现的效率和使用的方便程度不同： strcpy 无疑是最合适的选择：效率高且调用方便。 snprintf 要额外指定格式符并且进行格式转化，麻烦且效率不高。 memcpy 虽然高效，但是需要额外提供拷贝的内存长度这一参数，易错且使用不便；并且如果长度指定过大的话（最优长度是源字符串长度 + 1），还会带来性能的下降。其实 strcpy 函数一般是在内部调用 memcpy函数或者用汇编直接实现的，以达到高效的目的。因此，使用 memcpy 和 strcpy 拷贝字符串在性能上应该没有什么大的差别。 对于非字符串类型的数据的复制来说，strcpy和snprintf一般就无能为力了，可是对memcpy却没有什么影响。但是，对于基本数据类型来说，尽管可以用 memcpy 进行拷贝，由于有赋值运算符可以方便且高效地进行同种或兼容类型的数据之间的拷贝，所以这种情况下memcpy几乎不被使用。memcpy的长处是用来实现（通常是内部实现居多）对结构或者数组的拷贝，其目的是或者高效，或者使用方便，甚或两者兼有。 sprintf,strcpy,memcpy使用上有什么要注意的地方 strcpy是一个字符串拷贝的函数，它的函数原型为strcpy(char dst, const char src); 将src开始的一段字符串拷贝到dst开始的内存中去，结束的标志符号为 ‘\0’，由于拷贝的长度不是由我们自己控制的，所以这个字符串拷贝很容易出错。 具备字符串拷贝功能的函数有memcpy，这是一个内存拷贝函数，它的函数原型为memcpy(char dst, const char src, unsigned int len);将长度为len的一段内存，从src拷贝到dst中去，这个函数的长度可控。但是会有内存读写错误。(比如len的长度大于要拷贝的空间或目的空间) sprintf是格式化函数。将一段数据通过特定的格式，格式化到一个字符串缓冲区中去。sprintf格式化的函数的长度不可控，有可能格式化后的字符串会超出缓冲区的大小，造成溢出。 static关键字的作用 隐藏。编译多个文件时，所有未加static前缀的全局变量和函数都全局可见。 保持变量内容的持久。全局变量和static变量都存储在静态存储区，程序开始运行就初始化，只初始化一次。static控制了变量的作用范围。 默认初始化为0.在静态数据区，内存中的所有字节都是0x00，全局变量和static变量都是默认初始化为0. static关键字区别： static全局变量与普通的全局变量有什么区别：static全局变量只初使化一次，防止在其他文件单元中被引用; static局部变量和普通局部变量有什么区别：static局部变量只被初始化一次，下一次依据上一次结果值； static函数与普通函数有什么区别：static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝 关键字const const int a;int const a; 作用是一样：a 是一个常整型数 const int a;int const a; a 是一个指向常整型数的指针(整型数是不可修改的，但指针可以) int * const a;a 是一个指向整型数的常指针(指针指向的整型数是可以修改的，但指针是不可修改的) int const * const a;a 是一个指向常整型数的常指针(指针指向的整型数是不可修改的，同时指针也是不可修改的) 堆栈 管理方式：对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生内存泄露 (memory leak)。 申请大小： 栈：在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在Windows下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示 overflow。因此，能从栈获得的空间较小。 堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。 碎片问题： 对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个 问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出 分配方式： 堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由 alloc函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。 分配效率： 栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的 效率比较高。堆则是C/C++函数库提供的，它的机制是很复杂的 数组和指针的区别 数组可以申请在栈区和数据区；指针可以指向任意类型的内存块 sizeof作用于数组时，得到的是数组所占的内存大小；作用于指针时，得到的都是4个字节的大小 数组名表示数组首地址，是常量指针，不可修改指向。比如不可以将＋＋作用于数组名上；普通指针的值可以改变，比如可将＋＋作用于指针上 用字符串初始化字符数组是将字符串的内容拷贝到字符数组中；用字符串初始化字符指针是将字符串的首地址赋给指针，也就是指针指向了该字符串 引用和指针的区别 指针指向一块内存，内容存储所指内存的地址。 引用是某块内存的别名。 引用使用时不需要解引用（*）而指针需要 引用只在定义时被初始化，之后不可变，指针可变。 引用没有const 引用不能为空 sizeof引用得到的是所指向变量（对象）的大小，sizeof指针是指针本身的大小。 指针和引用的自增(++)运算意义不一样：引用++为引用对象自己++，指针++是指向对象后面的内存 程序需要为指针分配内存区域，引用不需要。 用变量a给出下面的定义 一个整型数（An integer） 一个指向整型数的指针（ A pointer to an integer） 一个指向指针的的指针，它指向的指针是指向一个整型数（ A pointer to a pointer to an intege）r 一个有10个整型数的数组（ An array of 10 integers） 一个有10个指针的数组，该指针是指向一个整型数的。（An array of 10 pointers to integers） 一个指向有10个整型数数组的指针（ A pointer to an array of 10 integers） 一个指向函数的指针，该函数有一个整型参数并返回一个整型数（A pointer to a function that takes an integer as an argument and returns an integer） 一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数（ An array of ten pointers to functions t hat take an integer argument and return an integer ） 答案是： int a; // An integer int *a; // A pointer to an integer int **a; // A pointer to a pointer to an integer int a[10]; // An array of 10 integers int *a[10]; // An array of 10 pointers to integers int (*a)[10]; // A pointer to an array of 10 integers int (*a)(int); // A pointer to a function a that takes an integer argument and returns an integer int (*a[10])(int); // An array of 10 pointers to functions that take an integer argument and return an integer 请写出以下代码输出int a[5] = {1, 2, 3, 4, 5}; int *ptr = (int *)(&amp;a + 1); printf("%d, %d", *(a + 1), *(ptr + 1)); 参考答案： 2, 随机值 这种类型题好像挺常见的。考的就是C语言上的指针的理解和数组的理解。 分析： a代表有5个元素的数组的首地址，a[5]的元素分别是1，2，3，4，5。接下来，a + 1表示数据首地址加1，那么就是a[1]，也就是对应于值为2.但是，这里是&amp;a + 1，因为a代表的是整个数组，它的空间大小为5 * sizeof(int)，因此&amp;a + 1就是a+5。a是个常量指针，指向当前数组的首地址，指针+1就是移动sizeof(int)个字节。 因此，ptr是指向int *类型的指针，而ptr指向的就是a + 5，那么ptr + 1也相当于a + 6，所以最后的*(ptr + 1)就是一个随机值了。而*(ptr – 1)就相当于a + 4，对应的值就是5。 简述内存分区情况 代码区：存放函数二进制代码 数据区：系统运行时申请内存并初始化，系统退出时由系统释放，存放全局变量、静态变量、常量 堆区：通过malloc等函数或new等操作符动态申请得到，需程序员手动申请和释放 栈区：函数模块内申请，函数结束时由系统自动释放，存放局部变量、函数参数 用NSLog函数输出一个浮点类型，结果四舍五入，并保留一位小数float money = 1.011; NSLog(@"%.1f", money);]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS面试题2--UNIX常用命令]]></title>
    <url>%2F2018%2F09%2F12%2FiOS%E9%9D%A2%E8%AF%95%E9%A2%982-UNIX%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[做开发说用不到命令行，那肯定是不可能的。所以记住几个常用的命令还是很有用。 cd 改变工作目录 pwd 输出当前工作目录的绝对路径 在UNIX中要执行什么命令，一定要知道自己当前所在的工作目录 ls 查看文件 $ ls 显示文件 $ ls -a 显示所有文件 $ ls -l 列表显示文件 $ ls -la 列表显示所有文件 touch 用于更改文件访问和修改时间的标准UNIX程序，也被用于创建新文件 $ touch test.txt 注意：touch不修改test.txt内容，只更改它的访问、修改时间，如果test.txt不存在，它会被创建 cat 连续查看文件内容 more 分页查看文件内容 提示： 1&gt; 命令和参数之间需要添加空格 2&gt; 如果要使用当前目录中的文件名，输入到一半时，按TAB键能够补全]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS面试题1--版本控制]]></title>
    <url>%2F2018%2F09%2F12%2FiOS%E9%9D%A2%E8%AF%95%E9%A2%981-%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[面试过程中，可能会问及一些关于版本控制的问题，理解下SVN和Git的原理，记住常用命令即可。 SVN SVN 是集中式源代码管理工具 概念： 1&gt; Repository 代码仓库，保存代码的仓库 2&gt; Server 服务器，保存所有版本的代码仓库 3&gt; Client 客户端，只保存当前用户的代码仓库 4&gt; 用户名&amp;密码 访问代码仓库需要使用自己的&quot;用户名和密码&quot;，从而可以区分出不同的人对代码做的修改 操作： 1&gt; checkout 将服务器上最新的代码仓库下载到本地，&quot;只需要做一次&quot; 2&gt; update 从服务器上将其他人所做的修改下载到本地，&quot;每天上班必须要做的事情&quot; 3&gt; commit 将工作提交到服务器，&quot;每天下班之前至少做一次&quot; SVN服务器安装(略) SVN常用命令 切换工作目录 $ cd 工作目录 checkout服务器上的代码仓库 $ svn co http://xxx/svn/xxxx --username=manager --password=manager 提示：checkout(co)之后，命令行会记录用户名和密码，后续操作不用再另行指定 查看本地代码库状态 $ svn st 错误提示：&quot;is not a working copy&quot;，必须在svn的工作目录下才能正确使用svn的命令 查看svn日志 $ svn log 查看某一个文件的日志 $ svn log filename 查看某一个文件某个版本的日志 $ svn log filename@1 创建文件 $ touch main.c 打开并编写文件内容 $ open main.c 查看工作目录状态 $ svn st 将文件添加到本地版本库中 $ svn add main.c/main.* 将文件提交到服务器的版本库中 $ svn ci -m &quot;备注信息&quot; 注意：一定要养成写注释的良好习惯 删除文件 $ svn rm Person.h 提交删除 $ svn ci -m &quot;删除了文件&quot; 注意：不要使用文件管理器直接删除文件 撤销修改 $ svn revert Person.m 恢复到之前的某个版本 $ svn update -r 5 冲突解决 (p) postpone 对比 (mc) mine-conflict 使用我的 (tc) theirs-conflict 使用对方的 svn st 显示的文件状态 &#39; &#39; 没有修改 &#39;A&#39; 被添加到本地代码仓库 &#39;C&#39; 冲突 &#39;D&#39; 被删除 &#39;I&#39; 被忽略 &#39;M&#39; 被修改 &#39;R&#39; 被替换 &#39;X&#39; 外部定义创建的版本目录 &#39;?&#39; 文件没有被添加到本地版本库内 &#39;!&#39; 文件丢失或者不完整（不是通过svn命令删除的文件） &#39;~&#39; 受控文件被其他文件阻隔 Git git是一款开源的分布式版本控制工具 $ git help 查看git所有命令的帮助 $ git help 子命令 要退出帮助信息，按&quot;q&quot; 翻看下页，按&quot;空格&quot; 翻看上页，按&quot;CTRL+B&quot; 要搜索相关文字，按&quot;/&quot;然后输入&quot;相关文字&quot; 创建代码仓库 $ git init 配置用户名和邮箱 $ git config user.name manager $ git config user.email manager@gmail.com 以上两个命令会将用户信息保存在当前代码仓库中 如果要一次性配置完成可以使用一下命令 $ git config --global user.name manager $ git config --global user.email manager@gmail.com 以上两个命令会将用户信息保存在用户目录下的 .gitconfig 文件中 查看当前所有配置 $ git config -l 创建代码，开始开发 $ touch main.c $ open main.c 将代码添加到代码库 查看当前代码库状态 $ git status 将文件添加到代码库 $ git add main.c 将修改提交到代码库 $ git commit -m &quot;添加了main.c&quot; 在此一定要使用 -m 参数指定修改的备注信息 否则会进入 vim 编辑器，如果对vim不熟悉，会是很糟糕的事情 将当前文件夹下的所有新建或修改的文件一次性添加到代码库 $ git add . 添加多个文件 $ touch Person.h Person.m $ git add . $ git commit -m &quot;添加了Person类&quot; $ open Person.h $ git add . $ git commit -m &quot;增加Person类属性&quot; 注意 使用git时，每一次修改都需要添加再提交，这一点是与svn不一样的 查看所有版本库日志 $ git log 查看指定文件的版本库日志 $ git log 文件名 回到当前版本，放弃所有没有提交的修改 $ git reset --hard HEAD 回到上一个版本 $ git reset --hard HEAD^ 回到之前第3个修订版本 $ git reset --hard HEAD~3 回到指定版本号的版本 $ git reset --hard e695b67 查看分支引用记录 $ git reflog 为什么要用源代码管理工具 能追踪一个项目从诞生一直到定案的过程 记录一个项目的所有内容变化 方便地查阅特定版本的修订情况 最常用的版本控制工具是什么，能大概讲讲原理么？参考答案： 最常用的版本控制工具有SourceTree（GIT）和CornerStone（SVN）； 原理提到svn是集中式代码管理，解释下具体意思，git也这样回答就行了。 集中式代码管理（SVN）的核心是服务器，所有开发者在开始新一天的工作之前必须从服务器获取代码，然后开发，最后解决冲突，提交。所有的版本信息都放在服务器上。如果脱离了服务器，开发者基本上可以说是无法工作的。 分布式的版本控制系统，在Git中并不存在主库这样的概念，每一份出的库都可以独立使用，任何两个库之间的不一致之处都可以进行合并。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS体系结构图]]></title>
    <url>%2F2018%2F09%2F11%2FiOS%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[这张图是github上一位大牛所制作。建议找工作的同学，把这张图打印出来，自己对着看，有哪些知识点遗忘的，赶紧去复习，每天过一遍，保证你面试的时候胸有成竹。 在这里，我将总结这段时间收集的和面试记录下来的各类问题，助各位同学面试一臂之力。文章如有问题，请留言，我将及时更正。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[速学block在ARC和MRC中的使用]]></title>
    <url>%2F2018%2F09%2F04%2F%E9%80%9F%E5%AD%A6block%E5%9C%A8ARC%E5%92%8CMRC%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1.ARC转MRC MRC转ARC首先, 先要了解下ARC转MRC和MRC转ARC.ARC项目转MRC创建项目, 打开Xcode, 点击项目, 找到Build Phases中的Compile Sources, 将需要转为MRC的 .m文件加入编译标记 -fno-objc-arc MRC项目转ARC给MRC项目中.m文件添加ARC标记 -fobjc-arc 2.示例演示Example A void exampleA() { char a = 'A'; ^{ printf("%c\n", a); }(); } 1.ARC和MRC都有效 ?2.只有ARC 有效?3.MRC有效 ?4.都没有效? Example B void exampleB_addBlockToArray(NSMutableArray *array) { char b = 'B'; [array addObject:^{ printf("%c\n", b); }]; } void exampleB() { NSMutableArray *array = [NSMutableArray array]; exampleB_addBlockToArray(array); void (^block)(void) = [array objectAtIndex:0]; block(); //MRC 断点查看下 __NSStackBlock__ NSLog(@"%@", [block class]);// ARC __NSMallocBlock__ } 1.ARC和MRC都有效 ?2.只有ARC 有效?3.MRC有效 ?4.都没有效? Example C void exampleC_addBlockToArray(NSMutableArray *array) { [array addObject:^{ printf("C\n"); }]; } void exampleC() { NSMutableArray *array = [NSMutableArray array]; exampleC_addBlockToArray(array); void (^block)(void) = [array objectAtIndex:0]; block(); NSLog(@"%@", [block class]); // __NSGlobalBlock__ } 1.ARC和MRC都有效 ?2.只有ARC 有效?3.MRC有效 ?4.都没有效? Example D typedef void (^dBlock)(void); dBlock exampleD_getBlock() { char d = 'D'; return ^{ printf("%c\n", d); } ; } void exampleD() { exampleD_getBlock()(); } 1.ARC和MRC都有效 ?2.只有ARC 有效?3.MRC有效 ?4.都没有效? Example E typedef void (^eBlock)(void); eBlock exampleE_getBlock() { char e = 'E'; void (^block)(void) = ^{ printf("%c\n", e); }; return block; } void exampleE() { eBlock block = exampleE_getBlock(); block(); //MRC 断点查看下 __NSStackBlock__ NSLog(@"%@", [block class]); // ARC __NSMallocBlock__ } 1.ARC和MRC都有效 ?2.只有ARC 有效?3.MRC有效 ?4.都没有效? 3.解析Example A: ARC和MRC都有效 不管在 ARC 还是 MRC 下，不论 block 存放在 stack 还是 heap 内存中，当example A 被调用时，block 仍然有效，都能正常执行. Example B: 只有ARC 有效 在 MRC 下，exampleB_addBlockToArray 中的 block 是 NSStackBlock 类型，存放在stack内存中。当执行 exampleB 时，stack 内存被释放，block 失效. 在 ARC 下，block 是 autoreleased NSMallocBlock 类型，存放在 heap 内存中，所以 Exmaple B 只有ARC 有效. Example C: ARC和MRC都有效 当 block 不需要从外部获取变量时，它不需要在 runtime 设置任何状态。此时，block 被编译成 NSGlobalBlock 类型，放在内存 data 段，就像 C 函数一样，属于代码的一部分，所以 ARC和MRC都有效. Example D: 只有ARC 有效 这题有点类似于 Example B. 在 MRC 下，exampleD_getBlock 中的block 会被创建在 stack 内存中，当函数返回时，block马上失效。鉴于本题的错误实在太明显，编译器在编译时，就会抛出错误 error: returning block that lives on the local stack. 而在 ARC 下，block 会被编译成 autoreleased NSMallocBlock 类型，存放于 heap 内存中。所以 只有ARC 有效. Example E: 只有ARC 有效 本题类似于 Example D，区别在于本题代码不会出现编译错误，而是在运行时才会崩溃。更槽糕的是，如果你关闭了编译器优化选项，代码运行正常，而无法发现这个隐藏的bug。 而在 ARC 下，block 会被编译成 autoreleased NSMallocBlock 类型，存放于 heap 内存中。所以 只有ARC 有效. 4.总结总结1: MRC 中block 没有引用外部变量, block为 NSGlobalBlock 类型,存储在全局数据区.MRC 中block 引用外部变量,block为NSStackBlock 类型,存储在栈内存中.所以, 在block所属的栈作用域外使用block时, 需要将调用copy方法将该block存储在堆区. 总结2: ARC 中 没有引用外部变量, block为 NSGlobalBlock 类型,存储在全局数据区.ARC 中 引用外部变量, block为 autoreleased NSMallocBlock 类型,存储在堆内存中. 例外:匿名block 引用外部变量 在ARC下其实很少见到 NSStackBlock 类的Block，大多数情况编译器都保证了Block是在堆上创建的 int count = 11; NSLog(@"Stack Block:%@", [^{NSLog(@"Stack Block:%d",count);} class]); //打印：Stack Block:__NSStackBlock__ 5.以上这么多例子告诉我们什么？告诉我们要使用ARC！在ARC下，block总能正确运行。如果你不用ARC，最好能保证在 stack 内存中声明定义的block，能够拷贝到heap内存，保证block的正常运行。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>block</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown语法]]></title>
    <url>%2F2018%2F08%2F30%2Fmarkdown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[欢迎使用马克飞象@(示例笔记本)[马克飞象|帮助|Markdown] 马克飞象是一款专为印象笔记（Evernote）打造的Markdown编辑器，通过精心的设计与技术实现，配合印象笔记强大的存储和同步功能，带来前所未有的书写体验。特点概述： 功能丰富 ：支持高亮代码块、LaTeX 公式、流程图，本地图片以及附件上传，甚至截图粘贴，工作学习好帮手； 得心应手 ：简洁高效的编辑器，提供[桌面客户端][1]以及[离线Chrome App][2]，支持移动端 Web； 深度整合 ：支持选择笔记本和添加标签，支持从印象笔记跳转编辑，轻松管理。 [TOC] (不支持) Markdown简介(hexo引用不一样) Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。 —— 维基百科 正如您在阅读的这份文档，它使用简单的符号标识不同的标题，将某些文字标记为粗体或者斜体，创建一个链接或一个脚注[^demo]。下面列举了几个高级功能，更多语法请按Cmd + /查看帮助。 代码块@requires_authorization def somefunc(param1='', param2=0): '''A docstring''' if param1 > param2: # interesting print 'Greater' return (param2 - param1 + 1) or None class SomeClass: pass >>> message = '''interpreter ... prompt''' LaTeX 公式 (hexo不支持此写法)可以创建行内公式，例如 $\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N$。或者块级公式： $$ x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a} $$ 表格 (不一样) Item Value Qty Computer 1600 USD 5 Phone 12 USD 12 Pipe 1 USD 234 流程图 (hexo不支持此写法)st=>start: Start e=>end op=>operation: My Operation cond=>condition: Yes or No? st->op->cond cond(yes)->e cond(no)->op 以及时序图: Alice->Bob: Hello Bob, how are you? Note right of Bob: Bob thinks Bob-->Alice: I am good thanks! 提示：想了解更多，请查看流程图[语法][3]以及时序图[语法][4]。 复选框使用 - [ ] 和 - [x] 语法可以创建复选框，实现 todo-list 等功能。例如： 已完成事项 待办事项1 待办事项2 注意：目前支持尚不完全，在印象笔记中勾选复选框是无效、不能同步的，所以必须在马克飞象中修改 Markdown 原文才可生效。下个版本将会全面支持。 印象笔记相关笔记本和标签马克飞象增加了@(笔记本)[标签A|标签B]语法, 以选择笔记本和添加标签。 绑定账号后， 输入(自动会出现笔记本列表，请从中选择。 笔记标题马克飞象会自动使用文档内出现的第一个标题作为笔记标题。例如本文，就是第一行的 欢迎使用马克飞象。 快捷编辑保存在印象笔记中的笔记，右上角会有一个红色的编辑按钮，点击后会回到马克飞象中打开并编辑该笔记。 注意：目前用户在印象笔记中单方面做的任何修改，马克飞象是无法自动感知和更新的。所以请务必回到马克飞象编辑。 数据同步马克飞象通过将Markdown原文以隐藏内容保存在笔记中的精妙设计，实现了对Markdown的存储和再次编辑。既解决了其他产品只是单向导出HTML的单薄，又规避了服务端存储Markdown带来的隐私安全问题。这样，服务端仅作为对印象笔记 API调用和数据转换之用。 隐私声明：用户所有的笔记数据，均保存在印象笔记中。马克飞象不存储用户的任何笔记数据。 离线存储马克飞象使用浏览器离线存储将内容实时保存在本地，不必担心网络断掉或浏览器崩溃。为了节省空间和避免冲突，已同步至印象笔记并且不再修改的笔记将删除部分本地缓存，不过依然可以随时通过文档管理打开。 注意：虽然浏览器存储大部分时候都比较可靠，但印象笔记作为专业云存储，更值得信赖。以防万一，请务必经常及时同步到印象笔记。 编辑器相关设置右侧系统菜单（快捷键Cmd + M）的设置中，提供了界面字体、字号、自定义CSS、vim/emacs 键盘模式等高级选项。 快捷键帮助 Cmd + /同步文档 Cmd + S创建文档 Cmd + Opt + N最大化编辑器 Cmd + Enter预览文档 Cmd + Opt + Enter文档管理 Cmd + O系统菜单 Cmd + M 加粗 Cmd + B插入图片 Cmd + G插入链接 Cmd + L提升标题 Cmd + H 关于收费马克飞象为新用户提供 10 天的试用期，试用期过后需要续费才能继续使用。未购买或者未及时续费，将不能同步新的笔记。之前保存过的笔记依然可以编辑。 反馈与建议 微博：@马克飞象，@GGock 邮箱：&#x68;&#x75;&#115;&#x74;&#x67;&#111;&#99;&#x6b;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109; 感谢阅读这份帮助文档。请点击右上角，绑定印象笔记账号，开启全新的记录与分享体验吧。 [^demo] (hexo不支持) [^demo]: 这是一个示例脚注。请查阅 MultiMarkdown 文档 关于脚注的说明。 限制： 印象笔记的笔记内容使用 [ENML][5] 格式，基于 HTML，但是不支持某些标签和属性，例如id，这就导致脚注和TOC无法正常点击。 (支持) [1]: http://maxiang.info/client_zh [2]: https://chrome.google.com/webstore/detail/kidnkfckhbdkfgbicccmdggmpgogehop [3]: http://adrai.github.io/flowchart.js/ [4]: http://bramp.github.io/js-sequence-diagrams/ [5]: https://dev.yinxiang.com/doc/articles/enml.php]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo语法体验]]></title>
    <url>%2F2018%2F08%2F30%2Fhexo%E8%AF%AD%E6%B3%95%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[Image在文章中插入指定大小的图片。 标签插件（Tag Plugins）引用块在文章中插入引言，可包含作者、来源和标题。 别号： quotecontent [author[source]] [link] [source_link_title] 样例没有提供参数，则只输出普通的 blockquote Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem. 111111 222222 333 代码块在文章中插入代码。 别名： codecode snippet 样例普通的代码块alert(&#39;Hello World!&#39;); alert(‘Hello World!’); 指定语言[rectangle setX: 10 y: 10 width: 20 height: 20]; [rectangle setX: 10 y: 10 width: 20 height: 20]; [rectangle setX: 10 y: 10 width: 20 height: 20]; 附加说明array.map(callback[, thisArg]) Array.maparray.map(callback[, thisArg]) 附加说明和网址_.compact([0, 1, false, 2, &#39;&#39;, 3]); =&gt; [1, 2, 3] _.compactUnderscore.js_.compact([0, 1, false, 2, ‘’, 3]);=&gt; [1, 2, 3] 反引号代码块另一种形式的代码块，不同的是它使用三个反引号来包裹。 [title] [url] [link text] code snippet Link在文章中插入链接，并自动给外部链接添加 target=”_blank” 属性。 text url [external] [title] Youtube在文章中插入 Youtube 视频。 Vimeo在文章中插入 Vimeo 视频。 引用文章引用其他文章的链接。 引用资源引用文章的资源。 window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdPic":"","bdStyle":"0","bdSize":"16"},"share":{},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["qzone","tsina","tqq","renren","weixin"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客开篇]]></title>
    <url>%2F2018%2F08%2F30%2F%E5%8D%9A%E5%AE%A2%E5%BC%80%E7%AF%87%2F</url>
    <content type="text"><![CDATA[终于下决心要开始写博客了，做程序员快三年了，三年的时间里，由一个嫩头青，成长为了一个能在公司项目里独立完成一些业务逻辑复杂的大模块的中坚程序员。首先我还是概括下这几年的成长历程吧。 由于本人的脸长得比较缓慢，刚出道时还是一张孩童脸，用时下流行的一个词来描述那就是“萌”。因为太萌，刚安排到客户现场做开发时，还被客户开玩笑说你们公司违法招收童工，我一怒之下蓄了几个月胡须，留了几个月飘逸的长发，想让自己在外表上看上去更老成。但不巧的是，此时的我又与那时刚出道的“犀利哥”风格极为类似，又被戏称为犀利程序哥，再怒之下，开始潜心工作，不再追求表面的浮夸，在工作中逐渐展露头角，完成了项目中几个重要需求的开发，在后来的普选中当选为公司年度优秀员工之一。最近1，2年波澜不惊，因为自学没有断过，技术也在逐步积累。 下面进入主题，关于我的博客，我用自问自答的方式来介绍： 1、我为什么要写博客？ 做程序员这几年，技术不断积累，思想不断在升华，有些思考和想法在与同事、朋友的交流中会迸发出来。在交流的过程中，我觉得很过瘾。有些模糊不清的事情，通过交流明确了，有些以为自己把握的很准的事情，通过交流颠覆了，而有些自己已经明白的事情，又开阔了新的思路。但交流只是瞬时的、已逝的，我们的讨论不是国家政要接见外国领导，没有人把我们的谈话记录下来。就像在内存里一样，断电后恢复不了，事后很难回忆起来那些曾经闪光的思想。所以我要把我在程序人生中得到的思想给持久化了，给固化下来。再一个就是，我的同事、朋友始终是我身边熟悉的人，我需要一个更大的世界，所以，我也想通过博客与大家交流！ 2、我的博客写些什么东西？ 这个问题我想了很久，以前想写些关于iOS的、关于前端博文。有时候在草稿中写好一段文字，最后一搜索，全世界拥有同样知识点的，同样解决方案的数不胜数，太多了。作为一个讨厌重复的人，我不能再罗列这些网上一抓一大把的普世技术知识点，更何况以我现在的积累，还不能做到非常好。当然我不是说罗列技术点没有技术含量，正是因为网上这些庞大的知识，我才能很快的找到我想要的，解决我的问题。综上，我不能做重复的事，也不要因为说的东西不扎实而误导别人。当然了，在某个技术领域达到一定境界了，我也会写研究技术细节的博文。 那我写什么？什么是不重复的？那必须斩钉截铁的说那就是我的思想，世上没有任何一个人和我的人生轨迹完全一样，在这个过程中，我会思考我会总结，我要把我的思想留存于世，即使有时候会有相同思想的东西同时存在，那也会因为是我个人的总结和反思而有所不同！ 3、写博客的计划？ 不追求一个月一定要写几篇几篇的，当我有深刻的感触，对事物有不同的理解，我就写一篇，记录下来，一步一个脚印，向卓越程序员迈进！ 夜空霓虹，都是我不要的繁荣，完。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[timeline]]></title>
    <url>%2Ftimeline%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[categories]]></title>
    <url>%2Fcategories%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[tags]]></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[links]]></title>
    <url>%2Flinks%2Findex.html</url>
    <content type="text"></content>
  </entry>
</search>
